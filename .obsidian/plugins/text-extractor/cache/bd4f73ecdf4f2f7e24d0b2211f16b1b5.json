{"path":"Homeworks/Submitted Answers/Theory_of_Computation___WH1.pdf","text":"Theory of Computation - HW1 Romeo Maignal, Alexandre Margery, Nobel Jaison March 2025 1 Problem 1 Let M = (Q, Σ, δ, q0, F ) be a DFA that recognizes the arbitrary language L. 1.1 Case 1: ↑L To prove that the language ↑L is regular, creating an NFA that recognizes it will suffice. A word w′ ∈ ↑L is formed from a word w ∈ L by adding phrases from u = a1a2a3...an from u ∈ Σ∗ into the word w. In other words, w corresponds to an accepting path through the state di- agram of M , where at every state q ∈ Q, we can choose to either accept a character from the string w ∈ L or accept an arbitrary phrase a from u. This process continues iteratively until we reach the state F . Consider a copy M ′ = (Q ′, Σ, δ′, q′ 0, F ′) of the DFA M = (Q, Σ, δ, q0, F ). For any state q ∈ Q, let q′ ∈ Q ′ correspond to the unique state in Q which is reached from q after adding the phrase a from u. The automata M and M ′ will correspond to the computation before and after the additional phrase a is added between the pair (q, q′). We construct an NFA N = (QN , Σ, δN , q0, FN ) where: • The states of N are QN = Q ∪ Q ′ • The transition function of N is δN (q, a) = { {δ(q, a)} if q ∈ Q {δ′(q, a)} if q ∈ Q ′ and δN (q, ε) = { {q′} if q ∈ Q ∅ else for all q ∈ QN and all a ∈ Σ. • The initial state of N is q0. • The accepting states of N are FN = F ∪ F ′. 1 To every q′ ∈ Q ′, we insert a transition (q′, a, q′) where a ∈ Σ. This allows the automata to ”expand” and accept an arbitrary number of phrases a in be- tween accepting the characters from w. The NFA N is illustrated below: M q0start q1 q2 qn−1 qn Fn M ′ q′ 0 q′ 1 q′ 2 q′ n−1 q′ n Fn w0 w1 . . . wn w0 w1 . . . wn a a a a a ε ε ε ε ε We now prove that L(N ) =↑ L using inclusion in both directions. If u ∈↑ L, then there are a1, ..., an and u0, ..., un with u = u0a1u1a2···anun and a1···an ∈ L. Since M accepts a1 · · · an, there is some corresponding accepting path P through M. By following the same path, the automaton N can process the string u0 in the part given by M and end up either in a state from which there is a consecutive series of state q or q′ (meaning you never encountered any scattered subword a) , or in a state from which there is a non-consecutive series of state q and q′ (meaning you encountered scattered subword a represented by the self-pointing arrows at each state of the automata M ). Thus, by definition of δN , there is an ϵ-transition to the part given by M ′ and also a q-transition to the part given by M . There we again follow the path P while processing y before reaching an accepting state. Hence, N accepts u = u0a1u1a2 · · · anun, as desired. Conversely, let u ∈ L(N ). Thus, there must be a corresponding accepting path P through N . Since N starts from q0 ∈ Q and its two accepting states are both in Q and Q ′, we are free to take at any point a transition from Q to Q ′. But the only such transitions are the one-way ϵ-transitions given by the pairs (q, q′), so we must make use of exactly one of them. If we now replace this tran- sition with the corresponding pair of consecutive arrows labeled w, we retrieve an accepting path through M of some string a1 · · · an with u0a1u1a2 · · · anun = u that ends in F instead of F ′. We conclude that M accepts a1 · · · an, implying 2 that a1 · · · an ∈ L and therefore u ∈↑ L. 1.2 Case 2: ↓L To prove that the language ↓L is regular, creating an NFA that recognizes it will suffice. A word w′ ∈ ↓L is formed from a word w ∈ L by arbitrarily removing characters w0, w1, w2, ..., wn from w = w0a1w1a2...anwn where w ∈ L such that we are left with w′ = a1a2a3...an remaining, where w′ ∈ Σ∗. In other words, w′ corresponds to an accepting path through the state dia- gram of M , where at every state q ∈ Q \\ {q0}, we can choose to either accept a character from the string w ∈ L, accept an arbitrary phrase a from u, or also skip to the next state by reading ε. This process continues iteratively until we reach the state F . Consider a copy M ′ = (Q ′, Σ, δ′, q′ 0, F ′) of the DFA M = (Q, Σ, δ, q0, F ). For any state q ∈ Q, let q′ ∈ Q ′ correspond to the unique state in Q which is reached from q after skipping the added phrase a from u. The automata M and M ′ will correspond to the computation before and after the additional phrase a is skipped between the pair (q, q′). We construct an NFA N = (QN , Σ, δN , q0, FN ) where: • The states of N are QN = Q ∪ Q ′ • The transition function of N is δN (q, a) = { {δ(q, a)} if q ∈ Q {δ′(q, a)} if q ∈ Q ′ and δN (q, ε) = {{q′} if q ∈ Q ∅ else for all q ∈ QN and all a ∈ Σ. • The initial state of N is q0. • The accepting states of N are FN = F ′. In q′ ∈ Q ′, for every transition (q′, a, q′) where a ∈ Σ and q′ ̸= q′, we add an ε transition as well. This allows the automata to ”skip” an arbitrary number of characters from w0, w1, w2, ..., wn leaving behind the phrases w′ = a1a2a3...an. The NFA N is illustrated below: 3 M q0start q1 q2 qn−1 qn Fn M ′ q′ 0 q′ 1 q′ 2 q′ n−1 q′ n Fn w0 w1 . . . wn w0 ε w1 ε . . . ε wn ε ε a a a a a ε ε ε ε ε We now prove that L(N ) =↓ L using inclusion in both directions. If u ∈↓ L, then there are a1, ..., an with u = a1 · · · anu0 and a1u1a2 · · · anun ∈ L. Since M accepts a1u1a2 · · · anun, there is some corresponding accepting path P through M. By following the same path, the automaton N can process the string u0 in the part given by M and end up either in a state from which there is a consecutive series of state q or q′ (meaning you never encountered any scattered subword a or encountered a series of ϵ-transition), or in a state from which there is a non-consecutive series of state q and q′ (meaning you encountered scattered subword a represented by the self-pointing arrows at each state of the automata M ). Thus, by definition of δN , there is an ϵ-transition to the part given by M ′ and also a q-transition to the part given by M . There we again follow the path P while processing y before reaching an accepting state. Hence, N accepts u = a1a2 · · · an, as desired. Conversely, let u ∈ L(N ). Thus, there must be a corresponding accepting path P through N . Since N starts from q0 ∈ Q and its two accepting states are both in Q and Q ′, we are free to take at any point a transition from Q to Q ′. But the only such transitions are the one-way ϵ-transitions given by the pairs (q, q′), so we must make use of exactly one of them. If we now replace this tran- sition with the corresponding pair of consecutive arrows labeled w, we retrieve an accepting path through M of some string a1, ..., an with a1 · · · anu0 = u that ends in F instead of F ′. We conclude that M accepts a1u1a2 · · · anun, implying that a1u1a2 · · · anun ∈ L and therefore u ∈↓ L. 4 2 Problem 2 2.1 A way to build an O(n) NFA for this is to in essence make every possible “missing symbol” have its own state. Here, we use the NFA’s ability to have multiple transitions per symbol to make each transition go from the start state to the state k, with all symbols *except* k. On the right is a drawing that illustrates this construction. Every state is an accept state, and thus the machine will accept the input so long as not all of the branches “die out”, which will happen only if its missing symbol appears in the string. This guaranteees that a string is only accepted if at least one symbol is still missing by the end of it. This is O(n) because adding a new symbol to the alphabet only requires adding one new state: the one tracking strings that are missing that symbol. q0start q2 q1 qn−1 qn 2,3,...,n 1,3,...,n 1,2,...,n-2,n 1,2,...,n-1 2,3,...,n 1,3,...,n 1,2,...,n-2,n 1,2,...,n-1 2.2 Here, as we cannot have multiple transitions for the same symbol, we need to instead keep track of which subset of the alphabet we have seen in the current string. The initial state is an accept state that corresponds to the empty subset, and it links to a row of states that correspond to a single symbol. Each of these states loop to themselves when their own symbol appears, and otherwise lead to a second layer which represents subsets of 2 symbols. This continues, with there being as many layers as there are symbols in the alphabet. All these states are accept states except for the very last one: The one containing the full alphabet. This means it will accept strings that contain any subset except for the full alphabet. An example is displayed here for n = 3. We know this is of size 2n, because since there is one state corresponding to each subset of the alphabet, the amount of states is equal to the size of the Powerset of n elements, which is 2n. 5 ∅start q2 q1 q3 q12 q13 q23 q123 1 2 3 2 3 1 3 1 2 3 2 1 2.3 Since we know that |P (n)| = 2 n elements, an amount of states lesser than 2n would imply two subsets of the alphabet share a state, by the pigeonhole principle. This means there will be at least one symbol x that is part of one of these subsets, but not the other. By having these subsets share a state, we have essentially ’lost track’ of x; We cannot tell whether a string contains this symbol or not, and we cannot distinguish strings such as W and the concatenation xW. Thus, if we find now every symbol but x, the full alphabet Σn will share a state with the full alphabet minus x, Σn\\x. Since Σn\\x is supposed to be an accept state, but not Σn, this means that the DFA does not recognize the correct language: It either recognizes both Σn and Σn\\x, or it recognizes neither. 6","libVersion":"0.5.0","langs":""}