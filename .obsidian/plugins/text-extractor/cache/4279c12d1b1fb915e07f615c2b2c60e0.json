{"path":"Exercises/Solutions/ToC ex 7 sol.pdf","text":"Exercise VII, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. Problems marked * are more difficult but also more fun :). These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. Problems on Mapping Reductions 1 Show that ≤m is a transitive relation on languages, i.e., if A ≤m B and B ≤m C then A ≤m C. Solution: Suppose A ≤m B and B ≤m C. That is, there are computable functions f, g with x ∈ A ⇐⇒ f (x) ∈ B and y ∈ B ⇐⇒ g(y) ∈ C. Now let h(x) = g(f (x)) and note that x ∈ A ⇐⇒ h(x) ∈ C. It remains to prove that h is computable by building a Turing machine that computes h. By assumption there are Turing machines F and G that compute f and g, respectively. Now consider the Turing machine that, on input x, does the following: first, simulates F on x and store the output y. hen simulate a G on y and return the result. This machine thus computes h(x) = g(f (x)). Hence, h is computable, so A ≤m C. 2 Show that if A is a Turing-recognizable language and A ≤m A, then A is decidable. Solution: Since A ≤m A, we also have A ≤m A (see exercise 1 from last week). Since A is recognizable and A ≤m A, we have that A is recognizable as well. Since A and A are both recognizable, A is decidable. 3* Show that a language A ⊆ {0, 1}∗ is decidable if and only if A ≤m {0a1b | a, b ≥ 0}. Solution: We prove the two directions separately. Suppose that A ≤m {0a1b | a, b ≥ 0}. We know that {0a1b | a, b ≥ 0} is a decidable language, since it is accepted by the following DFA: 0 1 1 0 0,1 Thus, A can be reduced to a decidable language, and is therefore also decidable. Now suppose that A is decidable and let M be the Turing machine that decides A. Consider the following algorithm. On input w, do: 1. Run M on input w. Page 1 (of 5) CS-251 Theory of Computation • Spring 2025 2. If the computation accepts, output 01. Otherwise, output 10. This algorithm clearly halts on every input and thus defines a computable function f . Moreover, we show that w ∈ A ⇐⇒ f (w) ∈ 0∗1∗. • If w ∈ A, then M (w) accepts. Hence, f (w) = 01 ∈ 0∗1∗. • If w ̸∈ A, then M (w) rejects. Hence, f (w) = 10 ̸∈ 0∗1∗. Therefore, A ≤m 0∗1∗ as desired. 4 A useless state in a Turing machine is a state that is never entered on any input string. Consider the problem of determining whether a Turing machine has any useless states. Formulate this problem as a language and show that it is undecidable. Solution: We define the language Useless = { ⟨M ⟩ : M has a useless state}. We show that Useless is undecidable by showing that AT M ≤m Useless. We construct the corresponding computable function f via the following algorithm. On input ⟨M, w⟩, do: 1. Construct a Turing machine T which on input x, does: (a) If x = ε, then T rejects. (b) Else, T simulates M (w). (c) If M (w) accepts, then T also accepts. (d) If M (w) rejects, then T also rejects. 2. Output T . Note that this algorithm always halts. We can assume that T has no useless states, possibly with the exception of the accept and reject states. Without loss of generality, assume that the input alphabet of T is {0, 1}, has start state q1, and the ability to not move the head after a transition. We now alter T by adding two new tape symbols s0 and s1, as well as a new start state q0. Let q0, q1, q2, . . . , qk be an enumeration of the non-terminal states of T . On some (non- empty) input, T now does the following: It replaces the first symbol a by sa on the tape and goes to state q2 without moving the head. Then, reading sa from the tape, it loops though the states q2, q3, . . . , qk, without changing the tape symbol or moving the head. Finally, from state qk, it changes the first symbol of the tape back from sa to a and goes to state q1, without moving the head. After that, the machine operates exactly like the original T would. It is not hard to see that T has no non-terminal useless states and agrees with the original machine on all inputs. It remains to show that ⟨M, w⟩ ∈ AT M ⇐⇒ T ∈ Useless. • Suppose ⟨M, w⟩ ∈ AT M . Then M (w) accepts and thus T accepts all inputs besides the empty string. Hence, T has no useless states and T ̸∈ Useless • Suppose ⟨M, w⟩ ̸∈ AT M . Then T rejects or loops on all inputs. Hence, the accept state of T is a useless state and T ∈ Useless This concludes the proof of the reduction. Since AT M is undecidable, so is Useless. Note that this argument even shows that Useless is unrecognisable. Page 2 (of 5) CS-251 Theory of Computation • Spring 2025 Problems on Time Complexity 5 Arrange the following functions in increasing order according to asymptotic growth. 2 n, (n 5 ) , (log log n)10, n300, √n, (log n)n, n/ log n, 22n, n√n, n!, log n Solution: (log log n) 10 < log n < √n < n/ log n < ( n 5 ) < n 300 < n √n < 2 n < (log n)n < n! < 22n . 6* We call an undirected graph G = (V, E) Eulerian if there is a closed walk (i.e. returning to where it starts) on G that uses each edge exactly once. Show that the language Eulerian-Graph = { ⟨G⟩ : G is Eulerian} is in P by giving an algorithm and bounding its running time as a polynomial in |V | and |E|. Hint: FirstprovethataconnectedgraphisEulerianiffeveryvertexhasevendegree. Solution: We first prove the correctness of the claim in the hint: A connected graph is Eulerian iff every vertex has an even degree. We show the two directions separately. • Suppose G is Eulerian and consider a closed walk on G that uses every edge exactly once. For any vertex v, the walk must enter and exit v an equal number of times. Therefore, the degree of v is even. • Assuming the other direction is false, let G be the connected graph with the fewest edges that is not Eulerian, but in which every vertex has even degree. Since G is connected and has at least two vertices, every vertex of G has degree at least 2, which means G is not a tree. Hence, there must be some cycle C in G. Let H = G \\ C and let H1, H2, . . . , Hk be the connected components of H. Note that for all i, Hi is connected and every vertex in Hi has even degree. Moreover, each Hi has strictly fewer edges than G, so must be Eulerian by assumption. Let Wi be a closed walk on Hi that uses each of its edges exactly once. Since G was connected, each Wi must share a vertex with C. Now consider the closed walk on G that goes around C, while taking each detour Wi exactly once. This walk visits every edge of G exactly, which means that G is Eulerian, a contradiction. Now we give an algorithm that decides Eulerian-Graph using the above characterization. On input ⟨G⟩, do: 1. Check if G is connected (e.g. by breadth-first-search from an arbitrary vertex). 2. If G is disconnected, reject. 3. Else, iterate over all vertices v of G and do: (a) If v has odd degree, reject. 4. Else, if all degrees are even, accept. Note that this algorithm takes at most O(|V | + |E|) many fundamental steps. Hence, Eulerian-Graph is in P as desired. Page 3 (of 5) CS-251 Theory of Computation • Spring 2025 7 Which of the following operations is the complexity class P closed under? 7a Union 7b Intersection 7c Complementation 7d* Kleene closure Solution: 7a (Union) Let L1 and L2 be two languages in P, decidable by deterministic polynomial-time machines M1 and M2, respectively. We construct a deterministic polynomial-time machine M for L1 ∪ L2 as follows. On input x, do: 1. Run M1(x). If M1(x) accepts, accept. 2. Run M2(x). If M2(x) accepts, accept. 3. Reject. The machine M accepts x if either of the two machines accepts x, and rejects otherwise. Hence, M decides L1 ∪ L2. Since both M1 and M2 run in polynomial time, M runs in polynomial time too. We can conclude P is closed under the union operation. 7b (Intersection) Let L1 and L2 be two languages in P, decidable by deterministic polynomial- time machines M1 and M2, respectively. We construct a deterministic polynomial-time machine M for L1 ∩ L2 as follows. On input x do: 1. Run M1(x). If M1(x) rejects, reject. 2. Run M2(x). If M2(x) rejects, reject. 3. Accept. The machine M accepts x if both machines accept x, and rejects otherwise. Hence, M decides L1 ∩ L2. Since both M1 and M2 run in polynomial time, M runs in polynomial time too. We can conclude P is closed under the intersection operation. 7c (Complementation) Let L be a language in P, decidable by a deterministic polynomial- time machine M . We construct a deterministic polynomial-time machine M ′ for L as follows. On input x, do: 1. Run M (x). 2. If M (x) rejects, accept. 3. If M (x) accepts, reject. The machine M ′ accepts x if and only if M rejects x. Hence, M ′ decides L. Since M runs in polynomial time, M ′ runs in polynomial time too. We can conclude P is closed under the complementation operation. Page 4 (of 5) CS-251 Theory of Computation • Spring 2025 7d (Kleene closure) Let L be a language in P, decidable by a deterministic polynomial-time machine M . We construct a deterministic polynomial-time machine M ′ for L∗ as follows. On input w, do: 1. If w = ϵ, accept. 2. Let w = w1w2 . . . wn. 3. Initialize an array A of length n with all 0’s. 4. For each j = 1, 2, . . . , n: (a) Simulate M on input w1 . . . wj. (b) If M accepted, set A[j] = 1. (c) For each i = 2, 3, . . . , j: i. Simulate M on input wi . . . wj. ii. If M accepted and A[i − 1] = 1, set A[j] = 1. 5. If A[n] = 1, accept. Otherwise, reject. In the above construction, we use a technique called dynamic programming. The idea is to store solutions of smaller sub-problems to solve the entire problem. A word w is in L∗ if and only if either w is in L, or if it can be written as w = w′w0 with w′ ∈ L∗ and w0 ∈ L. We used an array A to store the results of the sub-problems asking if the prefixes of w are in L∗. Since there are only finitely many indices where we could split the word w, we can loop over all these possibilities. Note that we need to iterate over all possible split locations from smallest to largest, to ensure that we have already solved all of the required sub-problems we might need later on. Now we argue that M ′ runs in polynomial-time. M ′ has two nested loops. Assuming that M runs in time O(nd) for some d ∈ N, the complexity of M ′ is thus O(n) · (O(nd) + O(n)), which is polynomial. Hence, P is closed under the Kleene star operation. Page 5 (of 5) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}