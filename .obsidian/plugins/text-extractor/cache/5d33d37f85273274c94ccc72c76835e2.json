{"path":"Lectures/Lecture8.pdf","text":"Lecture 8: The Class NP Mika GÃ¶Ã¶s School of Computer and Communication Sciences Lecture 8 Recall: Time Complexity Lecture 8 Time Complexity of a TM Deï¬nition: Let M be a TM that halts on all inputs (decider). The running time or time complexity of M is the function t : N â†’ N where t(n) = max w âˆˆÎ£âˆ—:|w |=n number of steps M takes on w Deï¬nition: Time complexity class TIME (t(n)) = {L âŠ† Î£âˆ— | L is decided by a TM with running time O(t(n))} Lecture 8 The class P Deï¬nition: P is the class of languages that are decidable in polynomial time on a deterministic Turing machine. In other words, P = âˆâ‹ƒ k=1 TIME (nk ) . Some languages in P: â–¶ {âŸ¨AâŸ© : A is a sorted array of integers} â–¶ {âŸ¨G, s, tâŸ© : s and t are vertices connected in graph G} (Breadth-First Search) â–¶ {âŸ¨GâŸ© : G is a connected graph} Lecture 8 NP: Easy-to-verify problems Lecture 8 The class NP Deï¬nition: A veriï¬er for a language A is a TM V , where A = {w | âˆƒC s.t. V accepts âŸ¨w , C âŸ©} . (Here C is called a certiï¬cate or witness) A polynomial time veriï¬er runs in polynomial time in |w|. Deï¬nition: NP is the class of languages with polynomial time veriï¬ers Lecture 8 Why is it called NP? Lecture 8 Detour: Non-deterministic Turing Machines Recall: In a Turing machine, Î´ : (Q Ã— Î“) âˆ’â†’ Q Ã— Î“ Ã— {L, R}. In a Nondeterministic Turing Machine (NTM), Î´ : (Q Ã— Î“) âˆ’â†’ P(Q Ã— Î“ Ã— {L, R}) (several possible transitions for a given state and tape symbol) Deï¬nition: A nondeterministic decider for language L is an NTM N such that for each x âˆˆ Î£âˆ—, every computation of N on x halts, and moreover, â–¶ If x âˆˆ L, then some computation of N on x accepts. â–¶ If x < L, then every computation of N on x rejects. An NTM is a polynomial time NTM if the running time its longest computation on x is polynomial in |x|. Lecture 8 Nondeterministic deciders â‡â‡’ Veriï¬ers Theorem: For any language L âŠ† Î£âˆ—, L has a nondeterministic poly-time decider â‡â‡’ L has a poly-time veriï¬er. Proof Sketch (â‡=): Let V be the veriï¬er. NTM N on input x does the following: 1 Write a certiï¬cate C nondeterministically. 2 Run V on âŸ¨x , C âŸ© and accept accordingly. Proof Sketch (=â‡’): Let N be the nondeterministic decider. Veriï¬er V on âŸ¨x , C âŸ© computes: 1 Interpret C as a sequence of transitions of N. 2 Simulate N on x , choosing transitions given by C . Now x âˆˆ L iï¬€ there exists C such that V accepts âŸ¨x , C âŸ©. Lecture 8 Non-deterministic Polynomial-time Theorem: For any language L âŠ† Î£âˆ—, L has a nondeterministic poly-time decider â‡â‡’ L has a poly-time veriï¬er. Deï¬nition: NP is the class of languages which have poly-time nonde- terministic deciders, or equivalently, have poly-time veriï¬ers. Deï¬nition: NTIME(t(n)) = {L : L has a nondeterministic O(t(n)) time decider} Then NP = âˆâ‹ƒ k=1 NTIME(nk ) . Lecture 8 Example problems in NP Lecture 8 Satisï¬ability problem, SAT Conjunctive Normal Form (CNF) Formula: Ï•1 = (x âˆ¨ y âˆ¨ z0) âˆ§ (x âˆ¨ y âˆ¨ z1) âˆ§ (x âˆ¨ y âˆ¨ z2) âˆ§ (x âˆ¨ y âˆ¨ z3) Ï•2 = x1 âˆ§ (x1 âˆ¨ x2) âˆ§ (x1 âˆ¨ x2 âˆ¨ x3) âˆ§ (x1 âˆ¨ x2 âˆ¨ x3 âˆ¨ x4) Ï•3 = x1 âˆ§ (x1 âˆ¨ x2) âˆ§ (x1 âˆ¨ x2) â–¶ CNF Formula: AND of Clauses â–¶ Clause: OR of Literals â–¶ Literal: variable or its negation Satisfying assignment: Boolean assignment to variables which makes the formula TRUE. Check: Ï•1 has 32 satisfying assignments, Ï•2 as only one, Ï•3 has zero. A formula is satisï¬able if it has at least one satisfying assignment. Lecture 8 Satisï¬ability problem, SAT SAT = {âŸ¨Ï•âŸ© : Ï• is satisï¬able} = {âŸ¨Ï•âŸ© : âˆƒC such that C evaluates Ï• to TRUE} SAT is in NP Poly-time veriï¬er for SAT: 1 Given input âŸ¨Ï•, C âŸ©: 2 Interpret C as a truth assignment to the variables of Ï•. 3 Substitute values for literals according to C . 4 Check that every clause has at least one TRUE literal. 5 Accept iï¬€ all checks pass. SAT = {âŸ¨Ï•âŸ© : âˆƒC s.t. the above veriï¬er accepts âŸ¨Ï•, C âŸ©} Lecture 8 Graph isomorphism, GI a bc d e f 1 2 3 4 5 6 Graph Isomorphism: Bijection f : V (G1) âˆ’â†’ V (G2) which preserves adjacency: {u, v } âˆˆ E (G1) â‡” {f (u), f (v )} âˆˆ E (G2) Eg. a â†’ 1 b â†’ 2 c â†’ 3 d â†’ 4 e â†’ 5 f â†’ 6 in the graphs above. Two graphs are isomorphic if they have at least one graph isomorphism. Lecture 8 Graph isomorphism, GI GI = {âŸ¨G1, G2âŸ© : G1 and G2 are isomorphic} GI is in NP Poly-time veriï¬er for GI: 1 Given input âŸ¨G1, G2, C âŸ©: 2 Interpret C as a function V (G1) â†’ V (G2). 3 Check that C is a bijection. 4 Check that C preserves adjacency, that is, for each u, v âˆˆ V (G1): â–¶ {u, v } âˆˆ E (G1) â‡” {C (u), C (v )} âˆˆ E (G2). 5 Accept iï¬€ all checks pass. GI = {âŸ¨G1, G2âŸ© : âˆƒC s.t. above veriï¬er accepts âŸ¨G1, G2, C âŸ©} Lecture 8 Independent set, INDSET 1 2 3 4 5 6 Independent Set: Subset S âŠ† V (G) such that no two vertices in S are adjacent in G. Eg. {1, 3, 5}, {2, 4}, {6}, âˆ…, etc. in the graph above. Lecture 8 Independent set, INDSET INDSET = {âŸ¨G, kâŸ© : G has an independent of size k} INDSET is in NP Poly-time veriï¬er for INDSET: 1 On input âŸ¨G, k, C âŸ©: 2 Interpret C as a subset C âŠ† V (G) 3 Check that |C | = k. 4 For each u, v âˆˆ C , check {u, v } < E (G). 5 Accept iï¬€ all checks pass. INDSET = {âŸ¨G, kâŸ© : âˆƒC s.t. above veriï¬er accepts âŸ¨G, k, C âŸ©} Lecture 8 P and NP Is P âŠ† NP? Yes (obviously) Is P = NP? Nobody knows . . . Find the answer and win USD 1,000,000! NP SAT INDSET GI? P GI? P=NP SAT INDSET GI Cook-Levin Theorem (informal): SAT âˆˆ P iï¬€ P = NP. (Also INDSET âˆˆ P iï¬€ P = NP.) Lecture 8 Polynomial-Time Reductions Lecture 8 Reductions Part 1: Poly-time Computability Reductions Part 1: Computability 0 0 1 0 1 1 0 1 âŠ” 1 1 1 0 âŠ” âŠ” âŠ” âŠ” âŠ” ğ‘¤ ğ‘‡ğ‘€ğ‘“ ğ‘“(ğ‘¤) ğ‘“ Î£ â‹† Î£ â‹† ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘£1 ğ‘£2 ğ‘£3ğ‘¤4 ğ‘£3ğ‘¤4 Definition: A function ğ‘“:Î£ â‹†â†’ Î£ â‹†is a computable function if some TM ğ‘€, on every input ğ‘¤ halts with just ğ‘“(ğ‘¤)on its tape Deï¬nition: A function f : Î£ âˆ— â†’ Î£âˆ— is a poly-time computable function if some poly-time TM M, on every input w halts with just f (w ) on its tape. Lecture 8 Reductions Part 2: Correctness Reductions Part 2: Correctness Definition: Language ğ´ is mapping reducible to language ğµ,written ğ‘¨ â‰¤ğ’ ğ‘©,if there is a computable function ğ‘“:Î£ â‹†â†’ Î£ â‹†,such that for every ğ‘¤ âˆˆÎ£ â‹†: ğ’˜âˆˆğ‘¨ âŸº ğ’‡ğ’˜ âˆˆğ‘© Î£ â‹† Î£ â‹† ğ‘“ ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘£1 ğ‘£2 ğ‘£3 ğ´ ğ‘¤4à´¥ğ´ ğµ à´¤ğµğ‘£4ğ‘¤4 Reduction Mapping may not be Surjective ğ‘£3 ğ‘£5 Deï¬nition: Language A is poly-time mapping reducible to language B, written A â‰¤P B, if there is a poly-time computable function f : Î£ âˆ— â†’ Î£âˆ—, such that for every w âˆˆ Î£âˆ—: w âˆˆ A â‡” f (w ) âˆˆ B Lecture 8 Theorem: If A â‰¤P B and B is in P, then A is in P. Proof: â–¶ Assume that M is an O(np)-time decider for B and f is an O(nq)-time reduction from A to B. â–¶ Let N be a TM as follows: â€¢ Assume that ğ‘´ is a decider for ğ‘©and ğ‘“is a reduction from ğ´ to ğµ â€¢ Let ğ‘ be a TM as follows: â€¢ ğ‘ =â€œOn input ğ‘¤: 1. Compute ğ‘“(ğ‘¤) 2. Run ğ‘€ on input ğ‘“(ğ‘¤)and output whatever ğ‘€ outputs\" ğ‘¤ ğ‘“(ğ‘¤) ğ‘€ ğ‘ ğ‘“ Computability of ğ‘“â‡’ N is a decider Correctness of ğ‘“â‡’ N decides A Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is decidable, then ğ´ is decidable Corollary: If ğ´ â‰¤ğ‘š ğµ and ğ´ is undecidable, then ğµ is undecidable Proof: â–¶ N = â€œOn input w : 1 Compute f (w ) (O(|w |q) time; |f (w )| = O(|w |q)) 2 Run M on input f (w ) and output whatever M outputsâ€ (O(|w |pq) time) â€¢ Assume that ğ‘´ is a decider for ğ‘©and ğ‘“is a reduction from ğ´ to ğµ â€¢ Let ğ‘ be a TM as follows: â€¢ ğ‘ =â€œOn input ğ‘¤: 1. Compute ğ‘“(ğ‘¤) 2. Run ğ‘€ on input ğ‘“(ğ‘¤)and output whatever ğ‘€ outputs\" ğ‘¤ ğ‘“(ğ‘¤) ğ‘€ ğ‘ ğ‘“ Computability of ğ‘“â‡’ N is a decider Correctness of ğ‘“â‡’ N decides A Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is decidable, then ğ´ is decidable Corollary: If ğ´ â‰¤ğ‘š ğµ and ğ´ is undecidable, then ğµ is undecidable Proof: Corollary: If A â‰¤P B and A is not in P, then B is not in P. Lecture 8 Theorem: If A â‰¤P B and B â‰¤P C , then A â‰¤P C . (i.e. â‰¤P is transitive.) Proof: â–¶ Assume fAB is an O(np)-time reduction from A to B and fBC is an O(nq)-time reduction from B to C . â–¶ N = â€œOn input w : 1 Compute fAB(w ) (O(|w |p) time; |f (w )| = O(|w |p)) 2 Compute fBC (fAB(w ))â€ (O(|w |pq) time) â–¶ N computes a poly-time reduction A â‰¤P C . Lecture 8 NP-completeness Deï¬nition: A language L is said to be NP-complete if â–¶ L is in NP. â–¶ For every language L â€² in NP, Lâ€² â‰¤P L. Observe: If one NP-complete language has a polynomial time decider, then every language in NP has a polynomial time decider, i.e. P = NP. The Cook-Levin Theorem: SAT is NP-complete. To show L is NP-complete: â–¶ [NP membership] Give a poly-time veriï¬er for L. â–¶ [NP hardness] Show that SAT â‰¤P L (or take any L âˆ— already proven to be NP-complete, and show L âˆ— â‰¤P L). Lecture 8 Examples of NP-completeness proofs Lecture 8 3SAT is NP-complete kSAT = {Ï• : Ï• is satisï¬able and each clause of Ï• contains â‰¤ k literals} Veriï¬er for 3SAT: Just use the veriï¬er for SAT. Claim: SAT â‰¤P 3SAT Reduction: Given Ï•, â–¶ While Ï• contains a clause K = (â„“1 âˆ¨ â„“2 âˆ¨ â„“3 âˆ¨ Â· Â· Â· âˆ¨ â„“m) with > 3 literals Replace K with the following two clauses K1 = (â„“1 âˆ¨ â„“2 âˆ¨ z) K2 = (z âˆ¨ â„“3 âˆ¨ Â· Â· Â· âˆ¨ â„“m) ï£¼ ï£´ï£´ï£½ ï£´ï£´ï£¾ Preserves satisï¬ability (check!) What is the runtime? Does SAT â‰¤P 2SAT analogously? Lecture 8 INDSET is NP-complete Claim: SAT â‰¤P INDSET Ï• = x1ï¸¸ï¸·ï¸·ï¸¸ K1 âˆ§ (x1 âˆ¨ x2) ï¸¸ ï¸·ï¸· ï¸¸ K2 âˆ§ (x1 âˆ¨ x2 âˆ¨ x3) ï¸¸ ï¸·ï¸· ï¸¸ K3 âˆ§ (x1 âˆ¨ x2 âˆ¨ x3 âˆ¨ x4) ï¸¸ ï¸·ï¸· ï¸¸ K4 x1 x1 x2 x1 x2 x3 x1 x2 x3 x4 K1 K2 K3 K4 Lecture 8 INDSET is NP-complete Claim: SAT â‰¤P INDSET Reduction f : On input Ï•, 1 Let G be the graph generated as follows. 1 Take a vertex for each literal of each clause. 2 Add edges for pairs of conï¬‚icting literals. 3 Add edges for pairs of literals from the same clause. 2 Let m be the number of clauses in Ï•. 3 Output (G, m). Claim: Ï• âˆˆ SAT =â‡’ f (Ï•) âˆˆ INDSET Proof: C : satisfying assignment of Ï•. Pick one true literal from each clause. The corresponding vertices form a independent set. Claim: f (Ï•) âˆˆ INDSET =â‡’ Ï• âˆˆ SAT Proof: C : independent set in G, |C | = m. C contains one vertex from each group. Set the corresponding literals to true to get a satisfying assignment. Lecture 8 Next class Will continue NP-completeness. Lecture 8","libVersion":"0.5.0","langs":""}