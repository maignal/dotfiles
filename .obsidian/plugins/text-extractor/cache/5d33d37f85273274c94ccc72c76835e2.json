{"path":"Lectures/Lecture8.pdf","text":"Lecture 8: The Class NP Mika Göös School of Computer and Communication Sciences Lecture 8 Recall: Time Complexity Lecture 8 Time Complexity of a TM Deﬁnition: Let M be a TM that halts on all inputs (decider). The running time or time complexity of M is the function t : N → N where t(n) = max w ∈Σ∗:|w |=n number of steps M takes on w Deﬁnition: Time complexity class TIME (t(n)) = {L ⊆ Σ∗ | L is decided by a TM with running time O(t(n))} Lecture 8 The class P Deﬁnition: P is the class of languages that are decidable in polynomial time on a deterministic Turing machine. In other words, P = ∞⋃ k=1 TIME (nk ) . Some languages in P: ▶ {⟨A⟩ : A is a sorted array of integers} ▶ {⟨G, s, t⟩ : s and t are vertices connected in graph G} (Breadth-First Search) ▶ {⟨G⟩ : G is a connected graph} Lecture 8 NP: Easy-to-verify problems Lecture 8 The class NP Deﬁnition: A veriﬁer for a language A is a TM V , where A = {w | ∃C s.t. V accepts ⟨w , C ⟩} . (Here C is called a certiﬁcate or witness) A polynomial time veriﬁer runs in polynomial time in |w|. Deﬁnition: NP is the class of languages with polynomial time veriﬁers Lecture 8 Why is it called NP? Lecture 8 Detour: Non-deterministic Turing Machines Recall: In a Turing machine, δ : (Q × Γ) −→ Q × Γ × {L, R}. In a Nondeterministic Turing Machine (NTM), δ : (Q × Γ) −→ P(Q × Γ × {L, R}) (several possible transitions for a given state and tape symbol) Deﬁnition: A nondeterministic decider for language L is an NTM N such that for each x ∈ Σ∗, every computation of N on x halts, and moreover, ▶ If x ∈ L, then some computation of N on x accepts. ▶ If x < L, then every computation of N on x rejects. An NTM is a polynomial time NTM if the running time its longest computation on x is polynomial in |x|. Lecture 8 Nondeterministic deciders ⇐⇒ Veriﬁers Theorem: For any language L ⊆ Σ∗, L has a nondeterministic poly-time decider ⇐⇒ L has a poly-time veriﬁer. Proof Sketch (⇐=): Let V be the veriﬁer. NTM N on input x does the following: 1 Write a certiﬁcate C nondeterministically. 2 Run V on ⟨x , C ⟩ and accept accordingly. Proof Sketch (=⇒): Let N be the nondeterministic decider. Veriﬁer V on ⟨x , C ⟩ computes: 1 Interpret C as a sequence of transitions of N. 2 Simulate N on x , choosing transitions given by C . Now x ∈ L iﬀ there exists C such that V accepts ⟨x , C ⟩. Lecture 8 Non-deterministic Polynomial-time Theorem: For any language L ⊆ Σ∗, L has a nondeterministic poly-time decider ⇐⇒ L has a poly-time veriﬁer. Deﬁnition: NP is the class of languages which have poly-time nonde- terministic deciders, or equivalently, have poly-time veriﬁers. Deﬁnition: NTIME(t(n)) = {L : L has a nondeterministic O(t(n)) time decider} Then NP = ∞⋃ k=1 NTIME(nk ) . Lecture 8 Example problems in NP Lecture 8 Satisﬁability problem, SAT Conjunctive Normal Form (CNF) Formula: ϕ1 = (x ∨ y ∨ z0) ∧ (x ∨ y ∨ z1) ∧ (x ∨ y ∨ z2) ∧ (x ∨ y ∨ z3) ϕ2 = x1 ∧ (x1 ∨ x2) ∧ (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x2 ∨ x3 ∨ x4) ϕ3 = x1 ∧ (x1 ∨ x2) ∧ (x1 ∨ x2) ▶ CNF Formula: AND of Clauses ▶ Clause: OR of Literals ▶ Literal: variable or its negation Satisfying assignment: Boolean assignment to variables which makes the formula TRUE. Check: ϕ1 has 32 satisfying assignments, ϕ2 as only one, ϕ3 has zero. A formula is satisﬁable if it has at least one satisfying assignment. Lecture 8 Satisﬁability problem, SAT SAT = {⟨ϕ⟩ : ϕ is satisﬁable} = {⟨ϕ⟩ : ∃C such that C evaluates ϕ to TRUE} SAT is in NP Poly-time veriﬁer for SAT: 1 Given input ⟨ϕ, C ⟩: 2 Interpret C as a truth assignment to the variables of ϕ. 3 Substitute values for literals according to C . 4 Check that every clause has at least one TRUE literal. 5 Accept iﬀ all checks pass. SAT = {⟨ϕ⟩ : ∃C s.t. the above veriﬁer accepts ⟨ϕ, C ⟩} Lecture 8 Graph isomorphism, GI a bc d e f 1 2 3 4 5 6 Graph Isomorphism: Bijection f : V (G1) −→ V (G2) which preserves adjacency: {u, v } ∈ E (G1) ⇔ {f (u), f (v )} ∈ E (G2) Eg. a → 1 b → 2 c → 3 d → 4 e → 5 f → 6 in the graphs above. Two graphs are isomorphic if they have at least one graph isomorphism. Lecture 8 Graph isomorphism, GI GI = {⟨G1, G2⟩ : G1 and G2 are isomorphic} GI is in NP Poly-time veriﬁer for GI: 1 Given input ⟨G1, G2, C ⟩: 2 Interpret C as a function V (G1) → V (G2). 3 Check that C is a bijection. 4 Check that C preserves adjacency, that is, for each u, v ∈ V (G1): ▶ {u, v } ∈ E (G1) ⇔ {C (u), C (v )} ∈ E (G2). 5 Accept iﬀ all checks pass. GI = {⟨G1, G2⟩ : ∃C s.t. above veriﬁer accepts ⟨G1, G2, C ⟩} Lecture 8 Independent set, INDSET 1 2 3 4 5 6 Independent Set: Subset S ⊆ V (G) such that no two vertices in S are adjacent in G. Eg. {1, 3, 5}, {2, 4}, {6}, ∅, etc. in the graph above. Lecture 8 Independent set, INDSET INDSET = {⟨G, k⟩ : G has an independent of size k} INDSET is in NP Poly-time veriﬁer for INDSET: 1 On input ⟨G, k, C ⟩: 2 Interpret C as a subset C ⊆ V (G) 3 Check that |C | = k. 4 For each u, v ∈ C , check {u, v } < E (G). 5 Accept iﬀ all checks pass. INDSET = {⟨G, k⟩ : ∃C s.t. above veriﬁer accepts ⟨G, k, C ⟩} Lecture 8 P and NP Is P ⊆ NP? Yes (obviously) Is P = NP? Nobody knows . . . Find the answer and win USD 1,000,000! NP SAT INDSET GI? P GI? P=NP SAT INDSET GI Cook-Levin Theorem (informal): SAT ∈ P iﬀ P = NP. (Also INDSET ∈ P iﬀ P = NP.) Lecture 8 Polynomial-Time Reductions Lecture 8 Reductions Part 1: Poly-time Computability Reductions Part 1: Computability 0 0 1 0 1 1 0 1 ⊔ 1 1 1 0 ⊔ ⊔ ⊔ ⊔ ⊔ 𝑤 𝑇𝑀𝑓 𝑓(𝑤) 𝑓 Σ ⋆ Σ ⋆ 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3𝑤4 𝑣3𝑤4 Definition: A function 𝑓:Σ ⋆→ Σ ⋆is a computable function if some TM 𝑀, on every input 𝑤 halts with just 𝑓(𝑤)on its tape Deﬁnition: A function f : Σ ∗ → Σ∗ is a poly-time computable function if some poly-time TM M, on every input w halts with just f (w ) on its tape. Lecture 8 Reductions Part 2: Correctness Reductions Part 2: Correctness Definition: Language 𝐴 is mapping reducible to language 𝐵,written 𝑨 ≤𝒎 𝑩,if there is a computable function 𝑓:Σ ⋆→ Σ ⋆,such that for every 𝑤 ∈Σ ⋆: 𝒘∈𝑨 ⟺ 𝒇𝒘 ∈𝑩 Σ ⋆ Σ ⋆ 𝑓 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3 𝐴 𝑤4ഥ𝐴 𝐵 ത𝐵𝑣4𝑤4 Reduction Mapping may not be Surjective 𝑣3 𝑣5 Deﬁnition: Language A is poly-time mapping reducible to language B, written A ≤P B, if there is a poly-time computable function f : Σ ∗ → Σ∗, such that for every w ∈ Σ∗: w ∈ A ⇔ f (w ) ∈ B Lecture 8 Theorem: If A ≤P B and B is in P, then A is in P. Proof: ▶ Assume that M is an O(np)-time decider for B and f is an O(nq)-time reduction from A to B. ▶ Let N be a TM as follows: • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: ▶ N = “On input w : 1 Compute f (w ) (O(|w |q) time; |f (w )| = O(|w |q)) 2 Run M on input f (w ) and output whatever M outputs” (O(|w |pq) time) • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: Corollary: If A ≤P B and A is not in P, then B is not in P. Lecture 8 Theorem: If A ≤P B and B ≤P C , then A ≤P C . (i.e. ≤P is transitive.) Proof: ▶ Assume fAB is an O(np)-time reduction from A to B and fBC is an O(nq)-time reduction from B to C . ▶ N = “On input w : 1 Compute fAB(w ) (O(|w |p) time; |f (w )| = O(|w |p)) 2 Compute fBC (fAB(w ))” (O(|w |pq) time) ▶ N computes a poly-time reduction A ≤P C . Lecture 8 NP-completeness Deﬁnition: A language L is said to be NP-complete if ▶ L is in NP. ▶ For every language L ′ in NP, L′ ≤P L. Observe: If one NP-complete language has a polynomial time decider, then every language in NP has a polynomial time decider, i.e. P = NP. The Cook-Levin Theorem: SAT is NP-complete. To show L is NP-complete: ▶ [NP membership] Give a poly-time veriﬁer for L. ▶ [NP hardness] Show that SAT ≤P L (or take any L ∗ already proven to be NP-complete, and show L ∗ ≤P L). Lecture 8 Examples of NP-completeness proofs Lecture 8 3SAT is NP-complete kSAT = {ϕ : ϕ is satisﬁable and each clause of ϕ contains ≤ k literals} Veriﬁer for 3SAT: Just use the veriﬁer for SAT. Claim: SAT ≤P 3SAT Reduction: Given ϕ, ▶ While ϕ contains a clause K = (ℓ1 ∨ ℓ2 ∨ ℓ3 ∨ · · · ∨ ℓm) with > 3 literals Replace K with the following two clauses K1 = (ℓ1 ∨ ℓ2 ∨ z) K2 = (z ∨ ℓ3 ∨ · · · ∨ ℓm)    Preserves satisﬁability (check!) What is the runtime? Does SAT ≤P 2SAT analogously? Lecture 8 INDSET is NP-complete Claim: SAT ≤P INDSET ϕ = x1︸︷︷︸ K1 ∧ (x1 ∨ x2) ︸ ︷︷ ︸ K2 ∧ (x1 ∨ x2 ∨ x3) ︸ ︷︷ ︸ K3 ∧ (x1 ∨ x2 ∨ x3 ∨ x4) ︸ ︷︷ ︸ K4 x1 x1 x2 x1 x2 x3 x1 x2 x3 x4 K1 K2 K3 K4 Lecture 8 INDSET is NP-complete Claim: SAT ≤P INDSET Reduction f : On input ϕ, 1 Let G be the graph generated as follows. 1 Take a vertex for each literal of each clause. 2 Add edges for pairs of conﬂicting literals. 3 Add edges for pairs of literals from the same clause. 2 Let m be the number of clauses in ϕ. 3 Output (G, m). Claim: ϕ ∈ SAT =⇒ f (ϕ) ∈ INDSET Proof: C : satisfying assignment of ϕ. Pick one true literal from each clause. The corresponding vertices form a independent set. Claim: f (ϕ) ∈ INDSET =⇒ ϕ ∈ SAT Proof: C : independent set in G, |C | = m. C contains one vertex from each group. Set the corresponding literals to true to get a satisfying assignment. Lecture 8 Next class Will continue NP-completeness. Lecture 8","libVersion":"0.5.0","langs":""}