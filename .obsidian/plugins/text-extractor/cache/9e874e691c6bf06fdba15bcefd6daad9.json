{"path":"Lectures/Lecture6.pdf","text":"Lecture 6: Reductions Mika Göös School of Computer and Communication Sciences Lecture 6 Recall Lecture 6 Turing-Recognizable/Decidable Languages A TM machine M recognizes a language L ⊆ Σ∗ iﬀ for all inputs w ∈ Σ∗: 1 If w ∈ L then M accepts w and 2 If w < L then M either rejects w or never halts Such languages are called (Turing)-Recognizable A TM machine M decides a language L ⊆ Σ∗ iﬀ for all inputs w ∈ Σ∗: 1 M halts on w , and 2 M accepts w iﬀ w ∈ L Such languages are called (Turing)-Decidable Lecture 6 Undecidable Languages Lecture 6 There are undecidable languages ▶ Turing machines are countable: enumerate all encodings ⟨M1⟩ ⟨M2⟩ ⟨M3⟩ ⟨M4⟩ ⟨M5⟩ ⟨M6⟩ . . . M1 A ∞ R A A R . . . M2 R R A A ∞ A . . . M3 R ∞ A ∞ R R . . . M4 A ∞ R R R ∞ . . . M5 ∞ ∞ A A A A . . . M6 R A R ∞ A ∞ . . . ... ... ... ... ... ... ... DIAG R A R A R A Let DIAG = {⟨Mi ⟩ : Mi doesn’t accept ⟨Mi ⟩} = {⟨M2⟩, ⟨M4⟩, ⟨M6⟩, . . .} Then DIAG , L(Mi ) for all i ∈ N. That is, DIAG is undecidable Lecture 6 Thm: ATM = {⟨M, w ⟩ : M is a TM and M accepts w } is undecidable Proof by contradiction Assume on the contrary that H is a decider for ATM Thm: 𝐴𝑇𝑀is Undecidable. Assume on the contrary that 𝑯 is a decider for 𝐴𝑇𝑀 𝐻〈𝑀,𝑤〉 Accept (𝑀 accepts 𝑤) Reject (𝑀doesn’t accept 𝑤) We construct a decider 𝑫for 𝑳𝑫𝑰𝑨𝑮using 𝑯 and encoder/decoder functions for strings/TMs. Accept 𝑤 𝑖 𝑤𝑖(=𝑤) 〈𝑀𝑖,𝑤𝑖〉 𝐻 𝐷 Accept Reject𝑀𝑖 Reject STR-DEC STR-ENC TM-DEC Proof: (by contradiction) Need to prove that 𝑫decides 𝑳𝑫𝑰𝑨𝑮! We construct a decider D for DIAG = {⟨Mi ⟩ : Mi doesn’t accept ⟨Mi ⟩} using H: w 2 {0, 1}⇤ <latexit sha1_base64=\"kLQXTNA20UKi4EHQhjXIsU+PQ3Y=\">AAAB+XicbVBNS8NAEJ3Ur1q/oh69LLaCiJSkHhRPBS8eK9gPaGLZbDft0s0m7G4qJfSfePGgiFf/iTf/jds2B60+GHi8N8PMvCDhTGnH+bIKK6tr6xvFzdLW9s7unr1/0FJxKgltkpjHshNgRTkTtKmZ5rSTSIqjgNN2MLqZ+e0xlYrF4l5PEupHeCBYyAjWRurZduXRYwJ5mXPuetOHs0rPLjtVZw70l7g5KUOORs/+9PoxSSMqNOFYqa7rJNrPsNSMcDoteamiCSYjPKBdQwWOqPKz+eVTdGKUPgpjaUpoNFd/TmQ4UmoSBaYzwnqolr2Z+J/XTXV45WdMJKmmgiwWhSlHOkazGFCfSUo0nxiCiWTmVkSGWGKiTVglE4K7/PJf0qpV3Ytq7a5Wrl/ncRThCI7hFFy4hDrcQgOaQGAMT/ACr1ZmPVtv1vuitWDlM4fwC9bHN01xkhw=</latexit> Let Mi be TM with encoding w,i.e., hMii = w <latexit sha1_base64=\"+sdWX7toMZuvj55n0g/8TEEnQgs=\">AAACPXicbVBNSxxBFOzRJJqNSVY95vLITsCDDDPrISIIgpccFBR2VdgZlp6et7uN/TF097gsi3/Mi//BW25ePCji1au9HwejKWgoqt6jX1VeCm5dHP8NFhY/fPy0tPy59mXl67fv9dW1E6srw7DNtNDmLKcWBVfYdtwJPCsNUpkLPM3P9yf+6QUay7VquVGJmaR9xXucUeelbr2VKs1VgcrBAToID7s8hByhdQhD7gZp2mlKmQEqpguu+hAOw03gEUabEKaCqr5A8DuQmhmHXRiG3XojjuIp4D1J5qRB5jjq1m/SQrNK+jOYoNZ2krh02Zgax5nAy1paWSwpO6d97HiqqESbjafpL+GXVwroaeOfjzFVX2+MqbR2JHM/Kakb2LfeRPyf16lcbzsbc1VWzueffdSrBDgNkyqh4AaZEyNPKDPc3wpsQA1lzhde8yUkbyO/JyfNKNmKmsfNxt7OvI5l8oP8JBskIb/JHvlDjkibMHJFbsk9eQiug7vgMXiajS4E85118g+C5xfy3KrH</latexit> Mi, hMii <latexit sha1_base64=\"aeAU0Hqg7ho2+SfqUHUFDpMUEyQ=\">AAACA3icbZDLSgMxFIYz9VbrbdSdboKt4ELKTF0orgpu3AgV7AU6Q8mkZ9rQTGZIMkIpBTe+ihsXirj1Jdz5NqbTWWj1h8CX/5xDcv4g4Uxpx/myCkvLK6trxfXSxubW9o69u9dScSopNGnMY9kJiALOBDQ10xw6iQQSBRzawehqVm/fg1QsFnd6nIAfkYFgIaNEG6tnH1RueuwUe5yIAQdsLtiTGVd6dtmpOpnwX3BzKKNcjZ796fVjmkYgNOVEqa7rJNqfEKkZ5TAteamChNARGUDXoCARKH+S7TDFx8bp4zCW5giNM/fnxIRESo2jwHRGRA/VYm1m/lfrpjq88CdMJKkGQecPhSnHOsazQHCfSaCajw0QKpn5K6ZDIgnVJraSCcFdXPkvtGpV96xau62V65d5HEV0iI7QCXLROaqja9RATUTRA3pCL+jVerSerTfrfd5asPKZffRL1sc3wneWSw==</latexit> H Accept Reject Accept Reject Need to prove that D decides DIAG: 1 D halts on all inputs 2 D accepts ⟨M⟩ ⇐⇒ M does not accept ⟨M⟩ ⇐⇒ ⟨M⟩ ∈ DIAG Lecture 6 Regular Decidable Recognizable ? Unrecognizable languages? Lecture 6 Unrecognizable languages exist! Thm: ATM is not recognizable Follows because ATM is recognizable and since Thm: A language L is decidable iﬀ it is recognizable and its complement is also recognizable Lecture 6 Reductions Lecture 6 A Reduction . . . A Reduction … 𝑁𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 ≠∅} 𝐿𝑝𝑎𝑡ℎ≔ 𝐺,𝑣,𝑤 𝑣,𝑤 ∈𝑉𝐺 and ∃a path from 𝑣 to 𝑤 in 𝐺} 𝑞2𝑞0 𝑞11 0 01 1 0 1 3 21 5 6 4 1,6 Input: Input: 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷 31 2 𝐺 1,3 Accept ⇒Accept Reject ⇒Reject The reduction does not use the knowledge whether 𝐷 is in the language 𝑁𝐸𝐷𝐹𝐴or not! 𝑞2𝑞0 𝑞11 0 0 1 0 1 31 2 0 1,3 A Reduction … 𝑁𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 ≠∅} 𝐿𝑝𝑎𝑡ℎ≔ 𝐺,𝑣,𝑤 𝑣,𝑤 ∈𝑉𝐺 and ∃a path from 𝑣 to 𝑤 in 𝐺} 𝑞2𝑞0 𝑞11 0 01 1 0 1 3 21 5 6 4 1,6 Input: Input: 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷 31 2 𝐺 1,3 Accept ⇒Accept Reject ⇒Reject The reduction does not use the knowledge whether 𝐷 is in the language 𝑁𝐸𝐷𝐹𝐴or not! 𝑞2𝑞0 𝑞11 0 0 1 0 1 31 2 0 1,3 A Reduction … 𝑁𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 ≠∅} 𝐿𝑝𝑎𝑡ℎ≔ 𝐺,𝑣,𝑤 𝑣,𝑤 ∈𝑉𝐺 and ∃a path from 𝑣 to 𝑤 in 𝐺} 𝑞2𝑞0 𝑞11 0 01 1 0 1 3 21 5 6 4 1,6 Input: Input: 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷 31 2 𝐺 1,3 Accept ⇒Accept Reject ⇒Reject The reduction does not use the knowledge whether 𝐷 is in the language 𝑁𝐸𝐷𝐹𝐴or not! 𝑞2𝑞0 𝑞11 0 0 1 0 1 31 2 0 1,3 A Reduction … 𝑁𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 ≠∅} 𝐿𝑝𝑎𝑡ℎ≔ 𝐺,𝑣,𝑤 𝑣,𝑤 ∈𝑉𝐺 and ∃a path from 𝑣 to 𝑤 in 𝐺} 𝑞2𝑞0 𝑞11 0 01 1 0 1 3 21 5 6 4 1,6 Input: Input: 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷 31 2 𝐺 1,3 Accept ⇒Accept Reject ⇒Reject The reduction does not use the knowledge whether 𝐷 is in the language 𝑁𝐸𝐷𝐹𝐴or not! 𝑞2𝑞0 𝑞11 0 0 1 0 1 31 2 0 1,3 A Reduction … 𝑁𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 ≠∅} 𝐿𝑝𝑎𝑡ℎ≔ 𝐺,𝑣,𝑤 𝑣,𝑤 ∈𝑉𝐺 and ∃a path from 𝑣 to 𝑤 in 𝐺} 𝑞2𝑞0 𝑞11 0 01 1 0 1 3 21 5 6 4 1,6 Input: Input: 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷 31 2 𝐺 1,3 Accept ⇒Accept Reject ⇒Reject The reduction does not use the knowledge whether 𝐷 is in the language 𝑁𝐸𝐷𝐹𝐴or not! 𝑞2𝑞0 𝑞11 0 0 1 0 1 31 2 0 1,3 Lecture 6 A reduction . . . Yes (path exists) No (no path) 𝑇𝑀𝑝𝑎𝑡ℎ𝐺,𝑣,𝑤 𝒇∶ 𝐷 DisaDFA} → { 𝐺,𝑣,𝑤 |𝐺is a directed graph, 𝑣,𝑤 ∈𝑉(𝐺)} 〈𝐷〉can be in 𝑁𝐸𝐷𝐹𝐴or not A Reduction … 𝐷 𝐺,𝑣,𝑤 𝑇𝑀𝑝𝑎𝑡ℎ Yes (𝐿 𝐷 ≠∅) No (𝐿 𝐷 =∅) 𝑇𝑀𝑛𝑜𝑛−𝑒𝑚𝑝𝑡𝑦 Reduction 𝒇 There might or might not be a path from 𝑣 to 𝑤 Lecture 6 Informally Reducibility Use knowledge about complexity of one language to reason about the complexity of other in an easy way Reduction Way to show that to solve one problem (A), it is suﬃcient to solve another problem (B) A reduces to B. . . ▶ Many examples (e.g. calculate area of rectangle reduces to calculate its width and height) ▶ Reductions quantify relative hardness of problems ▶ If problem B is easy then problem A is easy too ▶ If problem A is hard then problem B is hard too Lecture 6 Some Examples Lecture 6 HALT = {⟨M, w ⟩ | M halts on input w } Theorem: HALT is undecidable Proof: Assume on the contrary that HALT is decided by H 𝐻𝐴𝐿𝑇𝑇𝑀={𝑀,𝑤 :𝑀 is a TM and 𝑀 halts on 𝑤} Theorem: 𝐻𝐴𝐿𝑇𝑇𝑀is undecidable 𝐻〈𝑀,𝑤〉 Accept (𝑀 halts on 𝑤) Reject (𝑀 doesnot halton 𝑤) 〈𝑀,𝑤〉 𝐻 Accept Reject Run 𝑀 on 𝑤 Accept Accept Reject Reject Reject Proof. Assume on the contrary that 𝐻𝐴𝐿𝑇𝑇𝑀is decided by 𝐻 Decider 𝑁 for 𝐴𝑇𝑀 Pass the same input to 𝐻 Construct a decider for ATM = {⟨M, w ⟩ : M accepts w } 𝐻𝐴𝐿𝑇𝑇𝑀={𝑀,𝑤 :𝑀 is a TM and 𝑀 halts on 𝑤} Theorem: 𝐻𝐴𝐿𝑇𝑇𝑀is undecidable 𝐻〈𝑀,𝑤〉 Accept (𝑀 halts on 𝑤) Reject (𝑀 doesnot halton 𝑤) 〈𝑀,𝑤〉 𝐻 Accept Reject Run 𝑀 on 𝑤 Accept Accept Reject Reject Reject Proof. Assume on the contrary that 𝐻𝐴𝐿𝑇𝑇𝑀is decided by 𝐻 Decider 𝑁 for 𝐴𝑇𝑀 Pass the same input to 𝐻 Lecture 6 Theorem: REGTM = {⟨N⟩ | L(N) is regular} is undecidable Proof: Assume on the contrary that REGTM is decided by R Theorem: 𝑅𝐸𝐺𝑇𝑀≔ 𝑁 𝐿 𝑁 is regular}is undecidable Proof. Assume on the contrary that 𝑅𝐸𝐺𝑇𝑀is decided by 𝑅 𝑅〈𝑁〉 Accept (𝐿(𝑁)regular) Reject (𝐿(𝑁)not regular) Can we decide 𝐴𝑇𝑀using 𝑅? We would like: given 〈𝑴,𝒘〉, construct a Turing Machine 𝑻𝑴〈𝑴,𝒘〉such that: • If 𝑴,𝒘 ∈ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is regular and • If 𝑴,𝒘 ∉ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is non-regular (For example 𝟎 𝒏𝟏 𝒏:𝒏∈ ℕ) 〈𝑀,𝑤〉 〈𝑇𝑀 𝑀,𝑤 〉 𝑅 Decider for 𝐴𝑇𝑀 𝑓 Input of 𝐴𝑇𝑀: 〈𝑀,𝑤〉 Input of 𝑅: 〈𝑁〉 𝑓 Can we decide ATM using R? We’d like: given ⟨M, w ⟩, construct a TM TM⟨M,w ⟩ such that ▶ If ⟨M, w ⟩ ∈ ATM ⇒ L(⟨TM⟨M,w ⟩⟩) is regular ▶ If ⟨M, w ⟩ < ATM ⇒ L(⟨TM⟨M,w ⟩⟩) is non-regular (for example {0n1n | n ∈ N}) Theorem: 𝑅𝐸𝐺𝑇𝑀≔ 𝑁 𝐿 𝑁 is regular}is undecidable Proof. Assume on the contrary that 𝑅𝐸𝐺𝑇𝑀is decided by 𝑅 𝑅〈𝑁〉 Accept (𝐿(𝑁)regular) Reject (𝐿(𝑁)not regular) Can we decide 𝐴𝑇𝑀using 𝑅? We would like: given 〈𝑴,𝒘〉, construct a Turing Machine 𝑻𝑴〈𝑴,𝒘〉such that: • If 𝑴,𝒘 ∈ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is regular and • If 𝑴,𝒘 ∉ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is non-regular (For example 𝟎 𝒏𝟏 𝒏:𝒏∈ ℕ) 〈𝑀,𝑤〉 〈𝑇𝑀 𝑀,𝑤 〉 𝑅 Decider for 𝐴𝑇𝑀 𝑓 Input of 𝐴𝑇𝑀: 〈𝑀,𝑤〉 Input of 𝑅: 〈𝑁〉 𝑓 Theorem: 𝑅𝐸𝐺𝑇𝑀≔ 𝑁 𝐿 𝑁 is regular}is undecidable Proof. Assume on the contrary that 𝑅𝐸𝐺𝑇𝑀is decided by 𝑅 𝑅〈𝑁〉 Accept (𝐿(𝑁)regular) Reject (𝐿(𝑁)not regular) Can we decide 𝐴𝑇𝑀using 𝑅? We would like: given 〈𝑴,𝒘〉, construct a Turing Machine 𝑻𝑴〈𝑴,𝒘〉such that: • If 𝑴,𝒘 ∈ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is regular and • If 𝑴,𝒘 ∉ 𝑨𝑻𝑴⟹ L(𝑇𝑀 𝑀,𝑤 )is non-regular (For example 𝟎 𝒏𝟏 𝒏:𝒏∈ ℕ) 〈𝑀,𝑤〉 〈𝑇𝑀 𝑀,𝑤 〉 𝑅 Decider for 𝐴𝑇𝑀 𝑓 Input of 𝐴𝑇𝑀: 〈𝑀,𝑤〉 Input of 𝑅: 〈𝑁〉 𝑓 Lecture 6 Theorem: REGTM = {⟨N⟩ | L(N) is regular} is undecidable Theorem: 𝑅𝐸𝐺𝑇𝑀≔ 𝑁 𝐿 𝑁 is reg.}is undecidable 〈𝑀,𝑤〉 〈𝑇𝑀 𝑀,𝑤 〉 𝑅 Decider for 𝐴𝑇𝑀 𝐌,𝐰 → 〈𝐓𝐌 𝐌,𝐰 〉 Accepts a non-regular language 0 𝑛1 𝑛:𝑛∈ℕ if M does not accept w and accepts 0,1 ⋆(regular) if M accepts w Reduction 𝑦 Yes No 𝑻𝑴〈𝑴,𝒘〉 Does 𝑦belong to 0𝑛1𝑛:𝑛∈ℕ ? Run 𝑀 on 𝑤 Accept Reject Accept Lecture 6 Formalising reductions Lecture 6 Reductions Part 1: Computability Reductions Part 1: Computability 0 0 1 0 1 1 0 1 ⊔ 1 1 1 0 ⊔ ⊔ ⊔ ⊔ ⊔ 𝑤 𝑇𝑀𝑓 𝑓(𝑤) 𝑓 Σ ⋆ Σ ⋆ 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3𝑤4 𝑣3𝑤4 Definition: A function 𝑓:Σ ⋆→ Σ ⋆is a computable function if some TM 𝑀, on every input 𝑤 halts with just 𝑓(𝑤)on its tape Deﬁnition: A function f : Σ ∗ → Σ∗ is a computable function if some TM M, on every input w halts with just f (w ) on its tape Lecture 6 Reductions Part 2: Correctness Reductions Part 2: Correctness Definition: Language 𝐴 is mapping reducible to language 𝐵,written 𝑨 ≤𝒎 𝑩,if there is a computable function 𝑓:Σ ⋆→ Σ ⋆,such that for every 𝑤 ∈Σ ⋆: 𝒘∈𝑨 ⟺ 𝒇𝒘 ∈𝑩 Σ ⋆ Σ ⋆ 𝑓 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3 𝐴 𝑤4ഥ𝐴 𝐵 ത𝐵𝑣4𝑤4 Reduction Mapping may not be Surjective 𝑣3 𝑣5 Deﬁnition: Language A is mapping reducible to language B, written A ≤m B, if there is a computable function f : Σ ∗ → Σ∗, such that for every w ∈ Σ∗: w ∈ A ⇔ f (w ) ∈ B Lecture 6 Theorem: If A ≤m B and B is decidable, then A is decidable Proof: ▶ Assume that M is a decider for B and f is a reduction from A to B ▶ Let N be a TM as follows: • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: ▶ N = “On input w : 1 Compute f (w ) 2 Run M on input f (w ) and output whatever M outputs” • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: Corollary: If A ≤m B and A is undecidable, then B is undecidable Lecture 6 Examples of Reductions Lecture 6 HALTTM = {⟨M, w ⟩ | M halts on w } ATM = {⟨M, w ⟩ | M accepts w } Theorem: ATM ≤m HALTTM Proof idea: TMATM TMHALTreduction f⟨M, w ⟩ ∈ {0, 1} ∗ ⟨M ′, w ′⟩ accept reject Deﬁne computable f such that ATM ATM HALTTM HALTTM f Lecture 6 Theorem: ATM ≤m HALT (⇒ HALT is undecidable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M ′, w ⟩, where ▶ M ′ =“On input y : 1 Run M on y ; 2 If M rejects y , enter inﬁnite loop. If M accepts y , accept y . ▶ Check that f is computable • Let us define a function 𝑓as follows • Given an input 𝑥 ≔ 𝑀,𝑤 , return 𝑓𝑥 ≔ 𝑀′,𝑤 where • 𝑀’=“On input 𝑦 ∶ (1) Run 𝑀 on 𝑤; (2) If 𝑴 rejects 𝒘, enter infinite loop. Otherwise, accept y\" • Check that 𝑓is computable Theorem: 𝐴𝑇𝑀≤𝑚 𝐻𝐴𝐿𝑇𝑇𝑀 (⇒ 𝐻𝐴𝐿𝑇𝑇𝑀is undecidable) • ⇒If 𝑀,𝑤 ∈ 𝐴𝑇𝑀then 𝑀′halts on 𝑤. Thus, 𝑀′,𝑤 ∈ 𝐻𝐴𝐿𝑇𝑇𝑀 • ֚If 𝑀,𝑤 ∉ 𝐴𝑇𝑀then either (1) will never halt or 𝑀 rejects 𝑤 and (2) will ensure no halting. Thus, 𝑀′,𝑤 ∉ 𝐻𝐴𝐿𝑇𝑇𝑀 𝑓has to write down the code of 𝑀′only. It does not run 𝑀′! (𝑀′might loop for some inputs.) ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M ′ halts on w . Thus, ⟨M ′, w ⟩ ∈ HALT ▶ ⇐ If ⟨M, w ⟩ < ATM then either (1) will never halt or M rejects w and (2) will ensure no halting. Thus, ⟨M ′, w ⟩ < HALT Lecture 6 Theorem: ATM ≤m REGTM (⇒ REGTM is undecidable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M ′⟩, where ▶ M ′ =“On input y : 1 if y ∈ B = {0n1n : n ≥ 0}, then accept y 2 Run M on w , and accept y iﬀ M accepts w ” ▶ Check that f is computable ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M ′ accepts all inputs. Thus, L(M ′) = {0, 1} ∗ is regular — ⟨M ′⟩ ∈ REGTM ▶ ⇐ If ⟨M, w ⟩ < ATM then M does not accept w . Thus L(M ′) = B is non-regular — ⟨M ′⟩ < REGTM Lecture 6 Theorem: If A ≤m B and B is recognizable then A is recognizable Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is recognizable, then 𝐴 is recognizable 𝑀accepts 𝑤 ⟺ 𝑅𝐵accepts 𝑓𝑤 ⟺ 𝑓𝑤 ∈𝐵 ⟺ 𝑤∈𝐴 Definition of 𝑀 𝐴 ≤𝑚 𝐵 𝑅𝐵is a recognizer for 𝐵 ⇒ 𝑴 is a recognizer for 𝑨 𝑤 𝑓𝑤 𝑅𝐵 𝑀 𝑓 Corollary: If 𝐴 ≤𝑚 𝐵 and A is unrecognizable, then 𝐵 is unrecognizable Proof. Corollary: If A ≤m B and A is unrecognizable then B is unrecognizable Lecture 6 EQTM = {⟨M1, M2⟩ | M1, M2 are TMs s.t. L(M1) = L(M2)} Theorem: ATM ≤m EQTM (⇒ EQTM is unrecognizable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M1, M2⟩, where ▶ M1 =“On input y : 1 Run M on w (ignore the input y ) 2 If M accepts then accept, else enter an inﬁnite loop ▶ M2 =“On input y : 1 Reject y ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M1 loops on all inputs. Thus, L(M1) = ∅ = L(M2) — ⟨M1, M2⟩ ∈ EQTM ▶ ⇐ If ⟨M, w ⟩ < ATM then M accepts w and hence M1 accepts every string. Thus L(M1) = Σ ∗ , ∅ = L(M2) — ⟨M1, M2⟩ < EQTM Lecture 6 Summary Summary Definition: 𝑓:Σ1 ⋆→ Σ2 ⋆is a computable function if some TM 𝑀, on every input 𝑤halts with just 𝑓(𝑤)on its tape Definition: 𝐴 is mapping reducible to 𝐵,(𝐴 ≤𝑚 𝐵),if there exists 𝑓:Σ1 ⋆→ Σ2 ⋆, 𝑓computable, s.t. ∀𝑤∈Σ⋆: 𝑤∈A⟺ 𝑓𝑤 ∈𝐵 𝑓is called a reduction of 𝐴 to 𝐵 Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is recognizable (decidable), then 𝐴 is recognizable (decidable) Theorem: If 𝐴 ≤𝑚 𝐵 and A is unrecognizable (undecidable) , then 𝐵 is unrecognizable (undecidable) 𝐴 𝐵𝑓 𝑓 Σ⋆ Σ ⋆ Deﬁnition: A function f : Σ∗ → Σ∗ is a computable function if some TM M, on every input w halts with just f (w ) on its tape Deﬁnition: Language A is mapping reducible to language B, written A ≤m B, if there is a computable function f : Σ∗ → Σ∗, such that for every w ∈ Σ∗: w ∈ A ⇔ f (w ) ∈ B f is called a reduction from A to B Theorem: If A ≤m B and B is decidable (recognizable), then A is decidable (recognizable) Corollary: If A ≤m B and A is undecidable (unrecognizable) then B is undecidable (unrecognizable) Lecture 6 Next week: Recap of reductions! Lecture 6","libVersion":"0.5.0","langs":""}