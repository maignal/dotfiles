{"path":"Exercises/Solutions/ToC ex 10 sol.pdf","text":"Exercise X, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. 1 A formula is in Disjunctive Normal Form (DNF) if it is an OR (∨) of a number of terms, where each term is an AND (∧) of literals, as for example (x ∧ y ∧ ¯z) ∨ (¯y ∧ z) ∨ (¯x ∧ ¯y). Define DNF-SAT = {⟨φ⟩ : φ is a DNF formula and φ is satisfiable}. 1a Prove that DNF-SAT is in P. 1b What is wrong with the following reasoning? Suppose we are given a 3CNF formula, and we want to know if it is satisfiable. We can repeatedly use the distributive law (φ1 ∨ φ2) ∧ ψ ≡ (φ1 ∧ ψ) ∨ (φ2 ∧ ψ) to construct an equivalent DNF formula. For instance, (x ∨ y ∨ ¯z) ∧ (¯x ∨ ¯y) ≡ (x ∧ ¯x) ∨ (x ∧ ¯y) ∨ (y ∧ ¯x) ∨ (y ∧ ¯y) ∨ (¯z ∧ ¯x) ∨ (¯z ∧ ¯y). Then, using the algorithm from Part (a) we can determine, in polynomial time, whether the resulting DNF formula is satisfiable. We have just solved 3SAT in polynomial time. Since 3SAT is NP-complete, we conclude that P = NP. Solution: 1a On its own, any single clause is satisfiable if and only if it does not contain both a variable and its negation. If it does, then the clearly the clause cannot be satisfied. Else, every literal in the clause can just be set to true. Since the clauses are connected by OR, it is enough to satisfy just one clause. Thus, our algorithm is as follows: For each clause in the formula determine whether it is satisfiable or not according to the above rule. If at least one is, we return yes, if none are, we return no. 1b The reduction is correct, however, it does not run in polynomial time. In fact, in the general case, when we have n clauses of 3 variables each, applying the distributive law repeatedly yields a DNF with 3n clauses. When we call upon the algorithm from part 1, it will have runtime polynomial in 3n, which is exponential in n. Page 1 (of 3) CS-251 Theory of Computation • Spring 2025 2 Prove that the following language is NP-complete: L = {⟨G = (V, E), k⟩ : there exist disjoint S1, S2 ⊆ V , such that |S1|, |S2| ≥ k, S1 is an independent set in G and S2 is a clique in G}. Solution: We first prove the problem is in NP and then we prove it in NP-hard by a reduction from Clique which is known to be NP-complete. We first construct a verifier to show L ∈ NP. On input ((G, k), (S1, S2)), do: 1. If |S1| < k or |S2| < k, reject. 2. If S1 is not an independent set, reject. 3. If S2 is not a clique, reject. 4. Accept. Note that this algorithm runs in polynomial time. Moreover, input ((G, k), (S1, S2)) accepts if and only if (G, k) ∈ L. It remains to show that L is NP-hard. We show this by reducing from Clique. Recall that an instance of Clique is a graph G and an integer k. Consider the algorithm f that takes as input (G, k) and outputs (G′, k), where G′ is the graph obtained by adding k isolated vertices to G. It is clear that f is a polynomial-time algorithm. We claim that (G, k) ∈ Clique if and only if f (G, k) = (G′, k) ∈ L. • Assume that (G, k) ∈ Clique: Then there exists a clique of size at least k in G and thus also in G′. The k added isolated vertices in G′ form an independent. Therefore, (G′, k) ∈ L. • Assume that f (G, k) ∈ L: Then there exists a clique of size at least k in G′, which is also a clique of the same size in G. Thus, (G, k) ∈ Clique. 3 Recall that a matching in an undirected graph G = (V, E) is a subset M ⊆ E such that no two edges in M share an endpoint. We say that a matching M is well separated if for any distinct pair of edges e, e′ ∈ M each endpoint of e is at distance at least 2 from each endpoint of e′. Prove that the following problem is NP-complete: SepMatch = {⟨G, k⟩ : G contains a well separated matching of size k} Solution: Note first that SepMatch ∈ NP because a certificate is simply a subset of edges M ⊆ E (this has polynomial size) which is well-separated and has size k (this can be checked in polynomial time). We further show that IndSet ≤p SepMatch. Let ⟨G = (V, E), k⟩ be an independent set instance. Consider the graph G′ = (V ′, E′) which is a copy of G but where each original vertex v ∈ V has a new dual vertex v′ attached to it (see Figure 1 for an example). This transformation can clearly be performed in polynomial time. We claim that ⟨G, k⟩ ∈ IndSet ⇐⇒ ⟨G′, k⟩ ∈ SepMatch. Suppose first that G has an independent set S of size k: The set of edges M = {vv′ : v ∈ S} is a well separated matching of size k for G′. Indeed, pick any two edges uu′ and vv′ of M . Note that the two closest endpoints are u and v and because S is an independent set. they are at distance at least 2. On the other hand, suppose that G′ has a well separated matching M of size k. We may assume that M only uses edges of type vv′. Indeed, for any other type of edge, we can replaced one of its endpoints accordingly, without violating the well-separation. Now, S = {v : vv′ ∈ M } is an independent set of size k for G. Indeed, if u, v ∈ S are adjacent, then M was not well separated to begin with. Page 2 (of 3) CS-251 Theory of Computation • Spring 2025 Figure 1. Transforming an IndSet instance into a SepMatch one. Yellow vertices (resp. edges) are maximum independent set (resp. well-separated matching). 4 Prove that the following problem is NP-hard: Given n integers a1, a2, . . . , an, is there a set S ⊆ {1, 2, . . . , n} such that ∑ i∈S ai = ∑ i̸∈S ai? Solution: Let us denote this problem by L (it is often referred to as the partition problem). We show that L is NP-hard by reducing from SubsetSum. Recall that an instance to SubsetSum consists of a set S and an integer M . Consider the algorithm f , which on input (S, M ) outputs S′ = S ∪ { ∑ s∈S s − 2M } . It is clear that f runs in polynomial time. We how show that in fact (S, M ) ∈ SubsetSum if and only if f (S, M ) = S′ ∈ L. • Assume that (S, M ) ∈ SubsetSum: Then there exists T ⊆ S such that ∑ s∈T s = M . Consider T ′ = T ∪ { ∑ s∈S s − 2M }. We observe that ∑s∈T ′ s = M + ∑ s∈S s − 2M =∑ s∈S s − M , and ∑ s′∈S′\\T ′ = ( ∑ s∈S s) − M . Therefore, S′ ∈ L as desired. • Assume that S′ ∈ L: Then there exists T ⊆ S′ such that ∑ s∈T s = ∑ s∈S′\\T s = ∑ s∈S s + ∑ s∈S s − 2M 2 = ∑ s∈S s − M. One of T or S′ \\ T contains the number ∑ s∈S s − 2M , and removing it gives us a set of numbers in S whose sum is M . Therefore, (S, M ) ∈ SubsetSum as desired. Page 3 (of 3) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}