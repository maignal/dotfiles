{"path":"Homeworks/Submitted Answers/Theory_of_Computation___WH2.pdf","text":"Theory of Computation - HW2 Romeo Maignal, Alexandre Margery, Nobel Jaison April 2025 1 Problem 1 1.1 1a L1 = {⟨M ⟩ : M is a TM and L(M ) is decidable} We aim to prove that L1 is undecidable. Assume, for the sake of contradic- tion, that L1 is decidable. Then there exists a Turing machine ML that decides L1. Using ML, we construct an algorithm that recognizes AT M , which we know is not recognizable. This leads to a contradiction. • On input ⟨T, w⟩, do: 1. Construct a Turing machine M ′ that simulates T on input w and accepts no strings if T (w) does not accept. Specifically: – M ′ simulates T (w). – If T (w) accepts, M ′ accepts the input string x (for some arbitrary x). – Otherwise, M ′ accepts no strings. 2. Run ML(⟨M ′⟩), where ML decides whether L(M ′) is empty. 3. If ML accepts, then accept; otherwise, reject. Now we show that this algorithm recognizes AT M : • If ⟨T, w⟩ ∈ AT M , then T (w) does not accept by definition. Hence, M ′ accepts no strings, and ML(⟨M ′⟩) accepts. Thus, our algorithm accepts. • If ⟨T, w⟩ /∈ AT M , then T (w) accepts. Hence, M ′ accepts at least one string (namely x), and ML(⟨M ′⟩) rejects. Thus, our algorithm rejects. This shows that our algorithm recognizes AT M , which contradicts the fact that AT M is not recognizable. Therefore, L1 is undecidable. Finally, since L1 is undecidable, it cannot be Turing-decidable. A language is Turing-decidable if and only if it is recognizable and there exists a Turing machine guaranteed to halt for every input. Thus, L1 is undecidable. 1 1.2 1b L2 = {⟨M, N ⟩ : M and N are TMs and L(M ) ∩ L(N ) ̸= ∅} We aim to prove that L2 is undecidable. Assume, for the sake of contradic- tion, that L2 is decidable. Then there exists a Turing machine M2 that decides L2. Using M2, we construct an algorithm that decides AT M , which we know is undecidable. This leads to a contradiction. • On input ⟨T, w⟩, do: 1. Construct a Turing machine M ′ that simulates T on input w and outputs T (w). 2. Run M2(⟨M ′, M ′⟩). 3. If M2 accepts, then accept; otherwise, reject. We now argue that this algorithm decides AT M : • If ⟨T, w⟩ ∈ AT M , then T (w) accepts by definition. Thus, M ′ always accepts, and L(M ′) ∩ L(M ′) = ∅. This implies M2(⟨M ′, M ′⟩) rejects, and hence our algorithm accepts. • If ⟨T, w⟩ /∈ AT M , then T (w) does not accept (it might not halt). Thus, M ′ never accepts, and L(M ′) ∩ L(M ′) ̸= ∅. This implies M2(⟨M ′, M ′⟩) accepts, and hence our algorithm rejects. This shows that our algorithm decides AT M , which contradicts the fact that AT M is undecidable. Therefore, L2 is undecidable. Next, we show that L2 is Turing-recognizable. To construct a Turing ma- chine that recognizes L2: • On input ⟨M, N ⟩, do: 1. Enumerate all strings w1, w2, · · · ∈ Σ∗. 2. Simultaneously simulate M (w) and N (w) for each string w. 3. If at any point, you find a string wi such that both M (wi) and N (wi) accept, then accept. If L(M ) ∩ L(N ) ̸= ∅, then there exists some string w accepted by both machines. The algorithm will eventually find it and accept. If no such string exists, the machine may run forever, which is allowed for recognizers. Therefore, L2 is Turing-recognizable. 2 Problem 2 In order to prove that the Busy-Beaver Problem BB(n) is not computable, we can use reduction. Specifically, as it pertains to the Halting problem. If we can prove that the Halting problem can be reduced to the Busy Beaver problem, 2 then we can prove that the Busy Beaver is undecidable. Let’s consider a more generalized version of BB(n) which we will label BB′(n). BB′(n) calculates how many steps a machine with n states can take and still halt instead of counting how many 1s a machine with n states can out- put and still halt. Since BB′(n) is a reduction of BB(n), proving that BB′(n) is computable will prove the same for BB(n) also. Let’s consider a machine T M which when started with an empty tape, takes n steps before halting with the output [k]. We can construct a new machine T M ′ that simulates T M while also printing a ”1” for each step that T M takes. Although T M ′ may have more states than T M , the total number of states will be a linear transformation of the number of states in T M . If the function is linear, it is also computable. We can see that BB′(n) ≤ BB(f (n)) for a computable f (n). This means that the computability of BB′(n) depends on the computability of BB(n). We can start all machines with n states on an empty tape, and all that are still running even after BB(f (n)) steps must run indefinitely. For all the ones that halt, we simply count the steps they take. Now, we can use reduction yet again to show that BB′(n) being computable would imply the halting problem is computable, which we know is untrue. Let’s say that a Turing Machine T M computes BB′(n). We define another machine T M ′ as follows: T M ′ = On input ⟨A⟩, A being a Turing Machine : • Find the number of states in ⟨A⟩ from its description and assign to n. • To find BB′(n), we can simply run T M . • Simulate A on a blank tape. – If A halts within BB′(n) steps, accept. – If A has not halted within BB′(n) steps, reject. If the machine T M could compute BB′(n), we would have been able to solve the problem of determining whether A halts on a blank tape. We can try to reduce this even further. We define another machine T M ′′ as follows: T M ′′ = On input ⟨B, s⟩ where B is a Turing machine and s is the input string: 3 • First, T M ′′ writes s onto an empty tape. • Then, T M ′′ runs B on the input s. • If B halts on s, then T M ′′ will also halt because it successfully simulates B on s. If B does not halt on s, then T M ′′ will not halt because it will be stuck in the simulation of B. Since TM” halts on an empty tape if and only if B halts on s, we could use TM’ to compute whether TM” halts. Therefore, decide on the generalised halting problem, computing whether B halts on s. Consequently, we have a contradiction, and the problem of determining halting on a blank tape is unde- cidable. The contradictions then chain, and we have that BB′(n) is undecidable, otherwise the problem of determining halting on a blank tape would be decid- able. And finally, that BB(n) is undecidable, else BB′(n) would be decidable. Thus, BB(n) is undecidable. 4","libVersion":"0.5.0","langs":""}