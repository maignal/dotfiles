{"path":"Exam/Solutions/examsol2019-2020.pdf","text":"Final Exam, Theory of Computation 2019-2020 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in the class including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 18 points / 12 points / 20 points / 15 points / 20 points / 15 points Total / 100 Page 1 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 1 (consisting of subproblems a-b, 18 pts) Basic questions. 1a (8 pts) Write the formal deﬁnition of the class NP. If you use the concept of a veriﬁer or a non-deterministic Turing machine, then explain what it is. Solution: A language is in NP if it has a polynomial-time veriﬁer or equivalently a polynomial-time nondeterministic decider. A polynomial-time veriﬁer is a Turing Machine M such that given an input x, if x is in the language, then there exists a certiﬁcate C such that M accepts (x, C); if x is not in the language, then for every certiﬁcate C, M rejects (x, C). A nondeterministic decider is an NTM N such that for each input x, every computation of N on x halts, and if x is in the language, then some computation of N on x accepts; if x is not in the language, then every computation of N on x rejects. Page 2 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 1b (10 pts) Which of the following statements are true? 1. All regular languages are in NP. 2. All languages in P are regular. 3. All irregular languages are decidable. 4. All decidable languages are in NP. 5. All decidable languages are recognizable. 6. If a language L is decidable, then its complement ¯L is decidable. 7. If a language L is recognizable, then its complement ¯L is recognizable. 8. If a language is NP-hard, then it is NP-complete. 9. The language {w ∈ {0, 1}∗ | number of 0’s in w is divisible by 2020} is regular. 10. The language {0n1n | n ≥ 0} is in NP. 11. {⟨M ⟩ | M is a TM that halts on all inputs of length at least 2020} is recognizable. 12. If languages L1 and L2 are unrecognizable then L1 ∪ L2 is unrecognizable. (A complete solution identiﬁes all true statements. A fully correct solution is worth 10 points. A solution with one mistake is worth 9 points. A solution with two mistakes is worth 7 point. A solution with three mistakes is worth 4 points. A solution with four mistakes is worth 1 point. Solutions with more mistakes are worth 0 points. A mistake is to either indicate falsely that a false statement is true or to not indicate that a true statement is true.) Solution: Among the above statements, the following are true 1, 5, 6, 9, 10 (In this problem you do not need to justify your answer.) Page 3 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 2 (12 pts) NP-completeness. Prove that the following language LONGCYCLE is NP-complete: LONGCYCLE = {⟨G⟩ | G is an undirected graph with a cycle that visits at least half the vertices} . In your proof you may use that the following language is NP-complete: HAM = {⟨G⟩ | G is an undirected graph that is Hamiltonian} . An undirected graph G = (V, E) is said to be Hamiltonian if it contains a cycle of length |V |, i.e., a cycle that visits every vertex. Two examples of Hamiltonian graphs are the complete graph and the graph consisting of a single cycle of length |V |. (In this problem you are asked to prove that the language LONGCYCLE is NP-complete. Recall that you are allowed to use that HAM is NP-complete and to refer to material covered in the class including theorems without reproving them.) Page 4 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 3 (consisting of subproblems a-b, 20 pts) Reductions. In the next two subproblems, we are going to consider reductions between languages INDSET and ODD. Recall from class that INDSET denotes the NP-complete language INDSET = {⟨G, k⟩ | G is an undirected graph with an independent set of size k} and we deﬁne ODD to be the following regular language ODD = {w ∈ {0, 1} ∗ | w has an odd number of 1’s} . 3a (10 pts) In this subproblem, we are going to show that if INDSET is poly-time mapping reducible to ODD then P = NP. Speciﬁcally, your task is to prove the following statement: If INDSET ≤p ODD then P = NP. (In this problem you are asked to prove that if INDSET ≤p ODD then P = NP. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: ODD is in P as it is regular. By assumption that INDSET ≤p ODD and transitivity, INDSET is in P. But, INDSET is an NP-complete language. Hence, by deﬁnition, any language L ∈ NP satisﬁes L ≤p INDSET. Therefore, we conclude that P=NP. Page 5 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 3b (10 pts) In this subproblem, we are going to show that INDSET is mapping reducible to ODD. Speciﬁcally, your task is to show that INDSET ≤m ODD. (In this problem you are asked to give a mapping reduction from INDSET to ODD. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: We ﬁrst give a decider M for INDSET. On input ⟨G, k⟩, M iterates through all possible subsets of size k. If there exists a subset where there is no edge between any two vertices in the set, then accept. Otherwise, reject. It is a decider as it halts in ﬁnite amount of time. The correctness is easy to see as there exists an independent set of size k iﬀ M ﬁnds it as it exhaustively tries every possibility for such a set. We now give the function f for proving that INDSET≤mODD. f : On input ⟨G, k⟩: 1. Run M on ⟨G, k⟩. 2. If M accepts, output “1”, else output “0”. f is computable as M is a decider. For correctness, if ⟨G, k⟩ ∈ INDSET, then M accepts and f (⟨G, k⟩) = “1” ∈ ODD. On the other hand, if ⟨G, k⟩ /∈ INDSET, then M rejects and f (⟨G, k⟩) = “0” /∈ ODD. Page 6 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 4 (15 pts) Regular languages. Given a language A ⊆ {0, 1}∗, let B = {EVEN(w) | w ∈ A} , where EVEN(w) denotes the string with only the even-positioned letters of w. For example, EVEN(11101011) = 1001. Describe an NFA that shows that B is regular if A is regular. (In this problem you are asked to construct an NFA that shows that if A is regular then so is B.) Solution: Suppose A is regular. Then there is a DFA that recognizes it: D = (Q, Σ, δ, q, F ). Take two copies of this DFA: Dodd = (Qo, Σ, δo, qo, Fo) and Deven = (Qe, Σ, δe, qe, Fe). We deﬁne a new NFA: (Q′, Σ′, δ′, q′, F ′) where: • Q′ = Qo ∪ Qe • Σ′ = Σ • q′ = qo • F ′ = Fo ∪ Fe • δ′(qo,i, ϵ) = {δe(qe,i, 0), δe(qe,i, 1)} • δ′(qe,i, 0) = δo(qo,i, 0) • δ′(qe,i, 1) = δo(qo,i, 1) This NFA recognizes B so B is regular if A is regular. (Informally: take two copies of the states of the DFA D, one for “odd\" and one for “even\". The starting state is one from the odd copy. The ﬁnishing states is the union of the ﬁnishing states from each copy. Starting from an odd state q, add an epsilon transition to the correspond- ing states in the even copy that can be reached from q. Starting from an even state q, add a transition when reading 0 to the corresponding state in the odd copy that is reached by reading 0 from q, and similarly for reading 1. So when we are in the odd copy, we have removed the odd-positioned letter by an epsilon transition to the even copy, and when we are in the even copy, we read the letter by doing the original transition, but to the odd copy. The original accepting states are in both copies, since there can be both odd- and even-length words in A. Note that this NFA would accept the empty string, if there are words of 1 letter in A.) Page 7 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 5 (20 pts) Computability. Classify the following language into one of: decidable, undecidable but recognizable, unrecognizable. SLOWHALT = {⟨M, x⟩ | M is a TM that halts on input x after taking at least 2020 steps} . Justify your answer with a formal proof. (In this problem, you are asked to identify whether SLOWHALT is (decidable and recognizable), (undecidable and recognizable), or (unrecognizable) and provide a formal correctness proof. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: The language SLOWHALT is recognizable but undecidable. To prove recognizability we build the following recognizer. Recognizer R = \"on input ⟨M, x⟩ 1. Simulate M on input x while counting the number of steps. 2. If the number of steps is at least 2020 then accept otherwise reject.\" If ⟨M, x⟩ ∈ SLOWHALT then the line 1 will eventually stops after at least 2020 steps and the recognizer will accept the input ⟨M, x⟩. If ⟨M, x⟩ /∈ SLOWHALT, either line 1 stops in less than 2020 steps and line 2 will reject, or line 1 never stops. In both case, the input ⟨M, x⟩ is not accepted. We now prove that SLOWHALT is undecidable by providing a reduction from the language HALT = {⟨M, x⟩ | M is a TM and M halts on x} which is known to be undecidable by the lectures. We deﬁne the following computable reduction f (⟨M, x⟩) = ⟨M ′, x⟩ where M ′ is a TM deﬁned as follows. M ′ = \"on input y 1. Loop for 2020 steps. 2. Run M on y and output the same result.\" We see that f is computable as the input x is unchanged and we only need to deﬁne the Turing Machine M ′. As for correctness of the reduction, if ⟨M, x⟩ ∈ HALT, then the machine M ′ (on input x) will ﬁrst run 2020 useless steps because of line 1 then will stop in line 2. Hence ⟨M ′, x⟩ ∈ SLOWHALT. If ⟨M, x⟩ /∈ HALT then the machine M ′ will never stop on input x because of line 2 hence ⟨M ′, x⟩ /∈ SLOWHALT. We can conlude that SLOWHALT is recognisable but undecidable. Page 8 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 6 (15 pts) Large DFAs. Let LARGE = {0n1n | 1 ≤ n ≤ 106}. That is LARGE contains all strings that have n zeros followed by n ones where n is an integer between 1 and 106. As LARGE contains a ﬁnite number of strings (106 many strings), LARGE is a regular language. However, in this problem you are asked to prove that there is no “small” DFA that recognizes LARGE. More speciﬁcally, your task is to prove the following statement: Any DFA that recognizes LARGE has at least 105 states. (In this problem you should give a proof of the statement that any DFA that recognizes LARGE has at least 105 states. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: We will show a stronger claim. We will show that any DFA that recognizes LARGE has at least 106 states. Assume for the sake of contradiction that there exists a DFA Q that has fewer than 106 states and such that L(Q) = LARGE. Consider a set S := {0k : 1 ≤ k ≤ 106}. The number of states of Q is smaller than 106 and |S| = 106 so, by pigeonhole principle, there exist w1, w2 ∈ S, w1 ̸= w2 such that Q after reading w1 and w2 ends up in the same state. By deﬁnition of S, without loss of generality, we have that w1 = 0i, w2 = 0j for some 1 ≤ i < j ≤ 106. We claim that 0j1i ∈ L(Q) and 0j1i ̸∈ LARGE. This would constitute the desired contradic- tion. • 0j1i ̸∈ LARGE because i ̸= j, • 0j1i ∈ L(Q) because Q after reading 0j is in the same state as after reading 0i and 0i1i ∈ LARGE. Page 9 (of 9) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson","libVersion":"0.5.0","langs":""}