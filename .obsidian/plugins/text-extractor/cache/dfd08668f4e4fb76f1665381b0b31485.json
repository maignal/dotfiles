{"path":"Exercises/Solutions/Toc ex 8 sol.pdf","text":"Exercise VIII, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. Problems marked * are more difficult but also more fun :). These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. 1 Prove that the following problems are in NP: 1a A Boolean formula is said to be in disjunctive normal form (DNF) if it is an OR (∨) of a number of terms, where each term is an AND (∧) of some literals. For instance, the following is a DNF formula: (x ∧ y ∧ ¯z) ∨ (¯y ∧ z) ∨ (¯x ∧ ¯y). Given a DNF formula, decide it is satisfiable. 1b Given n positive integers a1, a2, . . . , an, decide if there is some S ⊆ {1, 2, . . . , n} with ∑ i∈S ai = ∑ i̸∈S ai. Solution: Recall that to prove a problem/language is in NP, we need to provide a polynomial time algorithm, the verifier V , such that given the instance and the witness, V determines if the instance is in the language. 1a For this problem, an instance is a DNF formula F , and as a witness we can take an assign- ment A of boolean values for the variables. Our verifier V then does the following: On input (F, A), do: 1. For each term in F : (a) Check if all literals in the term are true under assignment A. (b) If yes, accept. 2. Reject. Note that V runs in linear time in the size of F, A. Moreover, we can see that if F ∈ DNF-SAT, there exists some A such that V (F, A) accepts. Alternatively, if F ̸∈ DNF-SAT, then for all A, V (F, A) rejects. 1b In this problem, the instance consists of the positive integers a1, . . . , an, and as a witness we take some set S ⊆ [n]. Our verifier V then does the following: On input ((a1, . . . , an), S), do: 1. Compute s1 = ∑ i∈S ai. 2. Compute s2 = ∑ i̸∈S ai. 3. If s1 = s2, accept. Otherwise, reject. Similarly, we can see that computing the sums and check if they are equal takes O(n log(maxi ai)) time, which is polynomial in terms of the input size. Moreover, we can see that there exists some S such that V ((a1, . . . , an), S) accepts if and only if (a1, . . . , an) is an accepting instance to the problem. Page 1 (of 3) CS-251 Theory of Computation • Spring 2025 2 Show that if L1, L2 ⊆ Σ∗ are in NP then their concatenation L = L1L2 is also in NP. Solution: Assume L1 and L2 are in NP. Then there exists polynomial-time verifiers V1 and V2 for deciding membership of L1 and L2. An instance to our problem is some string x, and as a witness we take a triple (ℓ, w1, w2) where ℓ ≥ 0 is an integer and w1, w2 are witnesses for V1 and V2 respectively. Now we construct the verifier V for the concatenation. On input (x, (ℓ, w1, w2)), do: 1. If ℓ > |x|, reject. 2. Let x1 = x1x2 · · · xℓ. 3. Let x2 = xℓ+1xℓ+2 · · · x|x|. 4. Run V1(x1, w1) and V2(x2, w2). 5. If both V1 and V2 accept, accept. 6. Otherwise, reject. We first observe that V runs in polynomial-time in terms of the input. Now we show the correctness of V . • Assume that x ∈ L1L2: Then x = x1x2 for some x1, x2 such that x1 ∈ L1 and x2 ∈ L2. Since L1 and L2 are in NP, we know that there exist w1, w2 such that V1(x1, w1) and V2(x2, w2) accept. Let w := (|x1| , w1, w2), we have that V (x, w) accepts. • Assume that x ̸∈ L1L2: For all 0 ≤ ℓ ≤ |x|, we have that either x1 ̸∈ L1 or x2 ̸∈ L2. Therefore, for all w, V (x, w) rejects by construction. 3 Prove that the following problem is NP-complete: Given an undirected graph G = (V, E) and a positive integer k, decide if there is a subset S of V with |S| ≥ k such that there is an edge between every pair of vertices in S? Solution: To show a problem is NP-complete, we need to first show that the problem is in NP, and then show that it is NP-hard. We construct a V verifier for the problem. The instance is the graph G and the integer k, and as the witness we take the set S. Now define V as follows. On input ((V, E, k), S), do: 1. If |S| < k, reject. 2. If S is not a subset of V , reject. 3. If for any v ̸= v′ ∈ S we have (v, v′) ̸∈ E, reject. 4. Accept. One can easily see that V runs in polynomial time. Moreover, we observe that there exists some S such that V ((G, k), S) accepts if and only if (G, k) is an accepting instance of the problem. Now we show that this problem is NP-hard. We know from lecture that determining whether a graph contains an independent set (IS) of size at least k is NP-hard. Therefore, if we can provide a polynomial-time reduction from IS to our problem, which we call Clique, then Clique is also NP-hard. We construct the function f for the reduction by the following algorithm. On input (V, E, k), do: Page 2 (of 3) CS-251 Theory of Computation • Spring 2025 1. Construct E′ := {(u, v) : u ̸= v ∈ V, (u, v) ̸∈ E}. 2. Output (V, E′, k). Clearly, f is polynomial-time computable. It remains to show that (V, E, k) ∈ IS if and only if f (V, E, k) ∈ Clique. • Assume that (G, k) ∈ IS: Then there exists a set S ⊆ V such that |S| ≥ k and for all v ̸= v′ ∈ S, (v, v′) ̸∈ E. By the construction of E′, we know that for all v ̸= v ∈ S, (v, v′) ∈ E′. Therefore, (V, E′, k) ∈ Clique. • Assume that f (V, E, k) = (V, E′, k) ∈ Clique: Then there exists a set S ⊆ V such that |S| ≥ k and for all v ̸= v′ ∈ S, (v, v′) ∈ E′. Therefore, (v, v′) ̸∈ E by construction and (V, E, k) ∈ IS. Therefore, we can conclude that Clique is NP-complete. 4* Let 3SAT3 be the problem of deciding whether a 3CNF formula φ, with the additional assumption that every variable occurs at most 3 times in φ, is satisfiable. Show that 3SAT3 is NP-complete. Solution: We first not that we can show 3SAT3 ∈ NP the same way we use to show SAT ∈ NP. It now remains to show that 3SAT3 is NP-hard, we do so by reducing 3SAT to 3SAT3. The function f of the reduction is five by the following algorithm. On input φ, do: 1. Let φ′ = φ. 2. For each variable x in φ′ that appears more than 3 times: (a) Let m be the number of occurrences of x. (b) Introduce m new variables y1, . . . , ym. (c) Replace the i-th occurrence of x in φ′ by yi. (d) Add additional clauses (yi ∨ yi+1) for all i ∈ [m − 1] and (ym ∨ y1) to φ′. 3. Output φ′. We can easily see that f runs in polynomial-time. Now we argue that φ ∈ 3SAT if and only if f (φ) ∈ 3SAT3. Note that the conjunction of the clauses (yi ∨yi+1) for all i ∈ [m−1] and (ym ∨y1) is equivalent to saying y1 = · · · = ym. Thus, for each such family of variables, setting their value to be the same as the value of the variable x they replace gives us a direct correspondence between satisfying assignments of φ′ and those of φ. Moreover, in φ′ each yi appears exactly 3 times. Therefore, by construction, φ ∈ 3SAT ⇐⇒ φ′ ∈ 3SAT3. Page 3 (of 3) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}