{"path":"Exercises/Solutions/ToC ex 1 sol.pdf","text":"Exercise I, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. Problems marked * are more difficult but also more fun :). These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. 1 (Exercise 1.1 in Sipser’s book ) The following are the state diagrams of two DFAs, M1 and M2. Answer the following questions about each of these machines. 1a What is the start state? 1b What is the set of accepting states? 1c What sequence of states does the machine go through on input aabb? 1d Does the machine accept the string aabb? 1e Does the machine accept the string ε? Solution: M1 M2 1a q1 q1 1b {q2} {q1, q4} 1c q1, q2, q3, q1, q1 q1, q1, q1, q2, q4 1d No Yes 1e No Yes Page 1 (of 8) CS-251 Theory of Computation • Spring 2025 2 (Based on Exercise 1.4 in Sipser’s book ) Each of the following languages is the intersection of two simpler languages. In each part, construct DFAs for the simpler languages, then combine them using the construction discussed in class to give the state diagram of a DFA for the language given. In all parts, Σ = {a, b}. 2a {w | w has exactly two a’s and at least two b’s} 2b {w | w has an even number of a’s and each a is immediately followed by at least one b} Solution: 2a The following are DFAs for the two languages {w | w has exactly two a’s} and {w | w has at least two b’s}, respectively. b b b a,b a a a a a a,b b b Combining them using the intersection construction gives the following DFA. a a a,b b b b a a a a a a a a a b b b b b b b b Though the problem doesn’t ask you to simplify the DFA, the three states on the very right can be combined into a single one, as they all act as “dead states” from which one can never reach an accepting state. Page 2 (of 8) CS-251 Theory of Computation • Spring 2025 2b These are DFAs for the two languages {w | w has an even number of a’s} and {w | each a in w is immediately followed by at least one b}. b b a a b a,b a b a Combining them using the intersection construction gives the following DFA. b b b b aa b b a a a a Though the problem doesn’t ask you to simplify the DFA, the two states on the right can be combined into a single one, as they both act as “dead states” from which one can never reach an accepting state. Page 3 (of 8) CS-251 Theory of Computation • Spring 2025 3 (Based on Exercise 1.5 in Sipser’s book ) Each of the following languages is the complement of a simpler language. In each part, construct a DFA for the simpler language, then use it to give the state diagram of a DFA for the language given. In all parts, Σ = {a, b}. 3a {w | w does not contain the substring ab} 3b {w | w does not contain the substring baba} Solution: 3a The DFA below recognizes the language {w | w contains ab}. b a a,b a b The DFA below recognizes its complement i.e. { w | w does not contain ab }. b a a,b a b 3b The DFA below recognizes the language {w | w contains baba}. a b a,b a b b a b a The DFA below recognizes its complement i.e. {w | w does not contain baba}. a b a,b a b b a b a Page 4 (of 8) CS-251 Theory of Computation • Spring 2025 4 Suppose A1, A2, and A3 are regular languages over the alphabet Σ. Prove that (A1 ∪ A2) ∩ A3 is regular by giving a formal description of a finite automaton recognizing it. Solution: We know that A1, A2, and A3 are regular languages. Hence, there are finite automata that recognize them. Let M1 = (Q1, Σ ,δ1, q1, F1) such that L(M1) = A1. In other words, let M1 be the automaton that recognizes A1. Define M2 and M3 similarly for A2 and A3. We first construct M12 = (Q12, Σ ,δ12, q12, F12) where • Q12 = Q1 × Q2, • δ12((s1, s2), a) = (δ1(s1, a), δ2(s2, a)), • q12 = (q1, q2), • F12 = (F1 × Q2) ∪ (Q1 × F2). Observe that M12 is the machine such that L(M12) = A1 ∪ A2. We then construct M123 = (Q123, Σ ,δ123, q123, F123) where • Q123 = Q12 × Q3, • δ123((s1, s2), a) = (δ12(s1, a), δ3(s2, a)), • q123 = (q12, q3), • F123 = (F12 × F3). Observe L(M123) = L(M12) ∩ A3 = (A1 ∪ A2) ∩ A3 as required. 5 For the automaton given below, describe the language it recognizes. Prove that your description is correct. q0 q1 q2 q3 0 1 0,1 1 0 1 0 Solution: Denote the given automaton by M . The language recognized by M is L = {w | w has “100” as a substring} . We provide two different proofs of this below. First solution (ad-hoc): We show that the automaton stops in the only accepting state q3, if and only if the input string has “100” as a substring. We prove the two directions separately. First, consider any input s ∈ L. Clearly, we can write s = x100y for some possible empty words x, y. According to the illustration of the automaton, we know that starting from any state q, reading “100” will lead to state q3. Indeed, the four different paths when reading “100” are: (q0, q1, q2, q3), (q1, q1, q2, q3), (q2, q1, q2, q3) and (q3, q3, q3, q3). Therefore, no matter what state q the automaton is in after reading x, after reading “100” we are in state q3. Since no paths lead out of state q3, the automaton will stay in q3 until the entire string is read, and thus accept, just as desired. For the converse, suppose that the automaton accepts an input s. Then, there exists some i ∈ N such that after reading si, the i-th symbol of s, the automaton is in state q3 for the first time. Moreover, since the shortest path from the initial state to state q3 is of length 3, we must Page 5 (of 8) CS-251 Theory of Computation • Spring 2025 have i ≥ 3. Since this is the first time we reach q3, we must be in state q2 after reading si−1, according to the graph. Therefore, we must have that si = 0. But the only way to get t state q2 is from q1, thus we deduce that si−1 = 0 also. Finally, since all incoming arrows at state q1 are labelled 1, we must have read the symbol 1 to get there. We conclude that therefore si−2 = 1 and consequently s contains“100” as a substring, as desired. Second solution (induction): We proceed by induction, following the framework discussed in class. Claim. Let x be an arbitrary input to the automaton. We consider four cases: 1. If x does not contain any 1’s, the automaton M terminates in state q0. 2. If the last symbol of x is a “1”, but x does not contain “100” as a substring, then M terminates in state q1. 3. If the last two symbols of x are “10”, but x does not contain “100” as a substring, then M terminates in state q2. 4. If x contains “100” as a substring, then M terminates in state q3. Note that these four cases are mutually exclusive and together cover all possible inputs. Also, note that it suffices to prove this claim since it implies that the automaton terminates in the only accepting state q3 if and only if the input contains “100” as a substring. We now prove the above claim by induction on the length of the input x: Base case. If x has length 0 (i.e. x is the empty string), then x does not contain any 1’s and M terminates in the start state q0, as desired. Inductive step. Let x be some non-empty input string. By the inductive hypothesis, we can assume that the claim is true for all input strings that are shorter than x. Let x′ be the string obtained from x by removing the last symbol. This string is clearly shorter than x, so we can apply the inductive hypothesis to reason about which state M is in just before reading the last symbol of the input x. 1. If x′ does not contain any 1’s we know that after reading x′, M is in state q0. If the last symbol of x is a 0, then up feeding it to M , it stays in state q0, as desired. If the last symbol of x is a 1 instead, then x ends with a 1 but does not contain “100” as a substring. But in this case, M will go to state q1, also as desired. 2. If the last symbol of x′ is a “1” but x′ does not contain “100”, then after reading x′, M is in state q1. We again consider the last symbol of x. If it’s a 0, then the last two symbols of x are “10” but x does not contain “100” as a substring, while M ends up in state q2, as desired. If it’s a 1 instead, then the last symbol of x is a 1 and M ends in state q1, as desired. 3. If the last two symbols of x′ are “10” but x′ does not contain “100”, then after reading x′, M is in state q2. We consider the last symbol of x once more. If it’s a 0, then x contains “100”, and M ends in state q3, as desired. If it’s a 1, then x ends with a 1 but does not contain “100” as a substring, while M goes to state q1, as desired. Page 6 (of 8) CS-251 Theory of Computation • Spring 2025 4. Finally, if x′ contains “100” as substring, then after reading x′, M is in state q3. But x′ is a substring of x, so x also contains “100” as a substring. Moreover, no matter what the last symbol of x is, M will stay in state q3, just as desired. Thus, we conclude that the claim holds true for all input strings x. 6 The following automaton is over the alphabet Σ = {0, 1} and the set of states is Q = {q0, q1, q2}. The start state is q0 and the accepting states are F = {q1, q2}. q0 q1 q2 0 1 1 1 0 0 6a Write down the transition function δ for this automaton. 6b* Describe the language recognized by the automaton and prove the correctness of your claim. Hint: Tryallinputsofafixedlengthinsomenaturalorderandlookforapattern Solution: 6a The transition function δ : Q × Σ → Q is given by δ(q0, 0) = q0, δ(q0, 1) = q1; δ(q1, 0) = q2, δ(q1, 1) = q0; δ(q2, 0) = q1, δ(q2, 1) = q2. 6b* The automaton recognizes the binary strings w if and only if w, when interpreted as an integer in base two, is not divisible by 3. Note that the empty string represents 0 by convention. Going forth, we will treat binary strings interchangeably with the integers they represent in base two. Let M denote the automaton in question. Claim. Let x be an arbitrary input. We consider three cases: 1. If x = 3k for some k ∈ N, then M terminates in state q0. 2. If x = 3k + 1 for some k ∈ N, then M terminates in state q1. 3. If x = 3k + 2 for some k ∈ N, then M terminates in state q2. Note that these cases are exhaustive. Moreover, observe that q1 and q2 are the only accepting states, so it suffices to prove the claim to solve the problem. We prove the claim by induction on the length of the input string x. Base case. If x has length 0 (i.e. x is the empty string), it represents the integer 0, which is of the form 3k. Meanwhile, M terminates in the start state q0, as desired. Page 7 (of 8) CS-251 Theory of Computation • Spring 2025 Inductive step. Let x be a non-empty input string. By the inductive hypothesis we can assume the claim is true for all strings shorter than x. Let x′ be the string obtains from x after removing the last symbol. Since x′ is clearly shorter than x, we can apply the inductive hypothesis to x′. We use this to distinguish cases depending on which state M is in after reading all but the last symbol of x: 1. If M is in state q0, then we have x′ = 3k for some k ∈ N. We consider the last symbol of x. If it’s a 0, we have x = 2x′ = 3 · (2k), and M will stay in state q0, as desired. If instead it’s a 1, then we have x = 2x′ + 1 = 3 · (2k) + 1, and M goes to state q1, as desired. 2. If M is in state q1, then we have x′ = 3k + 1 for some k ∈ N. Again, we consider the last symbol of x. If it’s a 0, we have x = 2x′ = 2 × (3k + 1) = 3 · (2k) + 2, and M goes to q2, as desired. If instead it’s a 1, we have x = 2x′ + 1 = 2 · (3k + 1) + 1 = 3 · (2k + 1), and M goes to q0, as desired. 3. Finally, if M is in state q2, then we have x′ = 3k + 2. If the last symbol of x is a 0, then x = 2x′ = 3 · (2k + 1) + 1, and M goes to q1, as desired. If instead it’s a 1, then we have x = 2x′ + 1 = 3 × (2k + 1) + 2, and M goes to q2, as desired. Thus, we conclude that the claim holds for all input strings x. Page 8 (of 8) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}