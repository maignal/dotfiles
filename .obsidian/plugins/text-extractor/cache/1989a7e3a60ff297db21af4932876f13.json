{"path":"Lectures/Lecture5.pdf","text":"Lecture 5: Decidability and Undecidability Mika GÃ¶Ã¶s School of Computer and Communication Sciences Lecture 5 290 15 Turing Machines Figure 1: Alan Turingâ€™s â€œlight bulb momentâ€ â€“ Prof. Geoâ†µ Draper drew this cartoon for my book never halt; it may keep zigzagging on the tape, writing symbols all over, and running amok, much like many tricky programs do in real life. A Turing machine cannot manufacture new symbols ad inï¬nitum - so all the symbols written by a Turing machine on its tape do belong to a ï¬nite tape alphabet, \u0000. Notice that âŒƒ â‡¢ \u0000, since \u0000 includes the blank symbol B that is not allowed within âŒƒ. We assume that a Turing machine begins its operation scanning cell number 0 of a doubly-inï¬nite tape (meaning that there are tape cells numbered +x or \u0000x for any x 2 Nat); more on this is in the following section. A fact to remember is this: in order to feed the string \" to a TM, one must present to the Turing machine a tape ï¬lled with blanks (B). However, some authors alter this convention slightly, allowing \" to be fed to a Turing machine by ensuring that, in the initial state, the symbol under the tape head is blank (B) (i.e., the rest of the tape could contain non-blank symbols). In any case, a normal Turing machine input is such that for every i 2 length(w), w[i] 6= B is presented on tape cell i, with all remaining tape cells containing B, and the head of the Turing machine faces w[1] at the beginning of a computation. A TM may be deterministic or nondeterministic. The signature of \u0000 for a deterministic Turing machine (DTM) is \u0000 : Q â‡¥ \u0000 ! Q â‡¥ \u0000 â‡¥ {L, R}. This signature captures the fact that a TM can be in a certain state q 2 Q and looking at a 2 \u0000. It can then write a 0 on the tape in lieu of a, move to a state q0, and move its head left (L), or right (R), depending on whether \u0000(q, a)= hq0,a 0,Li or \u0000(q, a)= hq0,a 0 ,Ri,respectively. For an NDTM, \u0000(q, a) returns a set of next control states, tape symbol replacements, and head move directions. The signature of \u0000 for a nondeterministic Turing machine (NDTM) is \u0000 : Q â‡¥ \u0000 ! 2 Qâ‡¥\u0000â‡¥{L,R}. Think of a nondeterministic Turing machine as a C program where instead of the standard if-then-else construct, we have an if/fi construct of the following form: 2 Recall Lecture 5 The Turing Machine q0q1q2q3q4q5q3q0qaccept Head (with current state) 1 0 0 1 Inï¬nite Tape q0q0 q1q1 q2q2q3q3 q4q4 q5q5 qreject qacceptqaccept 1 â†’ âŠ”, R 0, 1 â†’ R âŠ” â†’ L 1 â†’ âŠ”, L 0, âŠ” â†’ R0, 1 â†’ L âŠ” â†’ R 0 â†’ âŠ”, R 0, 1 â†’ R âŠ” â†’ L 0 â†’ âŠ”, L 1, âŠ” â†’ R âŠ” â†’ R Finite state control (the algorithm) This Turing machine accepts even length binary palindromes Lecture 5 Turing Machine 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conï¬guration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maË† chine computesâ€œ Say that conï¬guration C1 yields conï¬guration C2 if the Turing machine can legally go from C1 to C2 in a single stepâ€œ We deï¬ne this notion formally as followsâ€œ Suppose that we have aa baand c in Î“aas well as u and v in Î“âˆ— and states qi and qjâ€œIn that casea ua qi bv and uqj acv are two conï¬gurationsâ€œ Say that ua qi bv yields uqj acv if in the transition function Î´(qi,b)= (qj,c, L)â€œThat handles the case where the Turing machine moves leftwardâ€œ For a rightward movea say that ua qi bv yields uac qj v if Î´(qi,b)= (qj,c, R)â€œ Special cases occur when the head is at one of the ends of the conï¬gurationâ€œ For the leftË†hand enda the conï¬guration qi bv yields qj cv if the transition is leftË† moving Abecause we prevent the machine from going off the leftË†hand end of the tape]a and it yields cqjv for the rightË†moving transitionâ€œ For the rightË†hand enda the conï¬guration ua qi is equivalent to ua qi â£ because we assume that blanks follow the part of the tape represented in the conï¬gurationâ€œ Thus we can handle this case as beforea with the head no longer at the rightË†hand endâ€œ The start conï¬guration of M on input w is the conï¬guration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tapeâ€œ In an accepting conï¬gurationathe state of the conï¬guration is qacceptâ€œIn a rejecting conï¬gurationathe state of the conï¬guration is qrejectâ€œ Accepting and rejecting conï¬gurations are halting conï¬gurations and do not yield further conï¬gurationsâ€œ Because the machine is deï¬ned to halt when in the states qaccept and qrejectawe equivalently could have deï¬ned the transition function to have the more complicated form Î´ : Qâ€² Ã— Î“âˆ’â†’ Q Ã— Î“ Ã— {L, R}awhere Qâ€² is Q without qaccept and qrejectâ€œA Turing machine M accepts input w if a sequence of conï¬gurations C1a C2a ... a Ck existsa where 1. C1 is the start conï¬guration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conï¬gurationâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃ_Â·Ã°ÃÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃk_ÃÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾Ã_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°Ã_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃÃ°ÃˆÃ‘Ã°Ã_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃÃŒÂ²ÃÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃ_ÃˆÃ°ÃÃÃˆÃÂ®ÃÃÃ‰ÃƒÃ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm â–¶ Inï¬nite tape â–¶ Tape alphabet contains input alphabet plus âŠ” (blank symbol) plus maybe more symbols â–¶ Head has states (corresponding to the ï¬nite control automata) â–¶ Exactly one Accept state and exactly one Reject state (where computation immediately ends) â–¶ Remaining states â€œcomputation in progressâ€ â–¶ May never reach an accept state. May never halt! q0 1 0 q0 q1 1 â†’ R 0 â†’ L Lecture 5 Formal Deï¬nition of a TM A Turing Machine is a 7-tuple (Q, Î£, Î“, Î´, q0, qaccept , qreject ), where Q, Î£, Î“ are all ï¬nite sets and 1 Q is the set of states, 2 Î£ is the input alphabet not containing the blank symbol âŠ”, 3 Î“ is the tape alphabet, where âŠ” âˆˆ Î“ and Î£ âŠ† Î“, 4 Î´ : Q Ã— Î“ â†’ Q Ã— Î“ Ã— {L, R} is the transition function, 5 q0 âˆˆ Q is the start state, 6 qaccept âˆˆ Q is the accept state, and 7 qreject âˆˆ Q is the reject state, where qaccept , qreject . Lecture 5 Turing-Recognizable/Decidable Languages A TM machine M recognizes a language L âŠ† Î£ âˆ— iï¬€ for all inputs w âˆˆ Î£ âˆ—: 1 If w âˆˆ L then M accepts w and 2 If w < L then M either rejects w or never halts Such languages are called (Turing)-Recognizable A TM machine M decides a language L âŠ† Î£ âˆ— iï¬€ for all inputs w âˆˆ Î£ âˆ—: 1 M halts on w , and 2 M accepts w iï¬€ w âˆˆ L Such languages are called (Turing)-Decidable Lecture 5 Church-Turing Thesis 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefï¬cientâ€œFor examplea 6 Â· x Â· x Â· x Â· y Â· z Â· z =6x 3yz2 is a term with coefï¬cient 6a and 6x 3yz2 +3xy2 âˆ’ x 3 âˆ’ 10 is a polynomial with four termsa over the variables xa yaand zâ€œFor this discusË† siona we consider only coefï¬cients that are integersâ€œ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is â€“â€œ This polynomial has a root at x =5a y =3aand z =0â€œThis root is an integral root because all the variables are assigned integer valuesâ€œ Some polynomials have an integral root and some do notâ€œ Hilbertâ€™s tenth problem was to devise an algorithm that tests whether a polyË† nomial has an integral rootâ€œ He did not use the term algorithm but rather â€œa process according to which it can be determined by a ï¬nite number of operË† ationsâ€œâ€Â¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be â€œdevisedâ€œâ€ Thus he apparently assumed that such an algorithm must existâ€”someone need only ï¬nd itâ€œ As we now knowa no algorithm exists for this task; it is algorithmically unsolvË† ableâ€œ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossibleâ€œ The intuË† itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular taskâ€œ Proving that an algorithm does not exist requires having a clear deï¬nition of algorithmâ€œ Progress on the tenth problem had to wait for that deï¬nitionâ€œ The deï¬nition came in the â€”9Â´6 papers of Alonzo Church and Alan TurË† ingâ€œ Church used a notational system called the Î»Ë†calculus to deï¬ne algorithmsâ€œ Turing did it with his â€œmachinesâ€œâ€ These two deï¬nitions were shown to be equivalentâ€œ This connection between the informal notion of algorithm and the precise deï¬nition has come to be called the Churchâ€“Turing thesisâ€œ The Churchâ€“Turing thesis provides the deï¬nition of algorithm necessary to resolve Hilbertâ€™s tenth problemâ€œ In â€”97â€“a Yuri MatijaseviË˜ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral rootsâ€œ In Chapter Â¸ we deË† velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvableâ€œ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Churchâ€“Turing thesis Â¸Translated from the original Germanâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃ_Â·Ã°ÃÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃk_ÃÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾Ã_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°Ã_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃÃ°ÃˆÃ‘Ã°Ã_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃÃŒÂ²ÃÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃ_ÃˆÃ°ÃÃÃˆÃÂ®ÃÃÃ‰ÃƒÃ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm â–¶ All algorithms we know of can be executed on TMs â–¶ Anything you write in C, Java, Scala, Python and so on â–¶ The deï¬nition is also robust to variations: if we allow for many tapes instead of one, then nothing changes To show language decidable or recognizable it suï¬ƒcient to describe an algorithm in a high level language (Since by above any such algorithm can be run on a TM) Lecture 5 Decidable Languages Lecture 5 What can TMs compute? What can TMs do? ğ‘‡ğ‘€ğ¿ 001011 Accept Equal number of 1â€™s and 0â€™s And moreâ€¦ ğ‘‡ğ‘€ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 ğ‘‡ğ‘€ğ‘†â„ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘¡â„ 21 5 6 4 3 What can TMs do? ğ‘‡ğ‘€ğ¿ 001011 Accept Equal number of 1â€™s and 0â€™s And moreâ€¦ ğ‘‡ğ‘€ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 ğ‘‡ğ‘€ğ‘†â„ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘¡â„ 21 5 6 4 3 What can TMs do? ğ‘‡ğ‘€ğ¿ 001011 Accept Equal number of 1â€™s and 0â€™s And moreâ€¦ ğ‘‡ğ‘€ğ‘ğ‘œğ‘›ğ‘›ğ‘’ğ‘ğ‘¡ğ‘’ğ‘‘ Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 ğ‘‡ğ‘€ğ‘†â„ğ‘œğ‘Ÿğ‘¡ğ‘’ğ‘ ğ‘¡ğ‘ğ‘ğ‘¡â„ 21 5 6 4 3 Lecture 5 How to encode inputs How to encode inputs? ğšº ğ‘¸ ğ‘­ ğ’’ğŸ âˆ— ğ‘0 1 ğ‘2 âˆ— ğ‘0 0 ğ‘1 âˆ— ğ‘1 0 ğ‘2 âˆ— â‹® â€¦ Q Î£ ğ¹ ğ‘0 * ğ‘0 1 ğ‘2 * ğ‘0 0 â€¦ ğ‘« âˆˆ ğŸ,ğŸ â‹†: 1 ğ‘0 ğ‘2 0 0 0 ğ‘1 1 1ğ· 0 1 â€¦ 1 1 â€¦ 0 0 1 0 1 1 0 0 0 1 0 â€¦ 0 0 1 â€¦ Anything can be encoded using binary strings! Lecture 5 Checking Emptiness of a DFA EDFA = {âŸ¨DâŸ© : L(D) = âˆ…} First approach: 1 For each string s âˆˆ {Îµ, 0, 1, 00, 01, 10, 11, 000, . . .} 2 Simulate D on s â–¶ If D accepts s, THEN reject â–¶ ELSE, pick the next string and go to 2. Checking Emptiness ğ¸ğ·ğ¹ğ´â‰” ğ· ğ¿ğ· =âˆ…} First approach: 1. For each word ğ°âˆˆ{ğœ€,0,1,00,01,10,11,000,â‹¯} 2. Simulate ğƒon ğ° IF ğƒaccepts ğ’˜, THEN reject, ELSE, pick the next word and go to 2. If ğ¿ğ· =âˆ…,then this TM will never halt! If L(D) = âˆ…, then this TM will never halt! Checking Emptiness ğ¸ğ·ğ¹ğ´â‰” ğ· ğ¿ğ· =âˆ…} First approach: 1. For each word ğ°âˆˆ{ğœ€,0,1,00,01,10,11,000,â‹¯} 2. Simulate ğƒon ğ° IF ğƒaccepts ğ’˜, THEN reject, ELSE, pick the next word and go to 2. If ğ¿ğ· =âˆ…,then this TM will never halt! Lecture 5 Checking Emptiness of a DFA (2nd attempt) EDFA = {âŸ¨DâŸ© : L(D) = âˆ…} Checking Emptiness: Second Attempt Language accepted by a DFA is non-empty iff there is an accepting state that can be reached from the starting state by a sequence of transitions! Given âŒ©ğ‘«âŒªwith ğ‘«= ğ‘¸,ğšº,ğœ¹,ğ’’ğŸ,ğ‘­ 1. Initialize, ğ‘¹ â‰” ğ’’ğŸ 2. For each ğ’’âˆˆğ‘¹ and ğ’’â€²âˆˆğ‘¸\\ğ‘¹,check if there exists a transition of the form ğœ¹ğ’’,ğ’‚ =ğ’’â€²for some ğ’‚âˆˆğšº. 3. If at least one such ğ’’â€²is found, add ğ’’â€²to ğ‘¹ and go back to Step 2 4. Accept iff ğ‘¹ âˆ©ğ‘­=âˆ… ğ‘2ğ‘0 ğ‘11 0 01 1 0 1 ğ·1 ğ‘2ğ‘0 ğ‘11 0 0 1 0 ğ·2 1 ğ¸ğ·ğ¹ğ´â‰” ğ· ğ¿ğ· =âˆ…} Language accepted by a DFA is non-empty iï¬€ there is an accepting state that can be reached from the starting state by a sequence of transitions Given âŸ¨DâŸ© with D = (Q, Î£, Î´, q0, F ) 1 Initialize, R = {q0} 2 For each q âˆˆ R and qâ€² âˆˆ Q \\ R, check if there exists a transition of the form Î´(q, a) = qâ€² for some a âˆˆ Î£ 3 If at least one such qâ€² is found, add qâ€² to R and go back to Step 2 4 Accept iï¬€ R âˆ© F = âˆ… Lecture 5 Two DFAs recognize the same language? EQDFA = {âŸ¨D, Dâ€²âŸ© : L(D) = L(Dâ€²)} Fact: L(D) = L(Dâ€²) if and only if L(D) âŠ• L(Dâ€²) = âˆ… L(D) L(Dâ€²) â–¶ Here L(D) âŠ• L(Dâ€²) = (L(D) âˆ© L(Dâ€²) ) âˆª (L(D) âˆ© L(Dâ€²) ) â–¶ Thus L(D) âŠ• L(Dâ€²) is regular â–¶ Let DâŠ• be DFA accepting L(D) âŠ• L(Dâ€²) Two DFAs recognize the same Language? ğ¸ğ‘„ğ·ğ¹ğ´= ğ·,ğ·â€² ğ¿ ğ· =ğ¿(ğ·â€²)} Fact: ğ¿ ğ· âŠ• ğ¿ ğ·â€² = ğ¿ ğ· âˆ©ğ¿ ğ·â€² âˆª(ğ¿(ğ·)âˆ©ğ¿ ğ·â€²) ğ‘‡ğ‘€ğ¸ğ‘šğ‘ğ‘¡ğ‘¦ ğ· ğ·â€² ğ·,ğ·â€² âŒ©ğ·âŠ•âŒª ACCEPTâ†’ ACCEPT REJECT â†’REJECTâŠ• ğ‘‡ğ‘€ğ¸ğ‘„ Thus, ğ¿ ğ· âŠ• ğ¿ ğ·â€² is regular. Let ğ·âŠ• be DFA accepting ğ¿ ğ· âŠ• ğ¿(ğ·â€²) Fact: ğ‘³ğ‘« =ğ‘³(ğ‘« â€²)if and only if ğ‘³ğ‘« âŠ• ğ‘³ğ‘« â€² =âˆ… Encodes pairs of DFAs as strings More generally: ğ’ğ’ƒğ’‹returns an encoding of ğ’ğ’ƒğ’‹as a string Lecture 5 Mika, we get it: Turing machines can compute a lot but can they compute anything? NO Theorem (Turing 1936): Halting problem HALT = {âŸ¨M, w âŸ© : M is a TM and M halts on input w } is undecidable Intuitively the diï¬ƒculty of is to conclude in a ï¬nite number of steps whether M loops forever or is just slow to halt . . . Lecture 5 Halting problem is recognizable HALT = {âŸ¨M, w âŸ© : M is a TM and M halts on input w } HALT is recognizable! The following TM U recognizes HALT U = On input âŸ¨M, w âŸ© where M is a TM and w is a string: 1 Simulate M on input w . 2 If M ever halts (enters accept/reject state), accept. â–¶ Note that U loops on input âŸ¨M, w âŸ© if M loops on w , which is why this machine does not decide HALT â–¶ Since we will show that HALT is undecidable this shows that recognizers are more powerful than deciders Lecture 5 George Cantor (1845â€“1918) Diagonalization Lecture 5 Comparing the size of inï¬nite sets In 1873, Cantor thought about the size of inï¬nite sets â–¶ Is the set of natural numbers N = {1, 2, 3, . . . , } of the same size as the set of even numbers {2, 4, 6, . . . , . . .}? â–¶ Is the size of N equal to the size of the set of rational numbers Q = { m n : m, n âˆˆ N}? â–¶ Is the size of N equal to the size of the set of real numbers R? Lecture 5 Comparing the size of inï¬nite sets Recall that a function f : X â†’ Y is bijective if it is one-to-one it never maps two diï¬€erent elements to the same place â€“ that is, f (a) , f (aâ€²) whenever a , aâ€² onto it hits every element of Y â€“ that is, for every b âˆˆ Y there is an a âˆˆ X such that f (a) = b Deï¬nition. A set A is countable if either it is ï¬nite or it has the same size as N (i.e., there is a bijection between A and N) Lecture 5 Comparing the size of inï¬nite sets In 1873, Cantor thought about the size of inï¬nite sets â–¶ Is the set of natural numbers N = {1, 2, 3, . . . , } of the same size as the set of even numbers {2, 4, 6, . . . , . . .}? YES â–¶ Is the size of N equal to the size of the set of rational numbers Q = { m n : m, n âˆˆ N}? YES â–¶ Is the size of N equal to the size of the set of real numbers R? NO N and the set of even numbers are of the same size by the bijection f (n) = 2n: 4.2 UNDECIDABILITY 203 DEFINITION 4.12 Assume that we have sets A and B and a function f from A to Bâ€œ Say that f is one-to-one if it never maps two different elements to the same placeâ€”that isa if f (a) Ì¸= f (b) whenever a Ì¸= bâ€œSay that f is onto if it hits every element of Bâ€”that isa if for every b âˆˆ B there is an a âˆˆ A such that f (a)= bâ€œSay that A and B are the same size if there is a oneË†toË†onea onto function f : Aâˆ’â†’Bâ€œA function that is both oneË†toË†one and onto is called a correspondenceâ€œIn a correspondencea every element of A maps to a unique element of B and each element of B has a unique element of A mapping to itâ€œ Acorrespondenceis simply a way of pairing theelements of A with the elements of Bâ€œ Alternative common terminology for these types of functions is injective for oneË†toË†onea surjective for ontoa and bijective for oneË†toË†one and ontoâ€œ EXAMPLE 4.13 Let N be the set of natural numbers {1, 2, 3,...} and let E be the set of even natural numbers {2, 4, 6,...}â€œ Using Cantorâ€™s deï¬nition of sizea we can see that N and E have the same sizeâ€œ The correspondence f mapping N to E is simply f (n)= 2nâ€œWe can visualize f more easily with the help of a tableâ€œ n f (n) 1 2 2 4 3 6 â€œâ€œâ€œ â€œâ€œâ€œ Of coursea this example seems bizarreâ€œ Intuitivelya E seems smaller than N beË† cause E is a proper subset of N â€œBut pairing each member of N with its own member of E is possiblea so we declare these two sets to be the same sizeâ€œ DEFINITION 4.14 Aset A is countable if either it is ï¬nite or it has the same size as N â€œ EXAMPLE 4.15 Now we turn to an even stranger exampleâ€œ If we let Q = { m n | m, n âˆˆ N} be the set of positive rational numbersa Q seems to be much larger than N â€œYet these two sets are the same size according to our deï¬nitionâ€œ We give a correspondence with N to show that Q is countableâ€œ One easy way to do so is to list all the â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃ_Â·Ã°ÃÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃk_ÃÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾Ã_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°Ã_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃÃ°ÃˆÃ‘Ã°Ã_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃÃŒÂ²ÃÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃ_ÃˆÃ°ÃÃÃˆÃÂ®ÃÃÃ‰ÃƒÃ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃmN and Q are of the same size by a bit more complex bijection (see book). May seem bizzarre at ï¬rst but incredibly inï¬‚uential! â€œNo one shall expel us from the paradise which Cantor has created for us.â€ some space â€“ David Hilbert Diagonalization Lecture 5 The reals are uncountable â–¶ Suppose toward contradiction that there is a bijection f : N â†’ R â–¶ We reach a contradiction by deï¬ning an x âˆˆ R such that no number a âˆˆ N maps to x , i.e., f (a) = x â–¶ For every n âˆˆ N, the n-th fractional digit of x is selected to be diï¬€erent from the n-th digit of f (n) â–¶ Example: 206 CHAPTER 4 / DECIDABILITY n f (n) 1 3.14159 ... 2 55.55555 ... 3 0.12345 ... 4 0.50000 ... â€œâ€œâ€œ â€œâ€œâ€œ x = 0.4641 ... The preceding theorem has an important application to the theory of comË† putationâ€œ It shows that some languages are not decidable or even TuringË† recognizablea for the reason that there are uncountably many languages yet only countably many Turing machinesâ€œ Because each Turing machine can recognize asingle language and there are more languages than Turing machinesa some languages are not recognized by any Turing machineâ€œ Such languages are not TuringË†recognizablea as we state in the following corollaryâ€œ COROLLARY 4.18 Some languages are not TuringË†recognizableâ€œ PROOF To show that the set of all Turing machines is countablea we ï¬rst observe that the set of all strings Î£âˆ— is countable for any alphabet Î£â€œWith only ï¬nitely many strings of each lengtha we may form a list of Î£âˆ— by writing down all strings of length â€“a length â€”a length Â¨a and so onâ€œ The set of all Turing machines is countable because each Turing machine M has an encoding into a string âŸ¨M âŸ©â€œIf we simply omit those strings that are not legal encodings of Turing machinesa we can obtain a list of all Turing machinesâ€œ To show that the set of all languages is uncountablea we ï¬rst observe that the set of all inï¬nite binary sequences is uncountableâ€œ An inï¬nite binary sequence is an unending sequence of â€“s and â€”sâ€œ Let B be the set of all inï¬nite binary sequencesâ€œ We can show that B is uncountable by using a proof by diagonalization similar to the one we used in Theorem Â¸â€œâ€”7 to show that R is uncountableâ€œ Let L be the set of all languages over alphabet Î£â€œWe show that L is unË† countable by giving a correspondence with Bathus showing that the two sets are the same sizeâ€œ Let Î£âˆ— = {s1,s2,s3,...}â€œEach language A âˆˆ L has a unique sequence in Bâ€œThe ith bit of that sequence is a â€” if si âˆˆ A and is a â€“ if si Ì¸âˆˆ Aa which is called the characteristic sequence of Aâ€œFor examplea if A were the lanË† guage of all strings starting with a 0 over the alphabet {0,1}aits characteristic sequence Ï‡A would be Î£âˆ— = { Îµa 0a 1a 00a 01a 10a 11a 000a 001a Â·Â·Â· } ; A = { 0, 00, 01, 000, 001, Â·Â·Â· } ; Ï‡A =0 1 0 1 1 0 0 1 1 Â·Â·Â· . The function f : Lâˆ’â†’Bawhere f (A) equals the characteristic sequence of Aais oneË†toË†one and ontoa and hence is a correspondenceâ€œ Thereforea as B is uncountablea L is uncountable as wellâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃ_Â·Ã°ÃÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃk_ÃÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾Ã_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃÃŒÃŠÃŠÃˆÃ°ÃÃÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°Ã_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃÃ°ÃˆÃ‘Ã°Ã_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃÃŒÂ²ÃÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃ_ÃˆÃ°ÃÃÃˆÃÂ®ÃÃÃ‰ÃƒÃ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm â–¶ By deï¬nition there is no n âˆˆ N such that f (n) = x which contradicts that f is onto. Lecture 5 We now use Diagonalization to â–¶ First prove that there is a language that is not decidable â–¶ Then prove that the speciï¬c language HALT = {âŸ¨M, w âŸ© : M is a TM and M halts on w } is not decidable Lecture 5 There are undecidable languages â–¶ Turing machines are countable: enumerate all encodings âŸ¨M1âŸ© âŸ¨M2âŸ© âŸ¨M3âŸ© âŸ¨M4âŸ© âŸ¨M5âŸ© âŸ¨M6âŸ© . . . M1 A âˆ R A A R . . . M2 R R A A âˆ A . . . M3 R âˆ A âˆ R R . . . M4 A âˆ R R R âˆ . . . M5 âˆ âˆ A A A A . . . M6 R A R âˆ A âˆ . . . ... ... ... ... ... ... ... . . . Let DIAG = {âŸ¨Mi âŸ© : Mi doesnâ€™t accept âŸ¨Mi âŸ©} = {âŸ¨M2âŸ©, âŸ¨M4âŸ©, âŸ¨M6âŸ©, . . .} Theorem DIAG is undecidable Proof by contradiction â–¶ Suppose M decided DIAG â–¶ Then M = Mi for some i âˆˆ N â–¶ We have L(Mi ) = DIAG Does âŸ¨Mi âŸ© âˆˆ L(Mi )? Two cases â–¶ If âŸ¨Mi âŸ© âˆˆ L(Mi ) then by def. of DIAG, âŸ¨Mi âŸ© < DIAG â€“ contradiction â–¶ If âŸ¨Mi âŸ© < L(Mi ) then by def. of DIAG, âŸ¨Mi âŸ© âˆˆ DIAG â€“ contradiction Lecture 5 Thm: HALT = {âŸ¨M, w âŸ© : M is a TM and M halts on w } is undecidable Proof by contradiction Assume on the contrary that H is a decider for HALT We construct a decider D for DIAG = {âŸ¨MâŸ© : M doesnâ€™t accept âŸ¨MâŸ©} â–¶ D: On input âŸ¨MâŸ©, run H on input âŸ¨M, âŸ¨MâŸ©âŸ© 1 If H rejects (i.e., M loops on âŸ¨MâŸ©), accept 2 If H accepts (i.e., M halts on âŸ¨MâŸ©), run M on input âŸ¨MâŸ©. When M accepts/rejects, output the opposite. Need to prove that D decides DIAG: 1 D halts on all inputs 2 D accepts âŸ¨MâŸ© â‡â‡’ M does not accept âŸ¨MâŸ© â‡â‡’ âŸ¨MâŸ© âˆˆ DIAG Lecture 5 Thm: ATM = {âŸ¨M, w âŸ© : M is a TM and M accepts w } is undecidable Proof by contradiction Assume on the contrary that H is a decider for ATM Thm: ğ´ğ‘‡ğ‘€is Undecidable. Assume on the contrary that ğ‘¯ is a decider for ğ´ğ‘‡ğ‘€ ğ»âŒ©ğ‘€,ğ‘¤âŒª Accept (ğ‘€ accepts ğ‘¤) Reject (ğ‘€doesnâ€™t accept ğ‘¤) We construct a decider ğ‘«for ğ‘³ğ‘«ğ‘°ğ‘¨ğ‘®using ğ‘¯ and encoder/decoder functions for strings/TMs. Accept ğ‘¤ ğ‘– ğ‘¤ğ‘–(=ğ‘¤) âŒ©ğ‘€ğ‘–,ğ‘¤ğ‘–âŒª ğ» ğ· Accept Rejectğ‘€ğ‘– Reject STR-DEC STR-ENC TM-DEC Proof: (by contradiction) Need to prove that ğ‘«decides ğ‘³ğ‘«ğ‘°ğ‘¨ğ‘®! We construct a decider D for DIAG = {âŸ¨Mi âŸ© : M doesnâ€™t accept âŸ¨Mi âŸ©} using H: w 2 {0, 1}â‡¤ <latexit sha1_base64=\"kLQXTNA20UKi4EHQhjXIsU+PQ3Y=\">AAAB+XicbVBNS8NAEJ3Ur1q/oh69LLaCiJSkHhRPBS8eK9gPaGLZbDft0s0m7G4qJfSfePGgiFf/iTf/jds2B60+GHi8N8PMvCDhTGnH+bIKK6tr6xvFzdLW9s7unr1/0FJxKgltkpjHshNgRTkTtKmZ5rSTSIqjgNN2MLqZ+e0xlYrF4l5PEupHeCBYyAjWRurZduXRYwJ5mXPuetOHs0rPLjtVZw70l7g5KUOORs/+9PoxSSMqNOFYqa7rJNrPsNSMcDoteamiCSYjPKBdQwWOqPKz+eVTdGKUPgpjaUpoNFd/TmQ4UmoSBaYzwnqolr2Z+J/XTXV45WdMJKmmgiwWhSlHOkazGFCfSUo0nxiCiWTmVkSGWGKiTVglE4K7/PJf0qpV3Ytq7a5Wrl/ncRThCI7hFFy4hDrcQgOaQGAMT/ACr1ZmPVtv1vuitWDlM4fwC9bHN01xkhw=</latexit> Let Mi be TM with encoding w,i.e., hMii = w <latexit sha1_base64=\"+sdWX7toMZuvj55n0g/8TEEnQgs=\">AAACPXicbVBNSxxBFOzRJJqNSVY95vLITsCDDDPrISIIgpccFBR2VdgZlp6et7uN/TF097gsi3/Mi//BW25ePCji1au9HwejKWgoqt6jX1VeCm5dHP8NFhY/fPy0tPy59mXl67fv9dW1E6srw7DNtNDmLKcWBVfYdtwJPCsNUpkLPM3P9yf+6QUay7VquVGJmaR9xXucUeelbr2VKs1VgcrBAToID7s8hByhdQhD7gZp2mlKmQEqpguu+hAOw03gEUabEKaCqr5A8DuQmhmHXRiG3XojjuIp4D1J5qRB5jjq1m/SQrNK+jOYoNZ2krh02Zgax5nAy1paWSwpO6d97HiqqESbjafpL+GXVwroaeOfjzFVX2+MqbR2JHM/Kakb2LfeRPyf16lcbzsbc1VWzueffdSrBDgNkyqh4AaZEyNPKDPc3wpsQA1lzhde8yUkbyO/JyfNKNmKmsfNxt7OvI5l8oP8JBskIb/JHvlDjkibMHJFbsk9eQiug7vgMXiajS4E85118g+C5xfy3KrH</latexit> Mi, hMii <latexit sha1_base64=\"aeAU0Hqg7ho2+SfqUHUFDpMUEyQ=\">AAACA3icbZDLSgMxFIYz9VbrbdSdboKt4ELKTF0orgpu3AgV7AU6Q8mkZ9rQTGZIMkIpBTe+ihsXirj1Jdz5NqbTWWj1h8CX/5xDcv4g4Uxpx/myCkvLK6trxfXSxubW9o69u9dScSopNGnMY9kJiALOBDQ10xw6iQQSBRzawehqVm/fg1QsFnd6nIAfkYFgIaNEG6tnH1RueuwUe5yIAQdsLtiTGVd6dtmpOpnwX3BzKKNcjZ796fVjmkYgNOVEqa7rJNqfEKkZ5TAteamChNARGUDXoCARKH+S7TDFx8bp4zCW5giNM/fnxIRESo2jwHRGRA/VYm1m/lfrpjq88CdMJKkGQecPhSnHOsazQHCfSaCajw0QKpn5K6ZDIgnVJraSCcFdXPkvtGpV96xau62V65d5HEV0iI7QCXLROaqja9RATUTRA3pCL+jVerSerTfrfd5asPKZffRL1sc3wneWSw==</latexit> H Accept Reject Accept Reject Need to prove that D decides DIAG: 1 D halts on all inputs 2 D accepts âŸ¨MâŸ© â‡â‡’ M does not accept âŸ¨MâŸ© â‡â‡’ âŸ¨MâŸ© âˆˆ DIAG Lecture 5 Regular Decidable Recognizable ? Unrecognizable languages? Lecture 5 Unrecognizable languages exist! Thm: HALT is not recognizable Lecture 5 Step 1 Thm: A language L is decidable iï¬€ it is recognizable and its complement is also recognizable Proof: â–¶ Easy direction: If L is decidable â‡’ L, L are recognizable â–¶ Harder direction: Assume L, L are recognizable â–¶ Let M1, M2 be the corresponding recognizers Thm: A language ğ‘³ is decidable iff it is recognizable and its complement is also recognizable Easy Direction: If ğ¿ is decidable â‡’ ğ¿,à´¤ğ¿ are recognizable Harder Direction: Assume ğ¿,à´¤ğ¿ are recognizable â€¢ Let ğ‘€1,ğ‘€2be the corresponding recognizers â€¢ ğ‘´ decides ğ‘³ â€¢ For all ğ’˜, either ğ’˜âˆˆğ‘³ or ğ’˜âˆˆà´¥ğ‘³ â€¢ Either ğ‘´ğŸaccepts ğ’˜or ğ‘´ğŸaccepts ğ’˜ â€¢ ğ‘´ halts once one of them stops â‡’ ğ‘´ must always halt! ğ‘´ =\"Oninputw: 1- Run both ğ‘´ğŸand ğ‘´ğŸon input ğ’˜,in parallel 2- If ğ‘´ğŸaccepts, accept; if ğ‘´ğŸaccepts, reject\" Proof: Step 1 Formally: we alternate between running 1 step of ğ‘´ğŸand 1 step of ğ‘´ğŸ â–¶ M decides L â–¶ For all w , either w âˆˆ L or w âˆˆ Â¯L â–¶ Either M1 accepts w or M2 accepts w â–¶ M halts once one of them stops â‡’ M must always halt! Lecture 5 Step 2 Corollary: Language HALT is unrecognizable â–¶ Recall that â–¶ HALT is undecidable â–¶ HALT is recognizable â–¶ So by previous Thm we must have that HALT is unrecognizable Lecture 5 Next week: Reductions Lecture 5","libVersion":"0.5.0","langs":""}