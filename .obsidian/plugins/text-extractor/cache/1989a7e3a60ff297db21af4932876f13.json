{"path":"Lectures/Lecture5.pdf","text":"Lecture 5: Decidability and Undecidability Mika Göös School of Computer and Communication Sciences Lecture 5 290 15 Turing Machines Figure 1: Alan Turing’s “light bulb moment” – Prof. Geo↵ Draper drew this cartoon for my book never halt; it may keep zigzagging on the tape, writing symbols all over, and running amok, much like many tricky programs do in real life. A Turing machine cannot manufacture new symbols ad inﬁnitum - so all the symbols written by a Turing machine on its tape do belong to a ﬁnite tape alphabet, \u0000. Notice that ⌃ ⇢ \u0000, since \u0000 includes the blank symbol B that is not allowed within ⌃. We assume that a Turing machine begins its operation scanning cell number 0 of a doubly-inﬁnite tape (meaning that there are tape cells numbered +x or \u0000x for any x 2 Nat); more on this is in the following section. A fact to remember is this: in order to feed the string \" to a TM, one must present to the Turing machine a tape ﬁlled with blanks (B). However, some authors alter this convention slightly, allowing \" to be fed to a Turing machine by ensuring that, in the initial state, the symbol under the tape head is blank (B) (i.e., the rest of the tape could contain non-blank symbols). In any case, a normal Turing machine input is such that for every i 2 length(w), w[i] 6= B is presented on tape cell i, with all remaining tape cells containing B, and the head of the Turing machine faces w[1] at the beginning of a computation. A TM may be deterministic or nondeterministic. The signature of \u0000 for a deterministic Turing machine (DTM) is \u0000 : Q ⇥ \u0000 ! Q ⇥ \u0000 ⇥ {L, R}. This signature captures the fact that a TM can be in a certain state q 2 Q and looking at a 2 \u0000. It can then write a 0 on the tape in lieu of a, move to a state q0, and move its head left (L), or right (R), depending on whether \u0000(q, a)= hq0,a 0,Li or \u0000(q, a)= hq0,a 0 ,Ri,respectively. For an NDTM, \u0000(q, a) returns a set of next control states, tape symbol replacements, and head move directions. The signature of \u0000 for a nondeterministic Turing machine (NDTM) is \u0000 : Q ⇥ \u0000 ! 2 Q⇥\u0000⇥{L,R}. Think of a nondeterministic Turing machine as a C program where instead of the standard if-then-else construct, we have an if/fi construct of the following form: 2 Recall Lecture 5 The Turing Machine q0q1q2q3q4q5q3q0qaccept Head (with current state) 1 0 0 1 Inﬁnite Tape q0q0 q1q1 q2q2q3q3 q4q4 q5q5 qreject qacceptqaccept 1 → ⊔, R 0, 1 → R ⊔ → L 1 → ⊔, L 0, ⊔ → R0, 1 → L ⊔ → R 0 → ⊔, R 0, 1 → R ⊔ → L 0 → ⊔, L 1, ⊔ → R ⊔ → R Finite state control (the algorithm) This Turing machine accepts even length binary palindromes Lecture 5 Turing Machine 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conﬁguration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maˆ chine computes“ Say that conﬁguration C1 yields conﬁguration C2 if the Turing machine can legally go from C1 to C2 in a single step“ We deﬁne this notion formally as follows“ Suppose that we have aa baand c in Γaas well as u and v in Γ∗ and states qi and qj“In that casea ua qi bv and uqj acv are two conﬁgurations“ Say that ua qi bv yields uqj acv if in the transition function δ(qi,b)= (qj,c, L)“That handles the case where the Turing machine moves leftward“ For a rightward movea say that ua qi bv yields uac qj v if δ(qi,b)= (qj,c, R)“ Special cases occur when the head is at one of the ends of the conﬁguration“ For the leftˆhand enda the conﬁguration qi bv yields qj cv if the transition is leftˆ moving Abecause we prevent the machine from going off the leftˆhand end of the tape]a and it yields cqjv for the rightˆmoving transition“ For the rightˆhand enda the conﬁguration ua qi is equivalent to ua qi ␣ because we assume that blanks follow the part of the tape represented in the conﬁguration“ Thus we can handle this case as beforea with the head no longer at the rightˆhand end“ The start conﬁguration of M on input w is the conﬁguration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tape“ In an accepting conﬁgurationathe state of the conﬁguration is qaccept“In a rejecting conﬁgurationathe state of the conﬁguration is qreject“ Accepting and rejecting conﬁgurations are halting conﬁgurations and do not yield further conﬁgurations“ Because the machine is deﬁned to halt when in the states qaccept and qrejectawe equivalently could have deﬁned the transition function to have the more complicated form δ : Q′ × Γ−→ Q × Γ × {L, R}awhere Q′ is Q without qaccept and qreject“A Turing machine M accepts input w if a sequence of conﬁgurations C1a C2a ... a Ck existsa where 1. C1 is the start conﬁguration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conﬁguration“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ Inﬁnite tape ▶ Tape alphabet contains input alphabet plus ⊔ (blank symbol) plus maybe more symbols ▶ Head has states (corresponding to the ﬁnite control automata) ▶ Exactly one Accept state and exactly one Reject state (where computation immediately ends) ▶ Remaining states “computation in progress” ▶ May never reach an accept state. May never halt! q0 1 0 q0 q1 1 → R 0 → L Lecture 5 Formal Deﬁnition of a TM A Turing Machine is a 7-tuple (Q, Σ, Γ, δ, q0, qaccept , qreject ), where Q, Σ, Γ are all ﬁnite sets and 1 Q is the set of states, 2 Σ is the input alphabet not containing the blank symbol ⊔, 3 Γ is the tape alphabet, where ⊔ ∈ Γ and Σ ⊆ Γ, 4 δ : Q × Γ → Q × Γ × {L, R} is the transition function, 5 q0 ∈ Q is the start state, 6 qaccept ∈ Q is the accept state, and 7 qreject ∈ Q is the reject state, where qaccept , qreject . Lecture 5 Turing-Recognizable/Decidable Languages A TM machine M recognizes a language L ⊆ Σ ∗ iﬀ for all inputs w ∈ Σ ∗: 1 If w ∈ L then M accepts w and 2 If w < L then M either rejects w or never halts Such languages are called (Turing)-Recognizable A TM machine M decides a language L ⊆ Σ ∗ iﬀ for all inputs w ∈ Σ ∗: 1 M halts on w , and 2 M accepts w iﬀ w ∈ L Such languages are called (Turing)-Decidable Lecture 5 Church-Turing Thesis 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefﬁcient“For examplea 6 · x · x · x · y · z · z =6x 3yz2 is a term with coefﬁcient 6a and 6x 3yz2 +3xy2 − x 3 − 10 is a polynomial with four termsa over the variables xa yaand z“For this discusˆ siona we consider only coefﬁcients that are integers“ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is –“ This polynomial has a root at x =5a y =3aand z =0“This root is an integral root because all the variables are assigned integer values“ Some polynomials have an integral root and some do not“ Hilbert’s tenth problem was to devise an algorithm that tests whether a polyˆ nomial has an integral root“ He did not use the term algorithm but rather “a process according to which it can be determined by a ﬁnite number of operˆ ations“”¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be “devised“” Thus he apparently assumed that such an algorithm must exist—someone need only ﬁnd it“ As we now knowa no algorithm exists for this task; it is algorithmically unsolvˆ able“ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossible“ The intuˆ itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular task“ Proving that an algorithm does not exist requires having a clear deﬁnition of algorithm“ Progress on the tenth problem had to wait for that deﬁnition“ The deﬁnition came in the —9´6 papers of Alonzo Church and Alan Turˆ ing“ Church used a notational system called the λˆcalculus to deﬁne algorithms“ Turing did it with his “machines“” These two deﬁnitions were shown to be equivalent“ This connection between the informal notion of algorithm and the precise deﬁnition has come to be called the Church–Turing thesis“ The Church–Turing thesis provides the deﬁnition of algorithm necessary to resolve Hilbert’s tenth problem“ In —97–a Yuri Matijasevi˘ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral roots“ In Chapter ¸ we deˆ velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvable“ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Church–Turing thesis ¸Translated from the original German“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ All algorithms we know of can be executed on TMs ▶ Anything you write in C, Java, Scala, Python and so on ▶ The deﬁnition is also robust to variations: if we allow for many tapes instead of one, then nothing changes To show language decidable or recognizable it suﬃcient to describe an algorithm in a high level language (Since by above any such algorithm can be run on a TM) Lecture 5 Decidable Languages Lecture 5 What can TMs compute? What can TMs do? 𝑇𝑀𝐿 001011 Accept Equal number of 1’s and 0’s And more… 𝑇𝑀𝑐𝑜𝑛𝑛𝑒𝑐𝑡𝑒𝑑 Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 𝑇𝑀𝑆ℎ𝑜𝑟𝑡𝑒𝑠𝑡𝑝𝑎𝑡ℎ 21 5 6 4 3 What can TMs do? 𝑇𝑀𝐿 001011 Accept Equal number of 1’s and 0’s And more… 𝑇𝑀𝑐𝑜𝑛𝑛𝑒𝑐𝑡𝑒𝑑 Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 𝑇𝑀𝑆ℎ𝑜𝑟𝑡𝑒𝑠𝑡𝑝𝑎𝑡ℎ 21 5 6 4 3 What can TMs do? 𝑇𝑀𝐿 001011 Accept Equal number of 1’s and 0’s And more… 𝑇𝑀𝑐𝑜𝑛𝑛𝑒𝑐𝑡𝑒𝑑 Reject Checking connectedness Shortest path problem 1,6 3 21 5 6 4 𝑇𝑀𝑆ℎ𝑜𝑟𝑡𝑒𝑠𝑡𝑝𝑎𝑡ℎ 21 5 6 4 3 Lecture 5 How to encode inputs How to encode inputs? 𝚺 𝑸 𝑭 𝒒𝟎 ∗ 𝑞0 1 𝑞2 ∗ 𝑞0 0 𝑞1 ∗ 𝑞1 0 𝑞2 ∗ ⋮ … Q Σ 𝐹 𝑞0 * 𝑞0 1 𝑞2 * 𝑞0 0 … 𝑫 ∈ 𝟎,𝟏 ⋆: 1 𝑞0 𝑞2 0 0 0 𝑞1 1 1𝐷 0 1 … 1 1 … 0 0 1 0 1 1 0 0 0 1 0 … 0 0 1 … Anything can be encoded using binary strings! Lecture 5 Checking Emptiness of a DFA EDFA = {⟨D⟩ : L(D) = ∅} First approach: 1 For each string s ∈ {ε, 0, 1, 00, 01, 10, 11, 000, . . .} 2 Simulate D on s ▶ If D accepts s, THEN reject ▶ ELSE, pick the next string and go to 2. Checking Emptiness 𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 =∅} First approach: 1. For each word 𝐰∈{𝜀,0,1,00,01,10,11,000,⋯} 2. Simulate 𝐃on 𝐰 IF 𝐃accepts 𝒘, THEN reject, ELSE, pick the next word and go to 2. If 𝐿𝐷 =∅,then this TM will never halt! If L(D) = ∅, then this TM will never halt! Checking Emptiness 𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 =∅} First approach: 1. For each word 𝐰∈{𝜀,0,1,00,01,10,11,000,⋯} 2. Simulate 𝐃on 𝐰 IF 𝐃accepts 𝒘, THEN reject, ELSE, pick the next word and go to 2. If 𝐿𝐷 =∅,then this TM will never halt! Lecture 5 Checking Emptiness of a DFA (2nd attempt) EDFA = {⟨D⟩ : L(D) = ∅} Checking Emptiness: Second Attempt Language accepted by a DFA is non-empty iff there is an accepting state that can be reached from the starting state by a sequence of transitions! Given 〈𝑫〉with 𝑫= 𝑸,𝚺,𝜹,𝒒𝟎,𝑭 1. Initialize, 𝑹 ≔ 𝒒𝟎 2. For each 𝒒∈𝑹 and 𝒒′∈𝑸\\𝑹,check if there exists a transition of the form 𝜹𝒒,𝒂 =𝒒′for some 𝒂∈𝚺. 3. If at least one such 𝒒′is found, add 𝒒′to 𝑹 and go back to Step 2 4. Accept iff 𝑹 ∩𝑭=∅ 𝑞2𝑞0 𝑞11 0 01 1 0 1 𝐷1 𝑞2𝑞0 𝑞11 0 0 1 0 𝐷2 1 𝐸𝐷𝐹𝐴≔ 𝐷 𝐿𝐷 =∅} Language accepted by a DFA is non-empty iﬀ there is an accepting state that can be reached from the starting state by a sequence of transitions Given ⟨D⟩ with D = (Q, Σ, δ, q0, F ) 1 Initialize, R = {q0} 2 For each q ∈ R and q′ ∈ Q \\ R, check if there exists a transition of the form δ(q, a) = q′ for some a ∈ Σ 3 If at least one such q′ is found, add q′ to R and go back to Step 2 4 Accept iﬀ R ∩ F = ∅ Lecture 5 Two DFAs recognize the same language? EQDFA = {⟨D, D′⟩ : L(D) = L(D′)} Fact: L(D) = L(D′) if and only if L(D) ⊕ L(D′) = ∅ L(D) L(D′) ▶ Here L(D) ⊕ L(D′) = (L(D) ∩ L(D′) ) ∪ (L(D) ∩ L(D′) ) ▶ Thus L(D) ⊕ L(D′) is regular ▶ Let D⊕ be DFA accepting L(D) ⊕ L(D′) Two DFAs recognize the same Language? 𝐸𝑄𝐷𝐹𝐴= 𝐷,𝐷′ 𝐿 𝐷 =𝐿(𝐷′)} Fact: 𝐿 𝐷 ⊕ 𝐿 𝐷′ = 𝐿 𝐷 ∩𝐿 𝐷′ ∪(𝐿(𝐷)∩𝐿 𝐷′) 𝑇𝑀𝐸𝑚𝑝𝑡𝑦 𝐷 𝐷′ 𝐷,𝐷′ 〈𝐷⊕〉 ACCEPT→ ACCEPT REJECT →REJECT⊕ 𝑇𝑀𝐸𝑄 Thus, 𝐿 𝐷 ⊕ 𝐿 𝐷′ is regular. Let 𝐷⊕ be DFA accepting 𝐿 𝐷 ⊕ 𝐿(𝐷′) Fact: 𝑳𝑫 =𝑳(𝑫 ′)if and only if 𝑳𝑫 ⊕ 𝑳𝑫 ′ =∅ Encodes pairs of DFAs as strings More generally: 𝒐𝒃𝒋returns an encoding of 𝒐𝒃𝒋as a string Lecture 5 Mika, we get it: Turing machines can compute a lot but can they compute anything? NO Theorem (Turing 1936): Halting problem HALT = {⟨M, w ⟩ : M is a TM and M halts on input w } is undecidable Intuitively the diﬃculty of is to conclude in a ﬁnite number of steps whether M loops forever or is just slow to halt . . . Lecture 5 Halting problem is recognizable HALT = {⟨M, w ⟩ : M is a TM and M halts on input w } HALT is recognizable! The following TM U recognizes HALT U = On input ⟨M, w ⟩ where M is a TM and w is a string: 1 Simulate M on input w . 2 If M ever halts (enters accept/reject state), accept. ▶ Note that U loops on input ⟨M, w ⟩ if M loops on w , which is why this machine does not decide HALT ▶ Since we will show that HALT is undecidable this shows that recognizers are more powerful than deciders Lecture 5 George Cantor (1845–1918) Diagonalization Lecture 5 Comparing the size of inﬁnite sets In 1873, Cantor thought about the size of inﬁnite sets ▶ Is the set of natural numbers N = {1, 2, 3, . . . , } of the same size as the set of even numbers {2, 4, 6, . . . , . . .}? ▶ Is the size of N equal to the size of the set of rational numbers Q = { m n : m, n ∈ N}? ▶ Is the size of N equal to the size of the set of real numbers R? Lecture 5 Comparing the size of inﬁnite sets Recall that a function f : X → Y is bijective if it is one-to-one it never maps two diﬀerent elements to the same place – that is, f (a) , f (a′) whenever a , a′ onto it hits every element of Y – that is, for every b ∈ Y there is an a ∈ X such that f (a) = b Deﬁnition. A set A is countable if either it is ﬁnite or it has the same size as N (i.e., there is a bijection between A and N) Lecture 5 Comparing the size of inﬁnite sets In 1873, Cantor thought about the size of inﬁnite sets ▶ Is the set of natural numbers N = {1, 2, 3, . . . , } of the same size as the set of even numbers {2, 4, 6, . . . , . . .}? YES ▶ Is the size of N equal to the size of the set of rational numbers Q = { m n : m, n ∈ N}? YES ▶ Is the size of N equal to the size of the set of real numbers R? NO N and the set of even numbers are of the same size by the bijection f (n) = 2n: 4.2 UNDECIDABILITY 203 DEFINITION 4.12 Assume that we have sets A and B and a function f from A to B“ Say that f is one-to-one if it never maps two different elements to the same place—that isa if f (a) ̸= f (b) whenever a ̸= b“Say that f is onto if it hits every element of B—that isa if for every b ∈ B there is an a ∈ A such that f (a)= b“Say that A and B are the same size if there is a oneˆtoˆonea onto function f : A−→B“A function that is both oneˆtoˆone and onto is called a correspondence“In a correspondencea every element of A maps to a unique element of B and each element of B has a unique element of A mapping to it“ Acorrespondenceis simply a way of pairing theelements of A with the elements of B“ Alternative common terminology for these types of functions is injective for oneˆtoˆonea surjective for ontoa and bijective for oneˆtoˆone and onto“ EXAMPLE 4.13 Let N be the set of natural numbers {1, 2, 3,...} and let E be the set of even natural numbers {2, 4, 6,...}“ Using Cantor’s deﬁnition of sizea we can see that N and E have the same size“ The correspondence f mapping N to E is simply f (n)= 2n“We can visualize f more easily with the help of a table“ n f (n) 1 2 2 4 3 6 “““ “““ Of coursea this example seems bizarre“ Intuitivelya E seems smaller than N beˆ cause E is a proper subset of N “But pairing each member of N with its own member of E is possiblea so we declare these two sets to be the same size“ DEFINITION 4.14 Aset A is countable if either it is ﬁnite or it has the same size as N “ EXAMPLE 4.15 Now we turn to an even stranger example“ If we let Q = { m n | m, n ∈ N} be the set of positive rational numbersa Q seems to be much larger than N “Yet these two sets are the same size according to our deﬁnition“ We give a correspondence with N to show that Q is countable“ One easy way to do so is to list all the ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏmN and Q are of the same size by a bit more complex bijection (see book). May seem bizzarre at ﬁrst but incredibly inﬂuential! “No one shall expel us from the paradise which Cantor has created for us.” some space – David Hilbert Diagonalization Lecture 5 The reals are uncountable ▶ Suppose toward contradiction that there is a bijection f : N → R ▶ We reach a contradiction by deﬁning an x ∈ R such that no number a ∈ N maps to x , i.e., f (a) = x ▶ For every n ∈ N, the n-th fractional digit of x is selected to be diﬀerent from the n-th digit of f (n) ▶ Example: 206 CHAPTER 4 / DECIDABILITY n f (n) 1 3.14159 ... 2 55.55555 ... 3 0.12345 ... 4 0.50000 ... “““ “““ x = 0.4641 ... The preceding theorem has an important application to the theory of comˆ putation“ It shows that some languages are not decidable or even Turingˆ recognizablea for the reason that there are uncountably many languages yet only countably many Turing machines“ Because each Turing machine can recognize asingle language and there are more languages than Turing machinesa some languages are not recognized by any Turing machine“ Such languages are not Turingˆrecognizablea as we state in the following corollary“ COROLLARY 4.18 Some languages are not Turingˆrecognizable“ PROOF To show that the set of all Turing machines is countablea we ﬁrst observe that the set of all strings Σ∗ is countable for any alphabet Σ“With only ﬁnitely many strings of each lengtha we may form a list of Σ∗ by writing down all strings of length –a length —a length ¨a and so on“ The set of all Turing machines is countable because each Turing machine M has an encoding into a string ⟨M ⟩“If we simply omit those strings that are not legal encodings of Turing machinesa we can obtain a list of all Turing machines“ To show that the set of all languages is uncountablea we ﬁrst observe that the set of all inﬁnite binary sequences is uncountable“ An inﬁnite binary sequence is an unending sequence of –s and —s“ Let B be the set of all inﬁnite binary sequences“ We can show that B is uncountable by using a proof by diagonalization similar to the one we used in Theorem ¸“—7 to show that R is uncountable“ Let L be the set of all languages over alphabet Σ“We show that L is unˆ countable by giving a correspondence with Bathus showing that the two sets are the same size“ Let Σ∗ = {s1,s2,s3,...}“Each language A ∈ L has a unique sequence in B“The ith bit of that sequence is a — if si ∈ A and is a – if si ̸∈ Aa which is called the characteristic sequence of A“For examplea if A were the lanˆ guage of all strings starting with a 0 over the alphabet {0,1}aits characteristic sequence χA would be Σ∗ = { εa 0a 1a 00a 01a 10a 11a 000a 001a ··· } ; A = { 0, 00, 01, 000, 001, ··· } ; χA =0 1 0 1 1 0 0 1 1 ··· . The function f : L−→Bawhere f (A) equals the characteristic sequence of Aais oneˆtoˆone and ontoa and hence is a correspondence“ Thereforea as B is uncountablea L is uncountable as well“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ By deﬁnition there is no n ∈ N such that f (n) = x which contradicts that f is onto. Lecture 5 We now use Diagonalization to ▶ First prove that there is a language that is not decidable ▶ Then prove that the speciﬁc language HALT = {⟨M, w ⟩ : M is a TM and M halts on w } is not decidable Lecture 5 There are undecidable languages ▶ Turing machines are countable: enumerate all encodings ⟨M1⟩ ⟨M2⟩ ⟨M3⟩ ⟨M4⟩ ⟨M5⟩ ⟨M6⟩ . . . M1 A ∞ R A A R . . . M2 R R A A ∞ A . . . M3 R ∞ A ∞ R R . . . M4 A ∞ R R R ∞ . . . M5 ∞ ∞ A A A A . . . M6 R A R ∞ A ∞ . . . ... ... ... ... ... ... ... . . . Let DIAG = {⟨Mi ⟩ : Mi doesn’t accept ⟨Mi ⟩} = {⟨M2⟩, ⟨M4⟩, ⟨M6⟩, . . .} Theorem DIAG is undecidable Proof by contradiction ▶ Suppose M decided DIAG ▶ Then M = Mi for some i ∈ N ▶ We have L(Mi ) = DIAG Does ⟨Mi ⟩ ∈ L(Mi )? Two cases ▶ If ⟨Mi ⟩ ∈ L(Mi ) then by def. of DIAG, ⟨Mi ⟩ < DIAG – contradiction ▶ If ⟨Mi ⟩ < L(Mi ) then by def. of DIAG, ⟨Mi ⟩ ∈ DIAG – contradiction Lecture 5 Thm: HALT = {⟨M, w ⟩ : M is a TM and M halts on w } is undecidable Proof by contradiction Assume on the contrary that H is a decider for HALT We construct a decider D for DIAG = {⟨M⟩ : M doesn’t accept ⟨M⟩} ▶ D: On input ⟨M⟩, run H on input ⟨M, ⟨M⟩⟩ 1 If H rejects (i.e., M loops on ⟨M⟩), accept 2 If H accepts (i.e., M halts on ⟨M⟩), run M on input ⟨M⟩. When M accepts/rejects, output the opposite. Need to prove that D decides DIAG: 1 D halts on all inputs 2 D accepts ⟨M⟩ ⇐⇒ M does not accept ⟨M⟩ ⇐⇒ ⟨M⟩ ∈ DIAG Lecture 5 Thm: ATM = {⟨M, w ⟩ : M is a TM and M accepts w } is undecidable Proof by contradiction Assume on the contrary that H is a decider for ATM Thm: 𝐴𝑇𝑀is Undecidable. Assume on the contrary that 𝑯 is a decider for 𝐴𝑇𝑀 𝐻〈𝑀,𝑤〉 Accept (𝑀 accepts 𝑤) Reject (𝑀doesn’t accept 𝑤) We construct a decider 𝑫for 𝑳𝑫𝑰𝑨𝑮using 𝑯 and encoder/decoder functions for strings/TMs. Accept 𝑤 𝑖 𝑤𝑖(=𝑤) 〈𝑀𝑖,𝑤𝑖〉 𝐻 𝐷 Accept Reject𝑀𝑖 Reject STR-DEC STR-ENC TM-DEC Proof: (by contradiction) Need to prove that 𝑫decides 𝑳𝑫𝑰𝑨𝑮! We construct a decider D for DIAG = {⟨Mi ⟩ : M doesn’t accept ⟨Mi ⟩} using H: w 2 {0, 1}⇤ <latexit sha1_base64=\"kLQXTNA20UKi4EHQhjXIsU+PQ3Y=\">AAAB+XicbVBNS8NAEJ3Ur1q/oh69LLaCiJSkHhRPBS8eK9gPaGLZbDft0s0m7G4qJfSfePGgiFf/iTf/jds2B60+GHi8N8PMvCDhTGnH+bIKK6tr6xvFzdLW9s7unr1/0FJxKgltkpjHshNgRTkTtKmZ5rSTSIqjgNN2MLqZ+e0xlYrF4l5PEupHeCBYyAjWRurZduXRYwJ5mXPuetOHs0rPLjtVZw70l7g5KUOORs/+9PoxSSMqNOFYqa7rJNrPsNSMcDoteamiCSYjPKBdQwWOqPKz+eVTdGKUPgpjaUpoNFd/TmQ4UmoSBaYzwnqolr2Z+J/XTXV45WdMJKmmgiwWhSlHOkazGFCfSUo0nxiCiWTmVkSGWGKiTVglE4K7/PJf0qpV3Ytq7a5Wrl/ncRThCI7hFFy4hDrcQgOaQGAMT/ACr1ZmPVtv1vuitWDlM4fwC9bHN01xkhw=</latexit> Let Mi be TM with encoding w,i.e., hMii = w <latexit sha1_base64=\"+sdWX7toMZuvj55n0g/8TEEnQgs=\">AAACPXicbVBNSxxBFOzRJJqNSVY95vLITsCDDDPrISIIgpccFBR2VdgZlp6et7uN/TF097gsi3/Mi//BW25ePCji1au9HwejKWgoqt6jX1VeCm5dHP8NFhY/fPy0tPy59mXl67fv9dW1E6srw7DNtNDmLKcWBVfYdtwJPCsNUpkLPM3P9yf+6QUay7VquVGJmaR9xXucUeelbr2VKs1VgcrBAToID7s8hByhdQhD7gZp2mlKmQEqpguu+hAOw03gEUabEKaCqr5A8DuQmhmHXRiG3XojjuIp4D1J5qRB5jjq1m/SQrNK+jOYoNZ2krh02Zgax5nAy1paWSwpO6d97HiqqESbjafpL+GXVwroaeOfjzFVX2+MqbR2JHM/Kakb2LfeRPyf16lcbzsbc1VWzueffdSrBDgNkyqh4AaZEyNPKDPc3wpsQA1lzhde8yUkbyO/JyfNKNmKmsfNxt7OvI5l8oP8JBskIb/JHvlDjkibMHJFbsk9eQiug7vgMXiajS4E85118g+C5xfy3KrH</latexit> Mi, hMii <latexit sha1_base64=\"aeAU0Hqg7ho2+SfqUHUFDpMUEyQ=\">AAACA3icbZDLSgMxFIYz9VbrbdSdboKt4ELKTF0orgpu3AgV7AU6Q8mkZ9rQTGZIMkIpBTe+ihsXirj1Jdz5NqbTWWj1h8CX/5xDcv4g4Uxpx/myCkvLK6trxfXSxubW9o69u9dScSopNGnMY9kJiALOBDQ10xw6iQQSBRzawehqVm/fg1QsFnd6nIAfkYFgIaNEG6tnH1RueuwUe5yIAQdsLtiTGVd6dtmpOpnwX3BzKKNcjZ796fVjmkYgNOVEqa7rJNqfEKkZ5TAteamChNARGUDXoCARKH+S7TDFx8bp4zCW5giNM/fnxIRESo2jwHRGRA/VYm1m/lfrpjq88CdMJKkGQecPhSnHOsazQHCfSaCajw0QKpn5K6ZDIgnVJraSCcFdXPkvtGpV96xau62V65d5HEV0iI7QCXLROaqja9RATUTRA3pCL+jVerSerTfrfd5asPKZffRL1sc3wneWSw==</latexit> H Accept Reject Accept Reject Need to prove that D decides DIAG: 1 D halts on all inputs 2 D accepts ⟨M⟩ ⇐⇒ M does not accept ⟨M⟩ ⇐⇒ ⟨M⟩ ∈ DIAG Lecture 5 Regular Decidable Recognizable ? Unrecognizable languages? Lecture 5 Unrecognizable languages exist! Thm: HALT is not recognizable Lecture 5 Step 1 Thm: A language L is decidable iﬀ it is recognizable and its complement is also recognizable Proof: ▶ Easy direction: If L is decidable ⇒ L, L are recognizable ▶ Harder direction: Assume L, L are recognizable ▶ Let M1, M2 be the corresponding recognizers Thm: A language 𝑳 is decidable iff it is recognizable and its complement is also recognizable Easy Direction: If 𝐿 is decidable ⇒ 𝐿,ത𝐿 are recognizable Harder Direction: Assume 𝐿,ത𝐿 are recognizable • Let 𝑀1,𝑀2be the corresponding recognizers • 𝑴 decides 𝑳 • For all 𝒘, either 𝒘∈𝑳 or 𝒘∈ഥ𝑳 • Either 𝑴𝟏accepts 𝒘or 𝑴𝟐accepts 𝒘 • 𝑴 halts once one of them stops ⇒ 𝑴 must always halt! 𝑴 =\"Oninputw: 1- Run both 𝑴𝟏and 𝑴𝟐on input 𝒘,in parallel 2- If 𝑴𝟏accepts, accept; if 𝑴𝟐accepts, reject\" Proof: Step 1 Formally: we alternate between running 1 step of 𝑴𝟏and 1 step of 𝑴𝟐 ▶ M decides L ▶ For all w , either w ∈ L or w ∈ ¯L ▶ Either M1 accepts w or M2 accepts w ▶ M halts once one of them stops ⇒ M must always halt! Lecture 5 Step 2 Corollary: Language HALT is unrecognizable ▶ Recall that ▶ HALT is undecidable ▶ HALT is recognizable ▶ So by previous Thm we must have that HALT is unrecognizable Lecture 5 Next week: Reductions Lecture 5","libVersion":"0.5.0","langs":""}