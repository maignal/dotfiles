{"path":"The Essential/Summaries/Theory_of_Computation.pdf","text":"Theory of Computation ﬁche Pierre Colson Contents Cours 1 Automata and Languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 1 Turing Machine . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Decidable languages . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 2 Time complexity . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 3 Example 4 Markdown version on github Compiled using pandoc and gpdf script Cours Automata and Languages • A deterministic ﬁnite automaton (DFA) is a 5-tuples (Q, Σ, δ, q0, F ), where : 1) Q is a ﬁnite set called the states 2) Σ is a ﬁnite set called the alphabet 3) δ : Q × Σ −→ Q is the transition function 4) q0 ∈ Q is the start state 5) F ⊆ Q is the set of accept states • A nondeterministic ﬁnite automaton (NFA) is a 5-tuple (Q, Σ, δ, q0, F ) where : 1) Q is a ﬁnite set called the states 2) Σ is a ﬁnite set called the alphabet 3) δ : Q × Σϵ −→ P (Q) is the transition function 4) q0 ∈ Q is the start state 5) F ⊆ Q is the set of accept states • Deterministic and nondeterministic ﬁnite automata recognize the same class of languages. Say that two machines are equivalent if they recognize the same language. • A language is called a regular language if some ﬁnite automaton recognizes it. • Every nondeterministic ﬁnite automaton has an equivalent deterministic ﬁnite automaton. • Let A and B be languages. We deﬁne the regular operations union, intersection, concatenation and the star as follows: 1) Union: A ∪ B = {x | x ∈ A or x ∈ B} 2) intersection A ∩ B = {x | x ∈ A and x ∈ B} 3) Concatenation: A ◦ B = {xy | x ∈ A and y ∈ B} 4) Star: A∗ = {x1x2...xk | k ≥ 0 and each xi ∈ A} 1 • The class of regular language is closed under the union operation, intersection operation, concatenation operation, start operation. • The complement ( ¯L = {w ∈ Σ∗ : w is not in L} ) of a regular language is also regular. • Say that R is a regualr expression is R is: 1) a for some a in the alphabet Σ 2) ϵ 3) ∅ 4) ¯R1 where R1 is aregular language 5) (R1 ∪ R2) where R1 and R2 are regular expressions 6) (R1 ∩ R2) where R1 and R2 are regular expressions 7) (R1 ◦ R2) where R1 and R2 are regular expressions 8) (R∗ 1) where R1 is a regular expression • A language is relular if and only if some regular expressions describes it. • Pumping Lemma: If A is a regular language, then there is a number p (the pumping lemma) where if s is any string in A of length a least p, then the s may be divided into three pieces, s = xyz, satisfying the following conditions: 1) for each i ≥ 0, xyiz ∈ A 2) |y| > 0, and 3) |xy| ≤ p Turing Machine • A Turing Machine is a 7-tuples, (Q, Σ, Γ, δ, q0, qaccept, qreject), where Q, Σ, Γ are all ﬁnite set and : 1) Q is the set of states, 2) Σ is the input alphabet not containing the blank symbol _ 3) Γ is the tape alphabet where _ ∈ Γ and Σ ⊂ Γ 4) δ : Q × Γ −→ Q × Γ × {L, R} is the transition function, 5) q0 ∈ Q is the start state, 6) qaccept ∈ Q is the accept state, and 7) qreject ∈ Q is the reject state, where qreject ̸= qaccept. • Call a language Turing reconizable or simply reconizable if some Turing machine recognizes it. A Turing machine M recognizes a language L ⊆ Σ∗ if and only if al inputs w ∈ Σ∗ : 1) if w ∈ L then M accepts w and 2) if w /∈ L then M either rejects w or never halts • Call a language Turing decidable or simply decidable if some Turing machine decides it. A Turing machine M decides a language L ⊆ Σ∗ if and only if al inputs w ∈ Σ∗ : 1) M halts on w, and 2) M accepts w if and only if w ∈ L • Every multitape Turing machine has an equivalent single-tape Turing machine • Every nondeterministic Turing machine has an equivalent deterministic Turing machine Decidable languages • ADF A = {⟨B, w⟩ | B is a DFA that accpets input string w}. ADF A is a decidable language. • AN F A = {⟨B, w⟩ | B is and NFA that accepts input string w}. AN F A is a decidable language. • EQDF A = {⟨A, B⟩ | A, B are DFAs s.t. L(A) = L(B)}. EQDF A is decidable. 2 • EDF A = {⟨D⟩ : L(D) =}. EDF A is decidable. (not verify yet) • LDIAG = {⟨Mi⟩ : Mi doesn’t accept ⟨Mi⟩}. LDIAG is undecidable • AT M = {⟨M, w⟩ | M is a TM and M accepts w}. AT M is undecidable. • REGT M = {⟨N ⟩ | L(N ) is regular}. REGT M is undecidable. • EQT M = {⟨M1, M2⟩ | M1, M2 are TMs s.t. L(M1) = L(M2)}. EQT M is undecidable. • ET M = {⟨M ⟩ : L(M ) =}. ET M is undecidable. (not verify yet) • Halting problem, let HALTT M = {⟨M, w⟩ | M is a TM and M halts on input w}. HALTT M is undecidable. • A language is decidable if and only if it is Turing reconizable and co Turing reconizable. In other words, a language is decidable exactly when both it and its complement are Turing reconizable. • A function f : Γ∗ −→ Γ∗ is a computable function is some Turing machien M , on every input w, halts with just f (w) on its tape. • Language A is mapping reducible to language B, written A ≤m B, if ther is a computable function f : Γ ∗ −→ Γ ∗, where for every w, w ∈ A ⇐⇒ f (w) ∈ B. The function f is called the reduction from A to B. • If A ≤m B and B is decidable, then A is decidable (same for reconizable) • If A ≤m B and A is undecidable, then B is undicidable (same for reconizable) • If B ≤m ¯B then ¯B ≤m B Time complexity • P is the calss of languages that are decidable in polynomial time on a deterministic Turing machine : P = ∞⋃ k=1 T IM E(nk) • A veriﬁer for a language A is an algorithm V , where: A = {w | V accepts ⟨w, c⟩ for some string c} • N P is the class on languages that have a polynomial time veriﬁers • NP-complete A language B is NP-complete if it satiﬁes two conditions : 1) B is in N P , and 2) every A in N P is polynomial time reductible to B • SAT Conjunctive Normal Form (CNF) Formula : ϕ = ( ¯X ∨ ¯y ∨ z0) ∧ (x ∨ ¯y ∨ z2) ∧ (x ∨ y ∨ z3) SAT = {⟨φ⟩ | φ is a satisﬁable Booolean formula} SAT is N P − complete 3 • CLIQUE The CLIQUE problem is to determine whether a graph contains a clique (fully connected subgraph) of a speciﬁed size. Let : CLIQU E = {⟨G, k⟩ | G is an undirected graph with ak − clique} CLIQUE is N P − complete • SUBSET-SUM We want to determine whether the collection contains a subcollection that adds up to t. Thus : SU BSET −SU M = {⟨S, t⟩ | S = {x1, . . . , xk} and for some {y1, . . . , yl} ⊆ {x1, . . . , xk} we have ∑ yi = t} SUBSET-SUM is N P − complete • 3SAT 3cnf-formula: all the clauses have three literals. Let : 3SAT = {⟨φ⟩ | φ is a satisﬁable 3cnf-formula} 3SAT is polynomial time reductible to CLIQUE. Thus it is N P − complete • INDESET IN DSET = {(G, k) : G has an independent subset of size k} INDSET is N P − complete • VERTEX-COVER If G is an undirected graph, a vertx cover of G is a subset of the nodes where every edges of G touches one of thoses nodes. The vertex cover problem asks whether a graph contains a vertex cover of a speciﬁed size. V ERT EX − COV ER = {⟨G, k⟩ | G is an undirected graph taht has ak-node vertex cover} VERTEX-COVER is N P − complete • SET-COVER Let U = {1, . . . , N } and F = {T1, . . . , Tm} be a family of subsets ∀i, Ti ⊆ U . A subset {Ti1, . . . , Tik } ⊆ F is called a set cover of size k if ⋃k j=1 Tij = U • If A ≤p B and B ∈ P , then A ∈ P • If B is N P − complete and B ≤p C for C in N P , then C is N P − complete Example • Pumping Lemma : Let B be the languages {0 n1 n | n ≥ 0}. We use the pumping lemma to prove that B is not regular. The proof is by contradiction. Assume to the contrary that B is regular. Let p be the pumping length given by the pumping lemma. Choose s to be the string 0 p1 p. Because s is a member of B and s has length more than p, the pumping lemma guarantees that s can be split into three pieces, s = xyz where |xy| ≤ p, |y| ≥ 1 and for any i ≥ 0 the string xyiz is in B. We consider three cases to show that this result is impossible: 1) The string y consists only of 0s. In this case, the string xyyz has more 0s than 1s and so is not a member of B, violating condition 1 of the pumping lemma. This case is a contradiction. 2) The string y consists only of 1s. This case also gives a contradiction. 3) The string y consists of both 0s and 1s. In this case, the string xyyz may have the same number of 0s and 1s, but they will be out of order with some 1s before 0s. Hence it is not a member of B, which is a contradiction. 4","libVersion":"0.5.0","langs":""}