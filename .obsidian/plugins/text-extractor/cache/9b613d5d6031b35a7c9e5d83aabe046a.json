{"path":"Exam/Solutions/ToC_exam_2022-sols.pdf","text":"Final Exam, Theory of Computation 2022 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in sufficient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in lectures (but not exercises) including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 15 points / 15 points / 15 points / 20 points / 20 points / 15 points Total / 100 Page 1 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 1 (15 pts) Quick-fire round. Consider the following statements. 1. If A is regular and B ≤p A, then B is regular. 2. If A can be recognised by an NFA, then A can also be recognised by an NFA. 3. If A is decidable and B ⊆ A, then B is decidable. 4. If A is NP-complete and A ≤p B, then B is NP-complete. 5. If A is recognisable and A ≤m A, then A is undecidable. 6. If A and B are recognisable, then A ∩ B is recognisable. 7. The language {0n1m : n − m is divisible by 2022} is regular. 8. The language {⟨D⟩ : D is a DFA and L(D) is infinite} is decidable. 9. The language {⟨M ⟩ : M is a TM and L(M ) is infinite} is recognisable. 10. The language {⟨G⟩ : G is a graph that contains a clique of size 2022} is in P. 11. 3-SAT ≤p 2-SAT. 12. SAT ≤m HALT. 13. If P = NP, then Graph-Isomorphism ∈ P. 14. If NP ̸= coNP, then SAT /∈ coNP. 15. Every function f : {0, 1}n → {0, 1} can be computed by a CNF with O(2n) clauses. For each box below, write one of the following symbols: − T if the statement is known to be true. − F if the statement is false or not known to be true. E.g., both P = NP and P ̸= NP should be marked F. − or leave the box empty. A correct T/F answer is worth +1 point, an incorrect answer is worth −1 point, and an empty answer is worth 0 points. 1. F 2. T 3. F 4. F 5. F 6. T 7. T 8. T 9. F 10. T 11. F 12. T 13. T 14. T 15. T Page 2 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 2 (15 pts) Pumping Lemma. 2a Write down the statement of the Pumping Lemma. (Only the statement, not its proof !) 2b For a string w = w1w2 · · · wn ∈ {0, 1}n define its reverse wR as the string written back- wards, that is, wR = wnwn−1 · · · w1. Show that the following language is not regular: L = {w ∈ {0, 1} ∗ : wR = w}. (A word w such that wR = w is called a palindrome.) Solution: 2a If A is a regular language, then there exists a number p(the pumping length) such that, for every string s ∈ A, of length at least p, there exists a division of s into three pieces s = xyz such that, • ∀i ≥ 0, xyiz ∈ A • |y| ≥ 1 • |xy| ≤ p 2b Assume the given L is regular, then there exists p a pumping length. Consider w = 0n110n. Clearly w = wR =⇒ w ∈ L. Also |w| ≥ p. Therefore, from the pumping lemma, there exists x, y, z satisfying the constraints of the pumping lemma such that w = xyz. Since |xy| ≤ p, this means x and y are completely contained within the 0p prefix of w. This implies |y| <= p, and since we also know that |y| >= 1, we can state that y = 0k for k ∈ [1, p]. Consider xy2z = 0p+k110p. xy2z ∈ L only if p + k = p i.e k = 0. This is a contradiction since k ∈ [1, p]. Hence L is not regular. Some grading guidelines: 2a (-1 pt) Ordering of the conditions in the pumping lemma. 2b (-1 pt), Directly using y = 0k rather than deducing it must be of that form and in fact we need to show that no division w = xyz must exist that can be pumped. (-2 pt) Choosing a specific decomposition instead of treating x, y, z as arbitrary, however encom- passing all the y = 0k decompositions. (-3 pt) Choosing a very specific decomposition like y = 0. (-5 pt) Choosing a wrong word w and choosing a specific decomposition that fails to be pumped. (-5 pt) Choosing a non palindrome word w. Page 3 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 3 (15 pts) Regular languages. For any language A ⊆ {0, 1}∗, define Drop(A) to be the language containing all strings that can be obtained by removing one bit from a string in A. That is, Drop(A) = {xy : xby ∈ A where b ∈ {0, 1}}. Show that if A is regular, then so is Drop(A). (Here it suffices that you describe clearly how to construct a DFA/NFA for Drop(A). You do not need to formally prove the correctness of your construction.) Solution: Let DA = (Q, Σ, δ, q0, F ) be the DFA that recognizes A. We define D′ A = (Q′, Σ′, δ′, q′ 0, F ′) and D′′ A = (Q′′, Σ′′, δ′′, q′′ 0 , F ′′), two copies of DA. We use these copies to build an NFA that recognizes DROP(A). Let N = (QN , ΣN , δN , q0N , FN ) be defined as follows: QN = Q ′ ∪ Q′′ ΣN = Σ ′ ∪ {ϵ} = Σ ′′ ∪ {ϵ} q0,N = q′ 0 FN = F ′′ δN (q, σ) =    δ′(q, σ), if q ∈ Q′ and σ ∈ {0, 1}, δ′′(q, σ), if q ∈ Q′′ and σ ∈ {0, 1}, δ′′(q′′, σ), if q ∈ Q′ and σ = ϵ. where, in the last line, q′′ is the state of D′′ A corresponding to q. The starting state of N is the starting state of D′ A, the set of accepting states if the one of D′′ A. These choices guarantee that one - and only one - bit is dropped. Example: q0 q1 q2 1 0 1 0 0 1 q′ 0 q′ 1 q′ 2 q′′ 0 q′′ 1 q′′ 2 1 0 1 0 0 1 1 0 1 0 0 1 ε Figure 1. DA (left) and N (right). The gray arrows in N are the new ε transitions. Common mistakes and grading scheme: • Unspecified q0,N , wrong FN [-2 point]. • Self-transitions not considered [-3 points]. Page 4 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös • 0/1-transitions to corresponding state in D′′ A (add one bit instead of dropping it) [-6 points]. • DA duplicated 2|Q| times, a different transition becomes an ε one in each copy [-8 points]. • DA not duplicated, ε-transitions added without modification of DA structure [-10 points]. • Definition of N based on input string xby [-11 points]. • Cut/copy/paste parts of DA assuming ordered states (no \"backward loops\") [-11 points]. • Assumption that A is finite [-13 points]. Page 5 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 4 (20 pts) NP-completeness. Let G = (L ∪ R, E) be a bipartite graph with left vertices L, right vertices R (where L ∩ R = ∅), and where edges exist only between left and right vertices, that is, E ⊆ L × R. We say that a subset D ⊆ L is a left-dominating set iff for every right vertex v ∈ R there is some u ∈ D such that (u, v) ∈ E. For example, the highlighted vertices in the bipartite graph below form a left-dominating set of size 2. Show that the following problem is NP-complete: LeftDom = {⟨G, k⟩ : G is a bipartite graph with a left-dominating set of size k}. (In your proof, you may assume the NP-completeness of any of the problems discussed in the lec- tures, but not exercises/homework. This includes SAT, Independent-Set, Clique, Vertex- Cover, Set-Cover, Subset-Sum, etc. Make sure to prove that your reduction is correct!) Solution: We first show that LeftDom ∈ NP. Given a birpartite graph G = (L ∪ R, E), a positive integer k, and a certificate C, the nonderterministic algorithm checks: (i) The certificate C encodes a subset of vertices D ⊆ L of size k. (ii) For any v ∈ R, there exists u ∈ D such that (u, v) ∈ E. And the algorithm accepts if both condition holds. In other words, the algorithms accepts iff. C encodes a left-dominating set of size k. Thus the algorithm indeed computes LeftDom. Moreover, the algorithm runs in polynomial time. Hence LeftDom ∈ NP. Then we show that LeftDom is NP-hard by reducing Set-Cover to it. Given a Set- Cover instance ⟨F, S, k⟩, where S is the ground set and F is a collection of subsets of S, we construct a Left-Dom instance g(⟨F, S, k⟩) = ⟨G = (L ∪ R, E), k′⟩ as follows: (i) Each vertex in L corresponds to a set F ∈ F, i.e. L = {vF | F ∈ F}. (ii) Each vertex in R corresponds to an element s ∈ S, i.e. R = {vS | s ∈ S}. (iii) E = {(vF , vS) | F ∈ F, s ∈ F }. (iv) k′ = k. It is easy to see that the above reduction runs in polynomial time. It remains to show ⟨F, S, k⟩ ∈ Set-Cover ⇐⇒ g(⟨F, S, k⟩) = ⟨G = (L ∪ R, E), k′ = k⟩ ∈ Left-Dom. =⇒ : If F ′ ⊆ F is a set cover for S of size k. Then every s ∈ S is contained in some F ∈ F ′, which implies (vF , vs) ∈ E. Thus {vF : F ∈ F ′} is a left-dominating set for G of size k. ⇐= : If D is a left-dominating set for G of size k. Then for every vs ∈ R, there exists some vF ∈ D such that (vF , vs) ∈ E, which implies that s ∈ F . Thus {F : vF ∈ D} is a set cover for S of size k. Page 6 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös Hence Left-Dom is NP-hard. In conclusion, Left-Dom is NP-complete. Remark: Set-Cover generalizes Vertex-Cover as the set of edges can be seen as the ground set, and each vertex can be seen as a set of incident edges. Hence one can reduce Vertex-Cover to LeftDom in the same way. It is also not complicated to reduce SAT to LeftDom, where the left side contains literals (variables and their negations) and the right sides contains disjunctions. If a literal is contained in a disjunction, we add an edge between their corresponding vertices. Moreover, we need to add all the disjunctions with the form x ∨ ¬x to make sure together with the constraint k = n, exactly one of x and ¬x is chosen. Grading Scheme: (1) Proving LeftDom is NP is worth 5 points and proving NP hardness is worth 15 points. (2) I deduct 1 point for answers that do not emphasize the certificate is a set of size k. (3) Many people forgot the definition of Vertex-Cover and were actually reducing Domi- nating Set to LeftDom, which is not allowed in this problem. In this case, I deduct 4 points if the reduction and the proof is correct. (4) However, some people are even not working on dominating set (they do not connect vL and vR). But it is still a reduction from an NP-complete problem to LeftDom. In this case, I deduct 8 points if the proof is correct. (5) If the reduction does not work, I will give [2,5] points out of 15. The score depends on the difficulty to fix the solution, the writing and the proof structure. 3 points is typical. Page 7 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 5 (20 pts) Undecidability. Recall the notation wR from 2b. Define T = {⟨M ⟩ : M is a TM such that for all w, M accepts w iff it accepts wR}. Show that both T and T are unrecognisable. Solution: Here is a reduction f : HALT → T where M ′ = f (⟨M, w⟩) is such that: On input ⟨x⟩: 1. Runs M on w. 2. If x = 01 then accept. f is a computable function. We show ⟨M, w⟩ ∈ HALT if and only if ⟨M ′⟩ ∈ T : • If ⟨M, w⟩ ∈ HALT then L(M ′) = ∅. Thus, ⟨M ′⟩ ∈ T . • If ⟨M, w⟩ /∈ HALT then L(M ′) = {01}. Thus, ⟨M ′⟩ /∈ T . To show HALT ≤m T it is sufficient to show HALT ≤m T . Here is a reduction g : HALT → T where M ′ = g(⟨M, w⟩) is such that: On input ⟨x⟩: 1. If x = 01 then accept. 2. Runs M on w. 3. If x = 10 then accept. g is a computable function. We show ⟨M, w⟩ ∈ HALT if and only if ⟨M ′⟩ ∈ T : • If ⟨M, w⟩ ∈ HALT then L(M ′) = {10, 01}. Thus, ⟨M ′⟩ ∈ T . • If ⟨M, w⟩ /∈ HALT then L(M ′) = {01}. Thus, ⟨M ′⟩ ∈ T . Grading scheme: • 10 points for T • 10 points for ¯T Within each: 5 points for each direction. Typical mistakes: • 0 - no answer, only sketch Page 8 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös • 5 - some argument, no correctness or utterly wrong • 10 - correctness argument but flawed, i.e. because didn’t realise modification needed • 15 - correctness arguments makes sense, i.e. realised some modification is needed • 20 - very good, modification realised and carried out correctly Page 9 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös 6 (15 pts) CNF Equivalence. We say that two CNF formulas φ and ψ, both defined over the same set of n variables x = (x1, . . . , xn), are equivalent if they compute the same boolean function, that is, φ(x) = ψ(x) for all x ∈ {0, 1}n. Consider the language CNF-Eq = {⟨φ, ψ⟩ : φ and ψ are a pair of equivalent CNFs}. Classify this problem into as small a complexity class as possible: is it in P, NP, coNP, or merely decidable? Is it complete for any complexity class? Justify your answer with a proof. (Note that, in general, for any class of languages C, we say a language A is C-complete iff A ∈ C and we have L ≤p A for all L ∈ C.) Solution: We show that the language CNF-Eq is coNP-complete. First of all, CNF-Eq ∈ coNP because CNF-Eq is the language of all pairs of functions (φ, ψ) that are not equivalent and non-equivalency can be certified by exhibiting an assignment x ∈n with φ(x) ̸= ψ(x). Verification takes polynomial time. We further show that the coNP-complete problem SAT reduces to CNF-Eq. Indeed, let f be the poly-time computable function that takes a formula φ and returns the CNF-Eq instance (φ, x1 ∧ ¬x1). Then, for any formula φ: φ ∈ SAT ⇐⇒ φ = 0 ⇐⇒ φ = x1 ∧ ¬x1 ⇐⇒ f (φ) ∈ CNF-Eq Finally, we know that NP and coNP are thought to be unequal and no coNP-complete problem can be in NP Thus, most likely CNF-Eq /∈ P and even CNF-Eq /∈ NP. Grading scheme for the problem 6. Solution as presented above consists of three parts, and they were graded as follows: • Stating that the problem is in coNP – 3 points, proving it – 3 points. • Claiming that the problem is coNP-complete – 3 points, proving it – 3 points. • The conclusion that coNP is indeed the smallest complexity class most probably, because of coNP ̸= NP – 3 points. It was also possible to receive partial points if they WERE NOT part of an argument for the points recieved from above. • Stating that the problem is decidable – 1 point, and giving the correct verifier – 1 point. • Reasonable attempts to show that the problem is not in P – 1 point and it’s not in NP – 1 point. • It is mentioned that SAT is useful for defining the complexity class – 1 point, and given explanations that it is useful because its is coNP-complete problem and we can find the reduction from it to CNF-Eq – 3 points. Finally, there were several common mistakes, approaches: • Trying to show the reduction from CNF-Eq to SAT and not the other way around. • Showing that the verifier of CNF-Eq is polytime. • Trying to show the reduction of SAT to CNF-Eq. • Just writing many facts and claims all together without any justification. Also, for small or big mistakes one or two points were subtracted. Page 10 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2022 Mika Göös","libVersion":"0.5.0","langs":""}