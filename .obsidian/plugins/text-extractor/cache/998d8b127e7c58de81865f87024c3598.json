{"path":"Lectures/Lecture4.pdf","text":"Lecture 4: Turing machines Mika GÃ¶Ã¶s School of Computer and Communication Sciences Lecture 4 Recall: Pumping Lemma (and how to prove that a language is not regular) Lecture 4 Pumping Lemma and its Proof Sketch If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i â‰¥ 0, xy i z âˆˆ A 2 |y | â‰¥ 1, and 3 |xy | â‰¤ p. â–¶ Let M = (Q, Î£, Î´, q0, F ) s.t. L(M) = A â–¶ Consider a string s âˆˆ A s.t. |s| â‰¥ |Q| = p â–¶ Stop once in a state for the 2nd time, say at times j, k â–¶ s = xyz where x is the ï¬rst j letters, y is letter j + 1 to k, z is from k + 1 to end x y z Lecture 4 F = {ww | w âˆˆ {0, 1} âˆ—} F is not regular! Proof: (by contradiction) â–¶ Assume F is regular, let p be its pumping length â–¶ Pick s = 0 p1 p0p1p âˆˆ F All strings donâ€™t work! Fun part is guessing which string to pick â–¶ Pumping lemma: s = xyz, |xy | â‰¤ p, |y | â‰¥ 1, xy i z âˆˆ F for all i â‰¥ 0 Pumping lemma tells us there is such a decomposition â€“ we canâ€™t choose it! Your reasoning should work for any decomposition â–¶ Since |xy | â‰¤ p and |y | â‰¥ 1, y = 0 k for some k > 0 â–¶ According to pumping lemma, xy 2z âˆˆ F â–¶ xy 2z = 0p+k 1 p0 p1 p < F â–¶ Contradiction! Lecture 4 Part I of course Lec 1: DFA and Regular Languages Lec 2: NFA and its equivalence to DFA Lec 3: Non-regular languages and the Pumping Lemma â–¶ {w âˆˆ {0, 1} âˆ— : w has the same number of 0â€™s and 1â€™s} cannot be recognized by DFAs â–¶ This seems like a problem with DFAs Whatâ€™s missing? Lecture 4 What is a computer? Program Output Memory InputProgramOutputMemoryInputï¬nite size (independent of input)amount depends on input Lecture 4 Abstractly Lecture 4 More abstractly Read Tape Write Tape Memory Tape Program Lecture 4 Single tape seems enough. . . Input # Memory # Output Program Lecture 4 The Turing Machine q0q1q2q3q4q5q3q0qaccept Head (with current state) 1 0 0 1 Inï¬nite Tape q0q0 q1q1 q2q2q3q3 q4q4 q5q5 qreject qacceptqaccept 1 â†’ âŠ”, R 0, 1 â†’ R âŠ” â†’ L 1 â†’ âŠ”, L 0 â†’ R 0, 1 â†’ L âŠ” â†’ R 0 â†’ âŠ”, R 0, 1 â†’ R âŠ” â†’ L 0 â†’ âŠ”, L 1 â†’ R âŠ” â†’ R Finite state control (the algorithm) This Turing machine accepts even length binary palindromes Lecture 4 Finite size program, larger and larger instances â‡’ Inï¬nite Tape! 290 15 Turing Machines Figure 1: Alan Turingâ€™s â€œlight bulb momentâ€ â€“ Prof. Geoâ†µ Draper drew this cartoon for my book never halt; it may keep zigzagging on the tape, writing symbols all over, and running amok, much like many tricky programs do in real life. A Turing machine cannot manufacture new symbols ad inï¬nitum - so all the symbols written by a Turing machine on its tape do belong to a ï¬nite tape alphabet, \u0000. Notice that âŒƒ â‡¢ \u0000, since \u0000 includes the blank symbol B that is not allowed within âŒƒ. We assume that a Turing machine begins its operation scanning cell number 0 of a doubly-inï¬nite tape (meaning that there are tape cells numbered +x or \u0000x for any x 2 Nat); more on this is in the following section. A fact to remember is this: in order to feed the string \" to a TM, one must present to the Turing machine a tape ï¬lled with blanks (B). However, some authors alter this convention slightly, allowing \" to be fed to a Turing machine by ensuring that, in the initial state, the symbol under the tape head is blank (B) (i.e., the rest of the tape could contain non-blank symbols). In any case, a normal Turing machine input is such that for every i 2 length(w), w[i] 6= B is presented on tape cell i, with all remaining tape cells containing B, and the head of the Turing machine faces w[1] at the beginning of a computation. A TM may be deterministic or nondeterministic. The signature of \u0000 for a deterministic Turing machine (DTM) is \u0000 : Q â‡¥ \u0000 ! Q â‡¥ \u0000 â‡¥ {L, R}. This signature captures the fact that a TM can be in a certain state q 2 Q and looking at a 2 \u0000. It can then write a 0 on the tape in lieu of a, move to a state q0, and move its head left (L), or right (R), depending on whether \u0000(q, a)= hq0,a 0,Li or \u0000(q, a)= hq0,a 0 ,Ri,respectively. For an NDTM, \u0000(q, a) returns a set of next control states, tape symbol replacements, and head move directions. The signature of \u0000 for a nondeterministic Turing machine (NDTM) is \u0000 : Q â‡¥ \u0000 ! 2 Qâ‡¥\u0000â‡¥{L,R}. Think of a nondeterministic Turing machine as a C program where instead of the standard if-then-else construct, we have an if/fi construct of the following form: 2 Lecture 4 Finite automata vs Turing machines 1 A Turing machine can both write on the tape and read from it 2 The read-write head can move both to the left and to the right 3 The tape is inï¬nite 4 The special states for rejecting and accepting take eï¬€ect immediately Lecture 4 Turing Machine 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conï¬guration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maË† chine computesâ€œ Say that conï¬guration C1 yields conï¬guration C2 if the Turing machine can legally go from C1 to C2 in a single stepâ€œ We deï¬ne this notion formally as followsâ€œ Suppose that we have aa baand c in Î“aas well as u and v in Î“âˆ— and states qi and qjâ€œIn that casea ua qi bv and uqj acv are two conï¬gurationsâ€œ Say that ua qi bv yields uqj acv if in the transition function Î´(qi,b)= (qj,c, L)â€œThat handles the case where the Turing machine moves leftwardâ€œ For a rightward movea say that ua qi bv yields uac qj v if Î´(qi,b)= (qj,c, R)â€œ Special cases occur when the head is at one of the ends of the conï¬gurationâ€œ For the leftË†hand enda the conï¬guration qi bv yields qj cv if the transition is leftË† moving Abecause we prevent the machine from going off the leftË†hand end of the tape]a and it yields cqjv for the rightË†moving transitionâ€œ For the rightË†hand enda the conï¬guration ua qi is equivalent to ua qi â£ because we assume that blanks follow the part of the tape represented in the conï¬gurationâ€œ Thus we can handle this case as beforea with the head no longer at the rightË†hand endâ€œ The start conï¬guration of M on input w is the conï¬guration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tapeâ€œ In an accepting conï¬gurationathe state of the conï¬guration is qacceptâ€œIn a rejecting conï¬gurationathe state of the conï¬guration is qrejectâ€œ Accepting and rejecting conï¬gurations are halting conï¬gurations and do not yield further conï¬gurationsâ€œ Because the machine is deï¬ned to halt when in the states qaccept and qrejectawe equivalently could have deï¬ned the transition function to have the more complicated form Î´ : Qâ€² Ã— Î“âˆ’â†’ Q Ã— Î“ Ã— {L, R}awhere Qâ€² is Q without qaccept and qrejectâ€œA Turing machine M accepts input w if a sequence of conï¬gurations C1a C2a ... a Ck existsa where 1. C1 is the start conï¬guration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conï¬gurationâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm â–¶ Inï¬nite tape â–¶ Tape alphabet contains input alphabet plus âŠ” (blank symbol) plus maybe more symbols â–¶ Head has states (corresponding to the ï¬nite control automata) â–¶ Exactly one Accept state and exactly one Reject state (where computation immediately ends) â–¶ Remaining states â€œcomputation in progressâ€ â–¶ May never reach an accept state. May never halt! q0 1 0 q0 q1 1 â†’ R 0 â†’ L Lecture 4 Formal Deï¬nition of a TM A Turing Machine is a 7-tuple (Q, Î£, Î“, Î´, q0, qaccept , qreject ), where Q, Î£, Î“ are all ï¬nite sets and 1 Q is the set of states, 2 Î£ is the input alphabet not containing the blank symbol âŠ”, 3 Î“ is the tape alphabet, where âŠ” âˆˆ Î“ and Î£ âŠ† Î“, 4 Î´ : Q Ã— Î“ â†’ Q Ã— Î“ Ã— {L, R} is the transition function, 5 q0 âˆˆ Q is the start state, 6 qaccept âˆˆ Q is the accept state, and 7 qreject âˆˆ Q is the reject state, where qaccept , qreject . Lecture 4 {w : w has an equal number of 0â€™s and 1â€™s} Easy (eï¬ƒcient) to write an algorithm to count number of 1s and 0â€™s â€” letâ€™s try to implement on a TM (In this Part II of the course, we do not care about running time. . . ) Our approach: check for each 0 (or 1) there is a corresponding 1 (or 0) â–¶ Scan the input from left to right â–¶ Whenever we encounter an uncrossed 0 or 1, we â€œremoveâ€ it and proceed right to ï¬nd a corresponding 1 or 0 that we cross â–¶ We keep doing this (2) until either we cross oï¬€ all the letters (accept) or we fail to ï¬nd a pair for one of the letters (reject) Lecture 4 {w : w has an equal number of 0â€™s and 1â€™s} Q = {q0, q1, q2, q3, qA, qR } Î£ = {0, 1} Î“ = {0, 1, âŠ”, X } â€“ X crossed oï¬€ letter q0 q1 q2 q3 qA qR X â†’ âŠ”, R 0 â†’ âŠ”, R 1 â†’ âŠ”, R âŠ” â†’ R X , 0 â†’ R âŠ” â†’ R 1 â†’ X , L âŠ” â†’ R 1, X â†’ R 0 â†’ X , L âŠ” â†’ R 0, 1, X â†’ L Execution of the TM on 0110 ð‘„ð‘„= ð‘žð‘ž0, ð‘žð‘ž1, ð‘žð‘ž2, ð‘žð‘ž3, ð‘žð‘žð´ð´, ð‘žð‘žð‘…ð‘… Î£= 0,1 Î“= {0,1,âŠ”, ð‘‹ð‘‹} -- ð‘‹ð‘‹crossed off letter (we also use âŠ”) ð‘¤ð‘¤ð‘¤ð‘¤has an equal number of 0â€™s and 1â€™s } Execution of the TM on 0110 Accept state Reject state Start state Lecture 4 Conï¬gurations of a TM As a Turing machine computes, changes occur in the current state, the current tape contents, and the current head location. A setting of these three items is called a conï¬guration of the Turing machine. Representation: We write uqv where u, v âˆˆ Î“âˆ— and q âˆˆ Q for the conï¬guration where â–¶ current state is q â–¶ current tape content is uv â–¶ the current head location is the ï¬rst symbol of v (Cells whose contents are unspeciï¬ed are blank. If u = Îµ then Head at leftmost cell.) Example: A TM with conï¬guration 1011q701111 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conï¬guration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maË† chine computesâ€œ Say that conï¬guration C1 yields conï¬guration C2 if the Turing machine can legally go from C1 to C2 in a single stepâ€œ We deï¬ne this notion formally as followsâ€œ Suppose that we have aa baand c in Î“aas well as u and v in Î“âˆ— and states qi and qjâ€œIn that casea ua qi bv and uqj acv are two conï¬gurationsâ€œ Say that ua qi bv yields uqj acv if in the transition function Î´(qi,b)= (qj,c, L)â€œThat handles the case where the Turing machine moves leftwardâ€œ For a rightward movea say that ua qi bv yields uac qj v if Î´(qi,b)= (qj,c, R)â€œ Special cases occur when the head is at one of the ends of the conï¬gurationâ€œ For the leftË†hand enda the conï¬guration qi bv yields qj cv if the transition is leftË† moving Abecause we prevent the machine from going off the leftË†hand end of the tape]a and it yields cqjv for the rightË†moving transitionâ€œ For the rightË†hand enda the conï¬guration ua qi is equivalent to ua qi â£ because we assume that blanks follow the part of the tape represented in the conï¬gurationâ€œ Thus we can handle this case as beforea with the head no longer at the rightË†hand endâ€œ The start conï¬guration of M on input w is the conï¬guration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tapeâ€œ In an accepting conï¬gurationathe state of the conï¬guration is qacceptâ€œIn a rejecting conï¬gurationathe state of the conï¬guration is qrejectâ€œ Accepting and rejecting conï¬gurations are halting conï¬gurations and do not yield further conï¬gurationsâ€œ Because the machine is deï¬ned to halt when in the states qaccept and qrejectawe equivalently could have deï¬ned the transition function to have the more complicated form Î´ : Qâ€² Ã— Î“âˆ’â†’ Q Ã— Î“ Ã— {L, R}awhere Qâ€² is Q without qaccept and qrejectâ€œA Turing machine M accepts input w if a sequence of conï¬gurations C1a C2a ... a Ck existsa where 1. C1 is the start conï¬guration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conï¬gurationâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm Lecture 4 Transitions: Given conï¬guration uaqi bv where a, b âˆˆ Î“, u, v âˆˆ Î“ âˆ— and state qi âˆˆ Q, we move to â–¶ uqj acv if Î´(qi , b) = (qj , c, L) â–¶ uacqj v if Î´(qi , b) = (qj , c, R) Computation: â–¶ Starting conï¬guration is C1 = q0w on input w âˆˆ Î£âˆ— â–¶ Obtain new conï¬gurations C2, C3, . . . by valid moves/transitions â–¶ Accept and halt if a conï¬guration with the state qaccept is reached â–¶ Reject and halt if a conï¬guration with the state qreject is reached What if the computation doesnâ€™t halt (i.e., loops)? Does it mean some conï¬guration is repeated? Lecture 4 Turing-Recognizable/Decidable Languages A TM machine M recognizes a language L âŠ† Î£âˆ— iï¬€ for all inputs w âˆˆ Î£âˆ—: 1 If w âˆˆ L then M accepts w and 2 If w < L then M doesnâ€™t halt (or it rejects w ) Such languages are called (Turing)-Recognizable A TM machine M decides a language L âŠ† Î£âˆ— iï¬€ for all inputs w âˆˆ Î£âˆ—: 1 M halts on w , and 2 M accepts w iï¬€ w âˆˆ L Such languages are called (Turing)-Decidable Lecture 4 {0 2n : n â‰¥ 0} TM that decides this language: On input string w 1 Remove ï¬rst 0 2 Sweep left to right across the tape, crossing oï¬€ every other 0 3 If in stage 1 the tape contained a single 0, accept 4 If in stage 1, the tape contained more than a single 0 and the number of 0s that we crossed out was odd, reject 5 Retun the head to the left-hand end of the tape 6 Go to stage 1 Each iteration of stage 1 cuts the number of 0s in half. Lecture 4 Q = {q1, q2, q3, q4, q5, qaccept , qreject } Î£ = {0} Î“ = {0, x , âŠ”} 172 CHAPTER 3 / THE CHURCH---TURING THESIS FIGURE 3.8 State diagram for Turing machine M2 In this state diagrama the label 0â†’â£,Rappears on the transition from q1 to q2â€œ This label signiï¬es that when in state q1 with the head reading 0athe machine goes to state q2awrites â£aand moves the head to the rightâ€œ In other wordsa Î´(q1,0)= (q2,â£,R)â€œFor clarity we use the shorthand 0â†’Rin the transition from q3 to q4ato mean that the machine moves to the right when reading 0 in state q3 but doesnâ€™t alter the tapea so Î´(q3,0)= (q4,0,R)â€œ This machine begins by writing a blank symbol over the leftmost 0 on the tape so that it can ï¬nd the leftË†hand end of the tape in stage Â¸â€œ Whereas we would normally use a more suggestive symbol such as # for the leftË†hand end delimitera we use a blank here to keep the tape alphabeta and hence the state diagrama smallâ€œ Example Â´â€œâ€”â€” gives another method of ï¬nding the leftË†hand end of the tapeâ€œ Next we give a sample run of this machine on input 0000â€œThe starting conË† ï¬guration is q10000â€œThe sequence of conï¬gurations the machine enters appears as follows; read down the columns and left to rightâ€œ q10000 â£q5x0xâ£ â£xq5xxâ£ â£q2000 q5â£x0xâ£ â£q5xxxâ£ â£xq300 â£q2x0xâ£ q5â£xxxâ£ â£x0q40 â£xq20xâ£ â£q2xxxâ£ â£x0xq3â£ â£xxq3xâ£ â£xq2xxâ£ â£x0q5xâ£ â£xxxq3â£ â£xxq2xâ£ â£xq50xâ£ â£xxq5xâ£ â£xxxq2â£ â£xxxâ£qaccept â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm Example on input 0000: 172 CHAPTER 3 / THE CHURCH---TURING THESIS FIGURE 3.8 State diagram for Turing machine M2 In this state diagrama the label 0â†’â£,Rappears on the transition from q1 to q2â€œ This label signiï¬es that when in state q1 with the head reading 0athe machine goes to state q2awrites â£aand moves the head to the rightâ€œ In other wordsa Î´(q1,0)= (q2,â£,R)â€œFor clarity we use the shorthand 0â†’Rin the transition from q3 to q4ato mean that the machine moves to the right when reading 0 in state q3 but doesnâ€™t alter the tapea so Î´(q3,0)= (q4,0,R)â€œ This machine begins by writing a blank symbol over the leftmost 0 on the tape so that it can ï¬nd the leftË†hand end of the tape in stage Â¸â€œ Whereas we would normally use a more suggestive symbol such as # for the leftË†hand end delimitera we use a blank here to keep the tape alphabeta and hence the state diagrama smallâ€œ Example Â´â€œâ€”â€” gives another method of ï¬nding the leftË†hand end of the tapeâ€œ Next we give a sample run of this machine on input 0000â€œThe starting conË† ï¬guration is q10000â€œThe sequence of conï¬gurations the machine enters appears as follows; read down the columns and left to rightâ€œ q10000 â£q5x0xâ£ â£xq5xxâ£ â£q2000 q5â£x0xâ£ â£q5xxxâ£ â£xq300 â£q2x0xâ£ q5â£xxxâ£ â£x0q40 â£xq20xâ£ â£q2xxxâ£ â£x0xq3â£ â£xxq3xâ£ â£xq2xxâ£ â£x0q5xâ£ â£xxxq3â£ â£xxq2xâ£ â£xq50xâ£ â£xxq5xâ£ â£xxxq2â£ â£xxxâ£qaccept â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm Lecture 4 Equivalence to Other Models and History Lecture 4 In 1900, David Hilbert raised 23 mathematical problems Lecture 4 Hilbertâ€™s tenth problem Given a Diophantine equation, devise a process according to which it can be determined in a ï¬nite number of operations whether the equation is soluble in integers. â–¶ A Diophantine equation is a polynomial equation with integer coeï¬ƒcients and ï¬nite number of unknowns. â–¶ E.g. 3x 2 âˆ’ 2xy âˆ’ y 2z âˆ’ 7 = 0 has solution x = 1, y = 2, z = âˆ’2 â–¶ E.g. x 2025 + y 2025 = z 2025 with x , y , z â‰¥ 1? No solution! (I have a marvelous proof, which this slide is too narrow to contain) Problem: in 1900 there was not a deï¬nition of what an algorithm is! Lecture 4 Deï¬nition of Algorithm â–¶ The deï¬nition came in 1936 papers of Alonzo Church and Alan Turing â–¶ Church used a notational system called Î»-calculus to deï¬ne algorithms â–¶ Turing did it with his â€œmachinesâ€ â–¶ The two deï¬nitions were shown to be equivalent Church-Turing thesis: 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefï¬cientâ€œFor examplea 6 Â· x Â· x Â· x Â· y Â· z Â· z =6x 3yz2 is a term with coefï¬cient 6a and 6x 3yz2 +3xy2 âˆ’ x 3 âˆ’ 10 is a polynomial with four termsa over the variables xa yaand zâ€œFor this discusË† siona we consider only coefï¬cients that are integersâ€œ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is â€“â€œ This polynomial has a root at x =5a y =3aand z =0â€œThis root is an integral root because all the variables are assigned integer valuesâ€œ Some polynomials have an integral root and some do notâ€œ Hilbertâ€™s tenth problem was to devise an algorithm that tests whether a polyË† nomial has an integral rootâ€œ He did not use the term algorithm but rather â€œa process according to which it can be determined by a ï¬nite number of operË† ationsâ€œâ€Â¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be â€œdevisedâ€œâ€ Thus he apparently assumed that such an algorithm must existâ€”someone need only ï¬nd itâ€œ As we now knowa no algorithm exists for this task; it is algorithmically unsolvË† ableâ€œ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossibleâ€œ The intuË† itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular taskâ€œ Proving that an algorithm does not exist requires having a clear deï¬nition of algorithmâ€œ Progress on the tenth problem had to wait for that deï¬nitionâ€œ The deï¬nition came in the â€”9Â´6 papers of Alonzo Church and Alan TurË† ingâ€œ Church used a notational system called the Î»Ë†calculus to deï¬ne algorithmsâ€œ Turing did it with his â€œmachinesâ€œâ€ These two deï¬nitions were shown to be equivalentâ€œ This connection between the informal notion of algorithm and the precise deï¬nition has come to be called the Churchâ€“Turing thesisâ€œ The Churchâ€“Turing thesis provides the deï¬nition of algorithm necessary to resolve Hilbertâ€™s tenth problemâ€œ In â€”97â€“a Yuri MatijaseviË˜ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral rootsâ€œ In Chapter Â¸ we deË† velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvableâ€œ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Churchâ€“Turing thesis Â¸Translated from the original Germanâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm The precise deï¬nition of algorithms allowed Yuri Matijasevic in 1970, building on the work of Martin Davis, Hilary Putnam, and Julia Robinson, to resolve Hilbertâ€™s tenth problem. No such algorithm can exist! Lecture 4 Church-Turing Thesis 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefï¬cientâ€œFor examplea 6 Â· x Â· x Â· x Â· y Â· z Â· z =6x 3yz2 is a term with coefï¬cient 6a and 6x 3yz2 +3xy2 âˆ’ x 3 âˆ’ 10 is a polynomial with four termsa over the variables xa yaand zâ€œFor this discusË† siona we consider only coefï¬cients that are integersâ€œ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is â€“â€œ This polynomial has a root at x =5a y =3aand z =0â€œThis root is an integral root because all the variables are assigned integer valuesâ€œ Some polynomials have an integral root and some do notâ€œ Hilbertâ€™s tenth problem was to devise an algorithm that tests whether a polyË† nomial has an integral rootâ€œ He did not use the term algorithm but rather â€œa process according to which it can be determined by a ï¬nite number of operË† ationsâ€œâ€Â¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be â€œdevisedâ€œâ€ Thus he apparently assumed that such an algorithm must existâ€”someone need only ï¬nd itâ€œ As we now knowa no algorithm exists for this task; it is algorithmically unsolvË† ableâ€œ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossibleâ€œ The intuË† itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular taskâ€œ Proving that an algorithm does not exist requires having a clear deï¬nition of algorithmâ€œ Progress on the tenth problem had to wait for that deï¬nitionâ€œ The deï¬nition came in the â€”9Â´6 papers of Alonzo Church and Alan TurË† ingâ€œ Church used a notational system called the Î»Ë†calculus to deï¬ne algorithmsâ€œ Turing did it with his â€œmachinesâ€œâ€ These two deï¬nitions were shown to be equivalentâ€œ This connection between the informal notion of algorithm and the precise deï¬nition has come to be called the Churchâ€“Turing thesisâ€œ The Churchâ€“Turing thesis provides the deï¬nition of algorithm necessary to resolve Hilbertâ€™s tenth problemâ€œ In â€”97â€“a Yuri MatijaseviË˜ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral rootsâ€œ In Chapter Â¸ we deË† velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvableâ€œ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Churchâ€“Turing thesis Â¸Translated from the original Germanâ€œ â„Ã‰ÃŠÃ–ÃˆÃÂ³Â©Ã_qopq_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³m_Â¢Ã€Ã€_Â·ÃÂ³Â©ÃÃŽ_Â·Ã°ÃŽÃ°ÃˆÃ‘Ã°âˆ’m_ï¬Â¾Ã–_ÃƒÃ‰Ã_Â²Ã°_Â®Ã‰ÃŠÃÃ°âˆ’k_ÃŽÂ®Â¾ÃƒÃƒÃ°âˆ’k_Ã‰Ãˆ_âˆ’ÃŒÃŠÃ€ÃÂ®Â¾ÃÃ°âˆ’k_ÃÃƒ_Ã“Â©Ã‰Ã€Ã°_Ã‰Ãˆ_ÃÃƒ_ÃŠÂ¾ÃˆÃm_Â¥ÃŒÃ°_ÃÃ‰_Ã°Ã€Ã°Â®ÃÃˆÃ‰ÃƒÃÂ®_ÃˆÃÂ³Â©ÃÃŽk_ÃŽÃ‰Ã…Ã°_ÃÂ©ÃÃˆâˆ’_ÃŠÂ¾ÃˆÃÃ–_Â®Ã‰ÃƒÃÃ°ÃƒÃ_Ã…Â¾Ã–_Â²Ã°_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Ã—ÃˆÃ‰Ã…_ÃÂ©Ã°_ Ã°Â£Ã‰Ã‰Ã„_Â¾Ãƒâˆ’nÃ‰Ãˆ_Ã°â„Â©Â¾ÃŠÃÃ°ÃˆgÃŽhm_Æ’âˆ’ÃÃÃ‰ÃˆÃÂ¾Ã€_ÃˆÃ°Ã‘ÃÃ°Ã“_Â©Â¾ÃŽ_âˆ’Ã°Ã°Ã…Ã°âˆ’_ÃÂ©Â¾Ã_Â¾ÃƒÃ–_ÃŽÃŒÃŠÃŠÃˆÃ°ÃŽÃŽÃ°âˆ’_Â®Ã‰ÃƒÃÃ°ÃƒÃ_âˆ’Ã‰Ã°ÃŽ_ÃƒÃ‰Ã_Ã…Â¾ÃÃ°ÃˆÃÂ¾Ã€Ã€Ã–_Â¾Ã—Ã—Ã°Â®Ã_ÃÂ©Ã°_Ã‰Ã‘Ã°ÃˆÂ¾Ã€Ã€_Ã€Ã°Â¾ÃˆÃƒÃÃƒÂ³_Ã°Ã”ÃŠÃ°ÃˆÃÃ°ÃƒÂ®Ã°m_â„Ã°ÃƒÂ³Â¾Â³Ã°_â€ºÃ°Â¾ÃˆÃƒÃÃƒÂ³_ÃˆÃ°ÃŽÃ°ÃˆÃ‘Ã°ÃŽ_ÃÂ©Ã°_ÃˆÃÂ³Â©Ã_ÃÃ‰_ÃˆÃ°Ã…Ã‰Ã‘Ã°_Â¾âˆ’âˆ’ÃÃÃÃ‰ÃƒÂ¾Ã€_ Â®Ã‰ÃƒÃÃ°ÃƒÃ_Â¾Ã_Â¾ÃƒÃ–_ÃÃÃ…Ã°_ÃÃ—_ÃŽÃŒÂ²ÃŽÃ°Ã‹ÃŒÃ°ÃƒÃ_ÃˆÃÂ³Â©ÃÃŽ_ÃˆÃ°ÃŽÃÃˆÃÂ®ÃÃÃ‰ÃƒÃŽ_ÃˆÃ°Ã‹ÃŒÃÃˆÃ°_ÃÃm â–¶ All algorithms we know of can be executed on TMs â–¶ Anything you write in C, Java, Scala, Python and so on â–¶ Anything you would possibly do with a Quantum Computer â–¶ The deï¬nition is also robust to variations: if we allow for many tapes instead of one, then nothing changes â–¶ Any computational process in nature â–¶ And so on Lecture 4 Next week: Undecidability Lecture 4","libVersion":"0.5.0","langs":""}