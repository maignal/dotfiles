{"path":"Lectures/Lecture4.pdf","text":"Lecture 4: Turing machines Mika Göös School of Computer and Communication Sciences Lecture 4 Recall: Pumping Lemma (and how to prove that a language is not regular) Lecture 4 Pumping Lemma and its Proof Sketch If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i ≥ 0, xy i z ∈ A 2 |y | ≥ 1, and 3 |xy | ≤ p. ▶ Let M = (Q, Σ, δ, q0, F ) s.t. L(M) = A ▶ Consider a string s ∈ A s.t. |s| ≥ |Q| = p ▶ Stop once in a state for the 2nd time, say at times j, k ▶ s = xyz where x is the ﬁrst j letters, y is letter j + 1 to k, z is from k + 1 to end x y z Lecture 4 F = {ww | w ∈ {0, 1} ∗} F is not regular! Proof: (by contradiction) ▶ Assume F is regular, let p be its pumping length ▶ Pick s = 0 p1 p0p1p ∈ F All strings don’t work! Fun part is guessing which string to pick ▶ Pumping lemma: s = xyz, |xy | ≤ p, |y | ≥ 1, xy i z ∈ F for all i ≥ 0 Pumping lemma tells us there is such a decomposition – we can’t choose it! Your reasoning should work for any decomposition ▶ Since |xy | ≤ p and |y | ≥ 1, y = 0 k for some k > 0 ▶ According to pumping lemma, xy 2z ∈ F ▶ xy 2z = 0p+k 1 p0 p1 p < F ▶ Contradiction! Lecture 4 Part I of course Lec 1: DFA and Regular Languages Lec 2: NFA and its equivalence to DFA Lec 3: Non-regular languages and the Pumping Lemma ▶ {w ∈ {0, 1} ∗ : w has the same number of 0’s and 1’s} cannot be recognized by DFAs ▶ This seems like a problem with DFAs What’s missing? Lecture 4 What is a computer? Program Output Memory InputProgramOutputMemoryInputﬁnite size (independent of input)amount depends on input Lecture 4 Abstractly Lecture 4 More abstractly Read Tape Write Tape Memory Tape Program Lecture 4 Single tape seems enough. . . Input # Memory # Output Program Lecture 4 The Turing Machine q0q1q2q3q4q5q3q0qaccept Head (with current state) 1 0 0 1 Inﬁnite Tape q0q0 q1q1 q2q2q3q3 q4q4 q5q5 qreject qacceptqaccept 1 → ⊔, R 0, 1 → R ⊔ → L 1 → ⊔, L 0 → R 0, 1 → L ⊔ → R 0 → ⊔, R 0, 1 → R ⊔ → L 0 → ⊔, L 1 → R ⊔ → R Finite state control (the algorithm) This Turing machine accepts even length binary palindromes Lecture 4 Finite size program, larger and larger instances ⇒ Inﬁnite Tape! 290 15 Turing Machines Figure 1: Alan Turing’s “light bulb moment” – Prof. Geo↵ Draper drew this cartoon for my book never halt; it may keep zigzagging on the tape, writing symbols all over, and running amok, much like many tricky programs do in real life. A Turing machine cannot manufacture new symbols ad inﬁnitum - so all the symbols written by a Turing machine on its tape do belong to a ﬁnite tape alphabet, \u0000. Notice that ⌃ ⇢ \u0000, since \u0000 includes the blank symbol B that is not allowed within ⌃. We assume that a Turing machine begins its operation scanning cell number 0 of a doubly-inﬁnite tape (meaning that there are tape cells numbered +x or \u0000x for any x 2 Nat); more on this is in the following section. A fact to remember is this: in order to feed the string \" to a TM, one must present to the Turing machine a tape ﬁlled with blanks (B). However, some authors alter this convention slightly, allowing \" to be fed to a Turing machine by ensuring that, in the initial state, the symbol under the tape head is blank (B) (i.e., the rest of the tape could contain non-blank symbols). In any case, a normal Turing machine input is such that for every i 2 length(w), w[i] 6= B is presented on tape cell i, with all remaining tape cells containing B, and the head of the Turing machine faces w[1] at the beginning of a computation. A TM may be deterministic or nondeterministic. The signature of \u0000 for a deterministic Turing machine (DTM) is \u0000 : Q ⇥ \u0000 ! Q ⇥ \u0000 ⇥ {L, R}. This signature captures the fact that a TM can be in a certain state q 2 Q and looking at a 2 \u0000. It can then write a 0 on the tape in lieu of a, move to a state q0, and move its head left (L), or right (R), depending on whether \u0000(q, a)= hq0,a 0,Li or \u0000(q, a)= hq0,a 0 ,Ri,respectively. For an NDTM, \u0000(q, a) returns a set of next control states, tape symbol replacements, and head move directions. The signature of \u0000 for a nondeterministic Turing machine (NDTM) is \u0000 : Q ⇥ \u0000 ! 2 Q⇥\u0000⇥{L,R}. Think of a nondeterministic Turing machine as a C program where instead of the standard if-then-else construct, we have an if/fi construct of the following form: 2 Lecture 4 Finite automata vs Turing machines 1 A Turing machine can both write on the tape and read from it 2 The read-write head can move both to the left and to the right 3 The tape is inﬁnite 4 The special states for rejecting and accepting take eﬀect immediately Lecture 4 Turing Machine 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conﬁguration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maˆ chine computes“ Say that conﬁguration C1 yields conﬁguration C2 if the Turing machine can legally go from C1 to C2 in a single step“ We deﬁne this notion formally as follows“ Suppose that we have aa baand c in Γaas well as u and v in Γ∗ and states qi and qj“In that casea ua qi bv and uqj acv are two conﬁgurations“ Say that ua qi bv yields uqj acv if in the transition function δ(qi,b)= (qj,c, L)“That handles the case where the Turing machine moves leftward“ For a rightward movea say that ua qi bv yields uac qj v if δ(qi,b)= (qj,c, R)“ Special cases occur when the head is at one of the ends of the conﬁguration“ For the leftˆhand enda the conﬁguration qi bv yields qj cv if the transition is leftˆ moving Abecause we prevent the machine from going off the leftˆhand end of the tape]a and it yields cqjv for the rightˆmoving transition“ For the rightˆhand enda the conﬁguration ua qi is equivalent to ua qi ␣ because we assume that blanks follow the part of the tape represented in the conﬁguration“ Thus we can handle this case as beforea with the head no longer at the rightˆhand end“ The start conﬁguration of M on input w is the conﬁguration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tape“ In an accepting conﬁgurationathe state of the conﬁguration is qaccept“In a rejecting conﬁgurationathe state of the conﬁguration is qreject“ Accepting and rejecting conﬁgurations are halting conﬁgurations and do not yield further conﬁgurations“ Because the machine is deﬁned to halt when in the states qaccept and qrejectawe equivalently could have deﬁned the transition function to have the more complicated form δ : Q′ × Γ−→ Q × Γ × {L, R}awhere Q′ is Q without qaccept and qreject“A Turing machine M accepts input w if a sequence of conﬁgurations C1a C2a ... a Ck existsa where 1. C1 is the start conﬁguration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conﬁguration“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ Inﬁnite tape ▶ Tape alphabet contains input alphabet plus ⊔ (blank symbol) plus maybe more symbols ▶ Head has states (corresponding to the ﬁnite control automata) ▶ Exactly one Accept state and exactly one Reject state (where computation immediately ends) ▶ Remaining states “computation in progress” ▶ May never reach an accept state. May never halt! q0 1 0 q0 q1 1 → R 0 → L Lecture 4 Formal Deﬁnition of a TM A Turing Machine is a 7-tuple (Q, Σ, Γ, δ, q0, qaccept , qreject ), where Q, Σ, Γ are all ﬁnite sets and 1 Q is the set of states, 2 Σ is the input alphabet not containing the blank symbol ⊔, 3 Γ is the tape alphabet, where ⊔ ∈ Γ and Σ ⊆ Γ, 4 δ : Q × Γ → Q × Γ × {L, R} is the transition function, 5 q0 ∈ Q is the start state, 6 qaccept ∈ Q is the accept state, and 7 qreject ∈ Q is the reject state, where qaccept , qreject . Lecture 4 {w : w has an equal number of 0’s and 1’s} Easy (eﬃcient) to write an algorithm to count number of 1s and 0’s — let’s try to implement on a TM (In this Part II of the course, we do not care about running time. . . ) Our approach: check for each 0 (or 1) there is a corresponding 1 (or 0) ▶ Scan the input from left to right ▶ Whenever we encounter an uncrossed 0 or 1, we “remove” it and proceed right to ﬁnd a corresponding 1 or 0 that we cross ▶ We keep doing this (2) until either we cross oﬀ all the letters (accept) or we fail to ﬁnd a pair for one of the letters (reject) Lecture 4 {w : w has an equal number of 0’s and 1’s} Q = {q0, q1, q2, q3, qA, qR } Σ = {0, 1} Γ = {0, 1, ⊔, X } – X crossed oﬀ letter q0 q1 q2 q3 qA qR X → ⊔, R 0 → ⊔, R 1 → ⊔, R ⊔ → R X , 0 → R ⊔ → R 1 → X , L ⊔ → R 1, X → R 0 → X , L ⊔ → R 0, 1, X → L Execution of the TM on 0110 𝑄𝑄= 𝑞𝑞0, 𝑞𝑞1, 𝑞𝑞2, 𝑞𝑞3, 𝑞𝑞𝐴𝐴, 𝑞𝑞𝑅𝑅 Σ= 0,1 Γ= {0,1,⊔, 𝑋𝑋} -- 𝑋𝑋crossed off letter (we also use ⊔) 𝑤𝑤𝑤𝑤has an equal number of 0’s and 1’s } Execution of the TM on 0110 Accept state Reject state Start state Lecture 4 Conﬁgurations of a TM As a Turing machine computes, changes occur in the current state, the current tape contents, and the current head location. A setting of these three items is called a conﬁguration of the Turing machine. Representation: We write uqv where u, v ∈ Γ∗ and q ∈ Q for the conﬁguration where ▶ current state is q ▶ current tape content is uv ▶ the current head location is the ﬁrst symbol of v (Cells whose contents are unspeciﬁed are blank. If u = ε then Head at leftmost cell.) Example: A TM with conﬁguration 1011q701111 3.1 TURING MACHINES 169 FIGURE 3.4 ATuring machine with conﬁguration 1011q701111 Here we formalize our intuitive understanding of the way that a Turing maˆ chine computes“ Say that conﬁguration C1 yields conﬁguration C2 if the Turing machine can legally go from C1 to C2 in a single step“ We deﬁne this notion formally as follows“ Suppose that we have aa baand c in Γaas well as u and v in Γ∗ and states qi and qj“In that casea ua qi bv and uqj acv are two conﬁgurations“ Say that ua qi bv yields uqj acv if in the transition function δ(qi,b)= (qj,c, L)“That handles the case where the Turing machine moves leftward“ For a rightward movea say that ua qi bv yields uac qj v if δ(qi,b)= (qj,c, R)“ Special cases occur when the head is at one of the ends of the conﬁguration“ For the leftˆhand enda the conﬁguration qi bv yields qj cv if the transition is leftˆ moving Abecause we prevent the machine from going off the leftˆhand end of the tape]a and it yields cqjv for the rightˆmoving transition“ For the rightˆhand enda the conﬁguration ua qi is equivalent to ua qi ␣ because we assume that blanks follow the part of the tape represented in the conﬁguration“ Thus we can handle this case as beforea with the head no longer at the rightˆhand end“ The start conﬁguration of M on input w is the conﬁguration q0 wawhich indicates that the machine is in the start state q0 with its head at the leftmost position on the tape“ In an accepting conﬁgurationathe state of the conﬁguration is qaccept“In a rejecting conﬁgurationathe state of the conﬁguration is qreject“ Accepting and rejecting conﬁgurations are halting conﬁgurations and do not yield further conﬁgurations“ Because the machine is deﬁned to halt when in the states qaccept and qrejectawe equivalently could have deﬁned the transition function to have the more complicated form δ : Q′ × Γ−→ Q × Γ × {L, R}awhere Q′ is Q without qaccept and qreject“A Turing machine M accepts input w if a sequence of conﬁgurations C1a C2a ... a Ck existsa where 1. C1 is the start conﬁguration of M on input wa 2. each Ci yields Ci+1aand 3. Ck is an accepting conﬁguration“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Lecture 4 Transitions: Given conﬁguration uaqi bv where a, b ∈ Γ, u, v ∈ Γ ∗ and state qi ∈ Q, we move to ▶ uqj acv if δ(qi , b) = (qj , c, L) ▶ uacqj v if δ(qi , b) = (qj , c, R) Computation: ▶ Starting conﬁguration is C1 = q0w on input w ∈ Σ∗ ▶ Obtain new conﬁgurations C2, C3, . . . by valid moves/transitions ▶ Accept and halt if a conﬁguration with the state qaccept is reached ▶ Reject and halt if a conﬁguration with the state qreject is reached What if the computation doesn’t halt (i.e., loops)? Does it mean some conﬁguration is repeated? Lecture 4 Turing-Recognizable/Decidable Languages A TM machine M recognizes a language L ⊆ Σ∗ iﬀ for all inputs w ∈ Σ∗: 1 If w ∈ L then M accepts w and 2 If w < L then M doesn’t halt (or it rejects w ) Such languages are called (Turing)-Recognizable A TM machine M decides a language L ⊆ Σ∗ iﬀ for all inputs w ∈ Σ∗: 1 M halts on w , and 2 M accepts w iﬀ w ∈ L Such languages are called (Turing)-Decidable Lecture 4 {0 2n : n ≥ 0} TM that decides this language: On input string w 1 Remove ﬁrst 0 2 Sweep left to right across the tape, crossing oﬀ every other 0 3 If in stage 1 the tape contained a single 0, accept 4 If in stage 1, the tape contained more than a single 0 and the number of 0s that we crossed out was odd, reject 5 Retun the head to the left-hand end of the tape 6 Go to stage 1 Each iteration of stage 1 cuts the number of 0s in half. Lecture 4 Q = {q1, q2, q3, q4, q5, qaccept , qreject } Σ = {0} Γ = {0, x , ⊔} 172 CHAPTER 3 / THE CHURCH---TURING THESIS FIGURE 3.8 State diagram for Turing machine M2 In this state diagrama the label 0→␣,Rappears on the transition from q1 to q2“ This label signiﬁes that when in state q1 with the head reading 0athe machine goes to state q2awrites ␣aand moves the head to the right“ In other wordsa δ(q1,0)= (q2,␣,R)“For clarity we use the shorthand 0→Rin the transition from q3 to q4ato mean that the machine moves to the right when reading 0 in state q3 but doesn’t alter the tapea so δ(q3,0)= (q4,0,R)“ This machine begins by writing a blank symbol over the leftmost 0 on the tape so that it can ﬁnd the leftˆhand end of the tape in stage ¸“ Whereas we would normally use a more suggestive symbol such as # for the leftˆhand end delimitera we use a blank here to keep the tape alphabeta and hence the state diagrama small“ Example ´“—— gives another method of ﬁnding the leftˆhand end of the tape“ Next we give a sample run of this machine on input 0000“The starting conˆ ﬁguration is q10000“The sequence of conﬁgurations the machine enters appears as follows; read down the columns and left to right“ q10000 ␣q5x0x␣ ␣xq5xx␣ ␣q2000 q5␣x0x␣ ␣q5xxx␣ ␣xq300 ␣q2x0x␣ q5␣xxx␣ ␣x0q40 ␣xq20x␣ ␣q2xxx␣ ␣x0xq3␣ ␣xxq3x␣ ␣xq2xx␣ ␣x0q5x␣ ␣xxxq3␣ ␣xxq2x␣ ␣xq50x␣ ␣xxq5x␣ ␣xxxq2␣ ␣xxx␣qaccept ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Example on input 0000: 172 CHAPTER 3 / THE CHURCH---TURING THESIS FIGURE 3.8 State diagram for Turing machine M2 In this state diagrama the label 0→␣,Rappears on the transition from q1 to q2“ This label signiﬁes that when in state q1 with the head reading 0athe machine goes to state q2awrites ␣aand moves the head to the right“ In other wordsa δ(q1,0)= (q2,␣,R)“For clarity we use the shorthand 0→Rin the transition from q3 to q4ato mean that the machine moves to the right when reading 0 in state q3 but doesn’t alter the tapea so δ(q3,0)= (q4,0,R)“ This machine begins by writing a blank symbol over the leftmost 0 on the tape so that it can ﬁnd the leftˆhand end of the tape in stage ¸“ Whereas we would normally use a more suggestive symbol such as # for the leftˆhand end delimitera we use a blank here to keep the tape alphabeta and hence the state diagrama small“ Example ´“—— gives another method of ﬁnding the leftˆhand end of the tape“ Next we give a sample run of this machine on input 0000“The starting conˆ ﬁguration is q10000“The sequence of conﬁgurations the machine enters appears as follows; read down the columns and left to right“ q10000 ␣q5x0x␣ ␣xq5xx␣ ␣q2000 q5␣x0x␣ ␣q5xxx␣ ␣xq300 ␣q2x0x␣ q5␣xxx␣ ␣x0q40 ␣xq20x␣ ␣q2xxx␣ ␣x0xq3␣ ␣xxq3x␣ ␣xq2xx␣ ␣x0q5x␣ ␣xxxq3␣ ␣xxq2x␣ ␣xq50x␣ ␣xxq5x␣ ␣xxxq2␣ ␣xxx␣qaccept ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Lecture 4 Equivalence to Other Models and History Lecture 4 In 1900, David Hilbert raised 23 mathematical problems Lecture 4 Hilbert’s tenth problem Given a Diophantine equation, devise a process according to which it can be determined in a ﬁnite number of operations whether the equation is soluble in integers. ▶ A Diophantine equation is a polynomial equation with integer coeﬃcients and ﬁnite number of unknowns. ▶ E.g. 3x 2 − 2xy − y 2z − 7 = 0 has solution x = 1, y = 2, z = −2 ▶ E.g. x 2025 + y 2025 = z 2025 with x , y , z ≥ 1? No solution! (I have a marvelous proof, which this slide is too narrow to contain) Problem: in 1900 there was not a deﬁnition of what an algorithm is! Lecture 4 Deﬁnition of Algorithm ▶ The deﬁnition came in 1936 papers of Alonzo Church and Alan Turing ▶ Church used a notational system called λ-calculus to deﬁne algorithms ▶ Turing did it with his “machines” ▶ The two deﬁnitions were shown to be equivalent Church-Turing thesis: 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefﬁcient“For examplea 6 · x · x · x · y · z · z =6x 3yz2 is a term with coefﬁcient 6a and 6x 3yz2 +3xy2 − x 3 − 10 is a polynomial with four termsa over the variables xa yaand z“For this discusˆ siona we consider only coefﬁcients that are integers“ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is –“ This polynomial has a root at x =5a y =3aand z =0“This root is an integral root because all the variables are assigned integer values“ Some polynomials have an integral root and some do not“ Hilbert’s tenth problem was to devise an algorithm that tests whether a polyˆ nomial has an integral root“ He did not use the term algorithm but rather “a process according to which it can be determined by a ﬁnite number of operˆ ations“”¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be “devised“” Thus he apparently assumed that such an algorithm must exist—someone need only ﬁnd it“ As we now knowa no algorithm exists for this task; it is algorithmically unsolvˆ able“ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossible“ The intuˆ itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular task“ Proving that an algorithm does not exist requires having a clear deﬁnition of algorithm“ Progress on the tenth problem had to wait for that deﬁnition“ The deﬁnition came in the —9´6 papers of Alonzo Church and Alan Turˆ ing“ Church used a notational system called the λˆcalculus to deﬁne algorithms“ Turing did it with his “machines“” These two deﬁnitions were shown to be equivalent“ This connection between the informal notion of algorithm and the precise deﬁnition has come to be called the Church–Turing thesis“ The Church–Turing thesis provides the deﬁnition of algorithm necessary to resolve Hilbert’s tenth problem“ In —97–a Yuri Matijasevi˘ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral roots“ In Chapter ¸ we deˆ velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvable“ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Church–Turing thesis ¸Translated from the original German“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm The precise deﬁnition of algorithms allowed Yuri Matijasevic in 1970, building on the work of Martin Davis, Hilary Putnam, and Julia Robinson, to resolve Hilbert’s tenth problem. No such algorithm can exist! Lecture 4 Church-Turing Thesis 3.3 THE DEFINITION OF ALGORITHM 183 constanta called a coefﬁcient“For examplea 6 · x · x · x · y · z · z =6x 3yz2 is a term with coefﬁcient 6a and 6x 3yz2 +3xy2 − x 3 − 10 is a polynomial with four termsa over the variables xa yaand z“For this discusˆ siona we consider only coefﬁcients that are integers“ A root of a polynomial is an assignment of values to its variables so that the value of the polynomial is –“ This polynomial has a root at x =5a y =3aand z =0“This root is an integral root because all the variables are assigned integer values“ Some polynomials have an integral root and some do not“ Hilbert’s tenth problem was to devise an algorithm that tests whether a polyˆ nomial has an integral root“ He did not use the term algorithm but rather “a process according to which it can be determined by a ﬁnite number of operˆ ations“”¸ Interestinglya in the way he phrased this problema Hilbert explicitly asked that an algorithm be “devised“” Thus he apparently assumed that such an algorithm must exist—someone need only ﬁnd it“ As we now knowa no algorithm exists for this task; it is algorithmically unsolvˆ able“ For mathematicians of that period to come to this conclusion with their intuitive concept of algorithm would have been virtually impossible“ The intuˆ itive concept may have been adequate for giving algorithms for certain tasksa but it was useless for showing that no algorithm exists for a particular task“ Proving that an algorithm does not exist requires having a clear deﬁnition of algorithm“ Progress on the tenth problem had to wait for that deﬁnition“ The deﬁnition came in the —9´6 papers of Alonzo Church and Alan Turˆ ing“ Church used a notational system called the λˆcalculus to deﬁne algorithms“ Turing did it with his “machines“” These two deﬁnitions were shown to be equivalent“ This connection between the informal notion of algorithm and the precise deﬁnition has come to be called the Church–Turing thesis“ The Church–Turing thesis provides the deﬁnition of algorithm necessary to resolve Hilbert’s tenth problem“ In —97–a Yuri Matijasevi˘ca building on the work of Martin Davisa Hilary Putnama and Julia Robinsona showed that no algorithm exists for testing whether a polynomial has integral roots“ In Chapter ¸ we deˆ velop the techniques that form the basis for proving that this and other problems are algorithmically unsolvable“ Intuitive notion Turing machine of algorithms equals algorithms FIGURE 3.22 The Church–Turing thesis ¸Translated from the original German“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ All algorithms we know of can be executed on TMs ▶ Anything you write in C, Java, Scala, Python and so on ▶ Anything you would possibly do with a Quantum Computer ▶ The deﬁnition is also robust to variations: if we allow for many tapes instead of one, then nothing changes ▶ Any computational process in nature ▶ And so on Lecture 4 Next week: Undecidability Lecture 4","libVersion":"0.5.0","langs":""}