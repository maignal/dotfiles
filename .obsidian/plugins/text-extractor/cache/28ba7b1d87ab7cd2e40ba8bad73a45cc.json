{"path":"The Essential/Summaries/Theory of Computation _ Résumé.pdf","text":"of 1 17 Nicolas Ettlin • v1.1 Introduction 4 Historique des versions\t 4 Finite Automata 5 Finite Automata and Regular Languages\t 5 Deterministic Finite Automaton (DFA)\t 5 Regular Languages and Operations\t 6 Nondeterministic ﬁnite automaton\t 7 Non-Regular Languages\t 8 Pumping Lemma\t 8 Computability 8 Turing Machines\t 8 Deﬁnition\t 8 Conﬁgurations\t 8 Computation\t 8 Equivalence to Other Models\t 9 Decidability and Undecidability\t 9 Deﬁnitions\t 9 Using Turing Machines as Input\t 9 Examples\t 10 Unrecognizable Languages\t 11 Reductions\t 11 Complexity 12 Deﬁnitions\t 12 Running Time of a Turing Machine\t 12 Time Complexity Class\t 12 P vs. NP\t 12 Class P\t 12 Class NP\t 12 Non-deterministic Turing Machines\t 13 Polynomial-Time Reductions\t 13 NP-completeness\t 13 NP-Complete Problems\t 14 SAT\t 14 3SAT\t 14 INDSET\t 14 of 2 17 CLIQUE\t 15 Vertex Cover\t 15 Set Cover\t 15 Perfect 3 Matching\t 16 Subset Sum\t 16 Circuit Complexity\t 17 Circuit for a Turing Machine\t 17 Cook-Levin Theorem\t 17 of 3 17 Introduction Ce document est un résumé mis au propre des notes que j’ai prises pendant le semestre. Attention, ce document : ne remplace pas les cours : il est écrit en partant du principe que tu vois déjà de quoi on parle, sans prendre le temps de bien introduire les sujets et présenter des exemples ; remplace encore moins les séries d’exercices et les révisions : t’entraîner sera essentiel pour bien comprendre les notions et te préparer à l’examen ; contient peut-être des erreurs ou imprécisions, malgré mes eﬀorts de relecture  (mais si tu en trouves, n’hésite pas à me les transmettre pour que je puisse les corriger !). Par contre, ce document peut être : une autre manière de voir les nouvelles notions, si tu bloques avec la formulation du cours ; une aide pendant les révisions, pour vériﬁer que tu es à jour sur tous les sujets ; un moyen rapide pour retrouver une formule du cours pendant les exercices.  (Mais n’oublie pas d’apprendre par cœur celles dont tu auras besoin pour l’examen !) En espérant que ces notes puissent t’être utiles, je te souhaite un bon courage et beaucoup de succès pour le BA4 ! Historique des versions Avant de commencer à lire le document, je te conseille de vériﬁer sur le drive que tu en as la version la plus récente, qui contiendra les derniers correctifs et ajouts. Si tu as des questions ou suggestions, n’hésite pas à me parler sur Discord : Nicolapps#3110.  Version Date Modiﬁcations v1.0 26 février 2023 Version initiale v1.1 18 mai 2023 Correction d’une erreur dans la partie sur 3SAT. of 4 17 Finite Automata Finite Automata and Regular Languages DETERMINISTIC FINITE AUTOMATON (DFA) A deterministic ﬁnite automaton (DFA) is a 5-tuple , where: • (ﬁnite set) are the states • (ﬁnite set) is the alphabet • is the transition function  Notation: = after all of the string . • is the start state • is the set of accept states LANGUAGE The language of the machine is: CORRECTNESS PROOFS To prove that is indeed the language of : • For each state , ﬁnd a precise description of the set   The language should be the union of the corresponding to accepting states. • Prove by induction: if (for every ) • Base case: on the empty string • Induction step: assume if (for every ), and for every : • identify in which would be • Verify that it is indeed the case  (Q, Σ, δ, q0, F ) Q Σ δ : Q × Σ → Q (q, σ) ↦ δ(q, σ) δ(q, s) s q0 ∈ Q F ⊂ Q L M L(M ) = {strings accepted by M} L M qi Ti = {string s | δ(q0, s) = qi} L Ti ∀w, δ(q0, w) = qi w ∈ Ti i ε δ(q0, x) x ∈ Ti i σ Ti x . σ of 5 17 Example 3 To understand what strings a DFA accepts, try a couple of strings to understand the roles of the states! 34 CHAPTER 1 / REGULAR LANGUAGES In beginning to describe the mathematical theory of ﬁnite automataa we do so in the abstracta without reference to any particular application“ The following ﬁgure depicts a ﬁnite automaton called M1“ FIGURE 1.4 Aﬁnite automaton called M1 that has three states Figure —“¸ is called the state diagram of M1“It has three statesalabeled q1a q2a and q3“The start statea q1ais indicated by the arrow pointing at it from nowhere“ The accept statea q2ais the one with a double circle“ The arrows going from one state to another are called transitions“ When this automaton receives an input string such as 1101ait processes that string and produces an output“ The output is either accept or reject“We will consider only this yes”no type of output for now to keep things simple“ The processing begins in M1’s start state“ The automaton receives the symbols from the input string one by one from left to right“ After reading each symbola M1 moves from one state to another along the transition that has that symbol as its label“ When it reads the last symbola M1 produces its output“ The output is accept if M1 is now in an accept state and reject if it is not“ For examplea when we feed the input string 1101 into the machine M1 in Figure —“¸a the processing proceeds as follows: 1. Start in state q1“ 2. Read 1afollow transition from q1 to q2“ 3. Read 1afollow transition from q2 to q2“ 4. Read 0afollow transition from q2 to q3“ 5. Read 1afollow transition from q3 to q2“ 6. Accept because M1 is in an accept state q2 at the end of the input“ Experimenting with this machine on a variety of input strings reveals that it accepts the strings 1a 01a 11aand 0101010101“In facta M1 accepts any string that ends with a 1aas it goes to its accept state q2 whenever it reads the symbol 1“In additiona it accepts strings 100a 0100a 110000aand 0101000000aand any string that ends with an even number of 0sfollowing the last 1“It rejects other stringsa such as 0a 10a 101000“ Can you describe the language consisting of all strings that M1 accepts? We will do so shortly“ What strings does the DFA accept? Strings with at least one 1 that ends with an even number of 0’s Lecture 1, 21.02.2022 REGULAR LANGUAGES AND OPERATIONS DEFINITION A language is regular there is a DFA that accepts that language. COMPLEMENT Construction: UNION Construction: and . INTERSECTION Construction: and . CONCATENATION ⇔ ¯L = {w ∈ Σ* : w is not in L} F′ = Q\\F L1 ∪ L2 = {w ∈ Σ* : w ∈ L1 or w ∈ L2} Q′ = Q1 × Q2 δ((q1, q2), a) = (δ1(q1, a), δ2(q2, a)) q0 = (q1, q2) F = {(q1, q2) : q1 ∈ F1 or q2 ∈ F2} L1 ∩ L2 = {w ∈ Σ* : w ∈ L1 and w ∈ L2} Q′ = Q1 × Q2 δ((q1, q2), a) = (δ1(q1, a), δ2(q2, a)) q0 = (q1, q2) F = {(q1, q2) : q1 ∈ F1 and q2 ∈ F2} L1 ∘ L2 = {w ∈ Σ* : w = w1 . w2, w1 ∈ L1 and w2 ∈ L2} of 6 17 NONDETERMINISTIC FINITE AUTOMATON IDEA We want to allow, for a given state and symbol: • transitions to more than one state • no transitions • transitions without reading input symbols ( -transitions). FORMAL DEFINITION A nondeterministic ﬁnite automaton (NFA) is a 5-tuple , where: • (ﬁnite set) are the states • (ﬁnite set) is the alphabet • is the transition function • is the start state • is the set of accept states An input is accepted if there exists at least one path that ends at an accepting state. EQUIVALENCE TO DFA Every NFA has a DFA that accepts the same language. It can be created using as the set of states, and using . CONCATENATION A NFA for the concatenation of two preexisting NFAs can be created by adding -transitions from the ﬁrst MFA’s accepting states to the second NFA’s start state. Its transition function is formally deﬁned as: ε (Q, Σ, δ, q0, F ) Q Σ δ : Q × (Σ ∪ {ε}) → 𝒫(Q) (q, σ) ↦ δ(q, σ) q0 ∈ Q F ⊂ Q 𝒫(Q) ˜δ(qset, a) = ⋃ q∈qset δ(q, a) ε δ(q, a) = δ1(q, a) if q ∈ F1 and q ∉ F1 inside Q1 δ1(q, a) if q ∈ F1 and a ≠ ε inside Q1 δ1(q, a) if q ∈F 1 and a = ε ε-transit. δ2(q, a) if q ∈ Q2 inside Q2 of 7 17 Example 1 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic ﬁnite automaton N1 The difference between a deterministic ﬁnite automatona abbreviated DFAa and a nondeterministic ﬁnite automatona abbreviated NFAais immediately apˆ parent“ Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet“ The NFA shown in Figure —“¨7 violates that rule“ State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1“In an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbol“ Seconda in a DFAalabels on the transition arrows are symbols from the alphaˆ bet“ This NFA has an arrow with the label \u0000“In generala an NFA may have arrows labeled with members of the alphabet or \u0000“Zeroa onea or many arrows may exit from each state with the label \u0000“ How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed“ For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1“After reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallel“ Each copy of the machine takes one of the possible ways to proceed and continues as before“ If there are subsequent choicesa the machine splits again“ If the next input symbol doesn’t appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with it“ Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input string“ If a state with an \u0000 symbol on an exiting arrow is encountereda something similar happens“ Without reading any inputa the machine splits into multiple copiesa one following each of the exiting \u0000ˆlabeled arrows and one staying at the current state“ Then the machine proceeds nondeterministically as before“ Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent “processes” or “threads” can be running concurrently“ When the NFA splits to follow several choicesa that corresponds to a process “forking” into several childrena each proceeding separately“ If at least one of these processes acceptsa then the entire computation accepts“ Another way to think of a nondeterministic computation is as a tree of possiˆ bilities“ The root of the tree corresponds to the start of the computation“ Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choices“ The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure —“¨8“ What language does the NFA recognize? L = {w œ {0, 1} ú | w contains 11 or 101 as a substring} Lecture 2, 28.02.2022 Concatenation 1.2 NONDETERMINISM 61 FIGURE 1.48 Construction of N to recognize A1 \u0000 A2 PROOF Let N1 =(Q1, \u0000, \u00001,q1,F1) recognize A1aand N2 =(Q2, \u0000, \u00002,q2,F2) recognize A2“ Construct N =(Q, \u0000, \u0000,q1,F2) to recognize A1 \u0000 A2“ 1. Q = Q1 \u0000 Q2“ The states of N are all the states of N1 and N2“ 2. The state q1 is the same as the start state of N1“ 3. The accept states F2 are the same as the accept states of N2“ 4. Deﬁne \u0000 so that for any q \u0000 Q and any a \u0000 \u0000\u0000a \u0000(q, a)= \u0000 \u0000\u0000\u0000\u0000 \u0000\u0000\u0000\u0000 \u00001(q, a) q \u0000 Q1 and q \u0000\u0000 F1 \u00001(q, a) q \u0000 F1 and a \u0000= \u0000 \u00001(q, a) \u0000 {q2} q \u0000 F1 and a = \u0000 \u00002(q, a) q \u0000 Q2. Lecture 2, 28.02.2022 Non-Regular Languages PUMPING LEMMA ✨ Used to show that a language is not regular. If is a regular language, there exists a number (the pumping length) such that: ① for all \t A “loop” can be repeated ② \t It is nonempty ③ \t It is fully followed before Computability Turing Machines DEFINITION A Turing macine is a 7-tuple , where: • (ﬁnite set) is the set of states. • (ﬁnite set) is the input alphabet ( ). • (ﬁnite set) is the tape alphabet, with (blank symbol), and . • is the transition function.  From a state and tape symbol, gives the new state and symbol to write + the move to do • is the start state. • is the accept state and is the reject state ( ). CONFIGURATIONS The full state of a Turing machine is given by its conﬁguration , where: • are the tape contents (the current head location is the ﬁrst symbol of ) • is the current state COMPUTATION We start with the conﬁguration where is the input. If the current conﬁguration is (with , and ), we move to: We repeat until or is reached.  L p x yiz ∈ L i ≥ 0 | y | ≥ 1 | x y | ≤ p p (Q, Σ, Γ, δ, q0, qaccept, qreject) Q Σ ⊔ ∉ Σ Γ ⊔ ∈ Γ Σ ⊆ Γ δ : Q × Γ → Q × Γ × {L, R} q0 ∈ Q qaccept ∈ Q qreject qaccept ≠ qreject u q v uv v q C1 = q0w w ∈ Σ* u a qi bv u, v ∈ Γ* u, v ∈ Γ qi ∈ Q { uabqj v if δ(qi, b) = (qj, c, L) uqj abv if δ(qi, b) = (qj, c, R) qaccept qreject of 8 17 with , where∀s ∈ A | s | ≥ p s = x yz {w : w has an equal number of 0’s and 1’s} Q = {q0, q1, q2, q3, qA, qR } \u0000 = {0, 1} \u0000 = {0, 1, Û, X } – X crossed o\u0000 letter q0 q1 q2 q3 qA qR X æÛ, R 0 æÛ, R 1 æÛ, R Ûæ R X , 0 æ R Ûæ R 1 æ X , L Ûæ R 1, X æ R 0 æ X , L Ûæ R 0, 1, X æ L Execution of the TM on 0110 Lecture 4, 21.03.2022 EQUIVALENCE TO OTHER MODELS CHURCH-TURING THESIS Intuitive notion of algorithms (= every algorithm we can execute, even on a quantum computer)  = Turing machine algorithms Decidability and Undecidability DEFINITIONS TURING-RECOGNIZABILITY A Turing machine recognizes a language iﬀ for all inputs , • accepts • rejects or doesn’t halt. This language is then Turing-recognizable. TURING-DECIDABILITY A Turing machine decides a language iﬀ for all inputs , • accepts • rejects . This language is then Turing-decidable. It halts on every input. USING TURING MACHINES AS INPUT Anything can be encoded as a binary string  → we can use Turing Machines or ﬁnite automata as the input for a Turing machine! 📝 Notation: = binary encoding of .  L ⊆ Σ* w ∈ Σ* w ∈ L ⇒ M w w ∉ L ⇒ M w L ⊆ Σ* w ∈ Σ* w ∈ L ⇒ M w w ∉ L ⇒ M w ⟨D⟩ D of 9 17 EXAMPLES CHECKING WHETHER A DFA IS EMPTY (RECOGNIZES NOTHING) ✅ is decidable. Idea: browse all the DFA nodes and mark the reachable states. Accept iﬀ there is an accepting state that is marked. CHECKING WHETHER TWO DFA RECOGNIZE THE SAME LANGUAGE ✅ is decidable. Idea: since and are regular, is regular as well  (since can be constructed from and ) and there is a DFA for it.  → Identify whether this DFA is empty (→ same language) or not (→ diﬀerent language). LANGUAGE OF MACHINES THAT DON’T ACCEPT THEMSELVES ❌ is undecidable. Idea: let be the machine that decides . • If accepts , then (doesn’t match the deﬁnition). • If rejects , then and shouldn’t have rejected ! CHECKING WHETHER A TURING MACHINE HALTS ON AN INPUT ❌ is undecidable. Idea: we could build a decider for from it. CHECKING WHETHER A TURING MACHINE ACCEPTS AN INPUT ❌ is undecidable. Idea: we could build a decider for from it. CHECKING WHETHER A TURING MACHINE ACCEPTS A REGULAR LANGUAGE ❌ is undecidable. Idea: by reduction to . Run the hypothetical decider on a machine that accepts if doesn’t accept , and if accepts .  𝖤DFA = {⟨D⟩ : L(D) = ∅} 𝖤𝖰DFA = {⟨D, D′ ⟩ : L(D) = L(D′ )} L(D) L(D′ ) L(D) ⊕ L(D′ ) ⊕ ∪ ∩ 𝖣𝖨𝖠𝖦 = {⟨M⟩ : M doesn’t accept ⟨M⟩} M𝖣 𝖣𝖨𝖠𝖦 M𝖣 ⟨M𝖣⟩ L(M𝖣) ≠ 𝖣𝖨𝖠𝖦 M𝖣 ⟨M𝖣⟩ M𝖣 ∈ 𝖣𝖨𝖠𝖦 M𝖣 ⟨M𝖣⟩ 𝖧𝖠𝖫𝖳 = {⟨M, w⟩ : M halts on input w} 𝖣𝖨𝖠𝖦 𝖠TM = {⟨M, w⟩ : M accepts w} 𝖣𝖨𝖠𝖦 𝖱𝖤𝖦TM = {⟨M⟩ : L(M ) is regular} 𝖠TM {0n1n : n ∈ ℕ} M w {0,1}* M w of 10 17 UNRECOGNIZABLE LANGUAGES THEOREM Decidable recognizable and complement recognizable. Proof: run both recognizers and one will stop. Example: , are not recognizable. CHECKING WHETHER TWO TURING MACHINES HAVE THE SAME LANGUAGE ❌ is unrecognizable. Idea: by reduction to . Compare the machine “run on ” to the machine “reject everything”. REDUCTIONS ✨ Use the knowledge of another language to determine easily properties of a language. COMPUTABLE FUNCTION A function is a computable function if there exists some Turing machine that for every input halts with just on its tape. MAPPING REDUCIBLE : The language is mapping reducible to language iﬀ computable with for every THEOREMS Let and be languages such that . • decidable decidable.\t ( undecidable undecidable.) • recognizable recognizable.\t ( unrecognizable unrecognizable.) ⇔ 𝖧𝖠𝖫𝖳 𝖠TM 𝖤𝖰TM = {⟨M1, M2⟩ : L(M1) = L(M2)} 𝖠TM M w f : Σ * → Σ * w f (w) A ≤m B A B ∃ f w ∈ A ⇔ f (w) ∈ B w ∈ Σ* A B A ≤m B B ⇒ A A ⇒ B B ⇒ A A ⇒ B of 11 17 Complexity Deﬁnitions RUNNING TIME OF A TURING MACHINE Let be a decider (TM that halts on every input). Its running time (time complexity) is: TIME COMPLEXITY CLASS For instance, regular languages . P vs. NP CLASS P Languages that are decidable in polynomial time (on a deterministic Turing machine). We can show that a problem is in by giving a polynomial-time algorithm in any language. CLASS NP VERIFIERS A veriﬁer for the language is a Turing machine such that : • (certiﬁcate/witness) such that accepts • , rejects CLASS NP Veriﬁer in polynomial time = its running time on any input is polynomial in . PROBLEMS IN NP • SAT: existence of a satisfying assignment to a CNF formula  (Cook-Levin theorem: )  kSAT: SAT with a limite of literals in each clause • GI: existence of a graph isomorphism (bijection that preserves adjacency). • INDSET: in a graph, existence of a subset of a given size in which all vertices are mutually independent.  M t(n) = max w∈Σn [steps of M on w] TIME(t(n)) = {languages decided by a TM in O(t(n))} ⊆ TIME(n) P = ⋃ ∞ k=1 TIME(nk) P L M ∀x ∈ Σ* x ∈ L ⇒ ∃C M ⟨x, C ⟩ x ∉ L ⇒ ∀C M ⟨x, C ⟩ NP = {languages with veriﬁers in polynomial time} ⟨x, C ⟩ | x | 𝖲𝖠𝖳 ∈ P ⇔ P = NP k of 12 17 NON-DETERMINISTIC TURING MACHINES A non-deterministic Turing machine (NTM) can return several possible transitions. DECIDERS A non-deterministic decider for a language is a NTM which halts on every input , and: • If , some computation accepts. • If , every computation rejects. POLYNOMIAL-TIME NTM A polynomial-time NTM has the running time of its longest computation polynomial in . NON-DETERMINISTIC POLYNOMIAL-TIME DECIDER POLYNOMIAL-TIME VERIFIER Since a certiﬁcate can be computed deterministically, this theorem holds. NAMING ON THE NP CLASS NP stands for non-deterministic polynomial-time.\t POLYNOMIAL-TIME REDUCTIONS POLY-TIME COMPUTABLE FUNCTION A function is a poly-time computable function if there exists some  polynomial-time Turing machine that for every input halts with just on its tape. POLY-TIME MAPPING REDUCIBLE : is poly-time mapping reducible to with a polynomial-time computable function THEOREMS Let , and be languages such that . • in in .\t ( not in not in .) • .\t (Transitivity) NP-COMPLETENESS A language is -complete if and , . To show that a language is -complete, we have to prove: • -membership: show that (give a polynomial-time veriﬁer). • -hardness: show that   (or any other NP-complete language such as INDSET or 3SAT). δ : (Q, Γ) → 𝒫(Q, Γ, {L, R}) L x x ∈ L x ∉ L | x | ⇔ NP = ⋃∞ k=1 NTIME(nk) f : Σ * → Σ * w f (w) A ≤P B A B A B C A ≤P B B P ⇒ A P A P ⇒ B P B ≤P C ⇒ A ≤P C L NP L ∈ NP ∀N ∈ NP N ≤P L L NP NP L ∈ NP NP 𝖲𝖠𝖳 ≤P L of 13 17 NP-Complete Problems SAT PROBLEM Does this CNF formula have any satisfying assignment? (For instance: ) NP-COMPLETENESS By the Cook-Levin theorem. 3SAT PROBLEM = where each clause has at most three literals NP-COMPLETENESS reduces to : . ✨ However, might not reduce to , which is decidable in polynomial time. INDSET PROBLEM Independent set = subset where no vertices are adjacent. NP-COMPLETENESS reduces to : • Create a vertex for each clause’s part • Link all vertices relative to the same variable but negated (= conﬂicting vertices)  → Avoids conﬂict in the result. • Link all vertices within a clause  → Avoids using multiple parts of the same clause to reach the goal • Size of the independent set: number of clauses  φ1 = (¯x ∨ ¯y ∨ z) ∧ (y ∨ ¯z ∨ a ∨ b) ∧ … 𝖲𝖠𝖳 𝖲𝖠𝖳 𝟥𝖲𝖠𝖳 (a ∨ b ∨ c ∨ d ) ↦ (a ∨ b ∨ φ) ∧ ( ¯φ ∨ c ∨ d ) 𝖲𝖠𝖳 𝟤𝖲𝖠𝖳 𝖨𝖭𝖣𝖲𝖤𝖳 = {⟨G, k⟩ : G has an ind. set of size k} 𝖲𝖠𝖳 𝖨𝖭𝖣𝖲𝖤𝖳 of 14 17 → Requires one variable in each clause to be true. CLIQUE PROBLEM Clique = subset where all the vertices are pairwise connected. NP-COMPLETENESS reduces to (invert all edges). VERTEX COVER PROBLEM Vertex cover = subset such that every edge is incident to one vertex of the subset. NP-COMPLETENESS reduces to : search a vertex cover of size , where is the number of vertices. SET COVER PROBLEM Let be a set and be a family of subsets of . NP-COMPLETENESS reduces to : • set = edges, • family = edges adjacent to one node, • number of subsets allowed = size .  𝖢𝖫𝖨𝖰𝖴𝖤 = {⟨G, k⟩ : G has a clique of size k} 𝖨𝖭𝖣𝖲𝖤𝖳 𝖢𝖫𝖨𝖰𝖴𝖤 𝖵𝖾𝗋𝗍𝖾𝗑𝖢𝗈𝗏𝖾𝗋 = {⟨G, k⟩ : G has a vertex cover of size k} 𝖨𝖭𝖣𝖲𝖤𝖳 𝖵𝖾𝗋𝗍𝖾𝗑𝖢𝗈𝗏𝖾𝗋 n − k n U ℱ = {T1, …, TM} ⊂ 𝒫(U ) U 𝖲𝖾𝗍𝖢𝗈𝗏𝖾𝗋 = {⟨U, ℱ, k⟩ : ℱ has a vertex cover of size k} = {⟨U, ℱ, k⟩ : ∃i1, …, in such that ⋃k j=1 Tij = U} 𝖵𝖾𝗋𝗍𝖾𝗑𝖢𝗈𝗏𝖾𝗋 𝖲𝖾𝗍𝖢𝗈𝗏𝖾𝗋 k of 15 17 PERFECT 3 MATCHING PROBLEM Let (where ). NP-COMPLETENESS reduces to : • For each variable, create a “gadget” (pairs of nodes in / which are connected in a cycle) • Extend each link to connect to an usage of this variable  (connect the direct usages to one half of the cycles, and the negated usages to the other half) • Create some “dummy” nodes in and connect them to the remaining cycle nodes. SUBSET SUM PROBLEM NP-MEMBERSHIP In when the input numbers are given in binary (not unary!). NP-COMPLETENESS reduces to : encode each edge as a vector whose columns contain “1” when the column corresponds to one of the connected nodes, and “0” otherwise. The vector is in base to avoid any issues with sum overﬂows.   E ⊂ U × V × W | U | = | V | = | W | = n 𝖯𝖾𝗋𝖿𝖾𝖼𝗍𝟥𝖬𝖺𝗍𝖼𝗁𝗂𝗇𝗀 = {⟨E⟩ : ∃m ⊂ E where each v ∈ U ∪ V ∪ W appears once} 𝖲𝖠𝖳 𝖯𝖾𝗋𝖿𝖾𝖼𝗍𝟥𝖬𝖺𝗍𝖼𝗁𝗂𝗇𝗀 U V W 𝖲𝗎𝖻𝗌𝖾𝗍𝖲𝗎𝗆 = {⟨X ⊂ ℕ, s⟩ : X has a subset whose elements sum to s} NP 𝖯𝖾𝗋𝖿𝖾𝖼𝗍𝟥𝖬𝖺𝗍𝖼𝗁𝗂𝗇𝗀 𝖲𝗎𝖻𝗌𝖾𝗍𝖲𝗎𝗆 b ≥ | E | of 16 17 Circuit Complexity CIRCUIT FOR A TURING MACHINE Given a Turing machine , for an input length and a runtime ,  we can comput in a circuit of size such that . COOK-LEVIN THEOREM WITNESSEXISTENCE WitnessExistence: general problem (existence of a certiﬁcate) We can reduce WitnessExistence to CircuitSAT (transform into a circuit and force assign ). CIRCUITSAT = Satisﬁability of a given circuit We can reduce CircuitSAT to SAT (remove all intermediary variables). M n t (n) poly(t (n)) Cn O(t (n)2) Cn(x) = m(x) ∀x ∈ {0,1} n 𝖶𝖤 = {⟨V, x, 1 t ⏟ unary ⟩ : ∃y (certiﬁcate) such that V accepts y in time t} V x 𝖢𝗂𝗋𝖼𝗎𝗂𝗍𝖲𝖠𝖳 = {⟨Cn⟩ : ∃x ∈ {0,1}n, Cn(x) = 1} of 17 17","libVersion":"0.5.0","langs":""}