{"path":"The Essential/Summaries/Theory of Computation _ RÃ©sumÃ©.pdf","text":"of 1 17 Nicolas Ettlin â€¢ v1.1 Introduction 4 Historique des versions\t 4 Finite Automata 5 Finite Automata and Regular Languages\t 5 Deterministic Finite Automaton (DFA)\t 5 Regular Languages and Operations\t 6 Nondeterministic ï¬nite automaton\t 7 Non-Regular Languages\t 8 Pumping Lemma\t 8 Computability 8 Turing Machines\t 8 Deï¬nition\t 8 Conï¬gurations\t 8 Computation\t 8 Equivalence to Other Models\t 9 Decidability and Undecidability\t 9 Deï¬nitions\t 9 Using Turing Machines as Input\t 9 Examples\t 10 Unrecognizable Languages\t 11 Reductions\t 11 Complexity 12 Deï¬nitions\t 12 Running Time of a Turing Machine\t 12 Time Complexity Class\t 12 P vs. NP\t 12 Class P\t 12 Class NP\t 12 Non-deterministic Turing Machines\t 13 Polynomial-Time Reductions\t 13 NP-completeness\t 13 NP-Complete Problems\t 14 SAT\t 14 3SAT\t 14 INDSET\t 14 of 2 17 CLIQUE\t 15 Vertex Cover\t 15 Set Cover\t 15 Perfect 3 Matching\t 16 Subset Sum\t 16 Circuit Complexity\t 17 Circuit for a Turing Machine\t 17 Cook-Levin Theorem\t 17 of 3 17 Introduction Ce document est un rÃ©sumÃ© mis au propre des notes que jâ€™ai prises pendant le semestre. Attention, ce document : ne remplace pas les cours : il est Ã©crit en partant du principe que tu vois dÃ©jÃ  de quoi on parle, sans prendre le temps de bien introduire les sujets et prÃ©senter des exemples ; remplace encore moins les sÃ©ries dâ€™exercices et les rÃ©visions : tâ€™entraÃ®ner sera essentiel pour bien comprendre les notions et te prÃ©parer Ã  lâ€™examen ; contient peut-Ãªtre des erreurs ou imprÃ©cisions, malgrÃ© mes eï¬€orts de relectureâ€¨ (mais si tu en trouves, nâ€™hÃ©site pas Ã  me les transmettre pour que je puisse les corriger !). Par contre, ce document peut Ãªtre : une autre maniÃ¨re de voir les nouvelles notions, si tu bloques avec la formulation du cours ; une aide pendant les rÃ©visions, pour vÃ©riï¬er que tu es Ã  jour sur tous les sujets ; un moyen rapide pour retrouver une formule du cours pendant les exercices.â€¨ (Mais nâ€™oublie pas dâ€™apprendre par cÅ“ur celles dont tu auras besoin pour lâ€™examen !) En espÃ©rant que ces notes puissent tâ€™Ãªtre utiles, je te souhaite un bon courage et beaucoup de succÃ¨s pour le BA4 ! Historique des versions Avant de commencer Ã  lire le document, je te conseille de vÃ©riï¬er sur le drive que tu en as la version la plus rÃ©cente, qui contiendra les derniers correctifs et ajouts. Si tu as des questions ou suggestions, nâ€™hÃ©site pas Ã  me parler sur Discord : Nicolapps#3110.â€© Version Date Modiï¬cations v1.0 26 fÃ©vrier 2023 Version initiale v1.1 18 mai 2023 Correction dâ€™une erreur dans la partie sur 3SAT. of 4 17 Finite Automata Finite Automata and Regular Languages DETERMINISTIC FINITE AUTOMATON (DFA) A deterministic ï¬nite automaton (DFA) is a 5-tuple , where: â€¢ (ï¬nite set) are the states â€¢ (ï¬nite set) is the alphabet â€¢ is the transition functionâ€¨ Notation: = after all of the string . â€¢ is the start state â€¢ is the set of accept states LANGUAGE The language of the machine is: CORRECTNESS PROOFS To prove that is indeed the language of : â€¢ For each state , ï¬nd a precise description of the set â€¨ The language should be the union of the corresponding to accepting states. â€¢ Prove by induction: if (for every ) â€¢ Base case: on the empty string â€¢ Induction step: assume if (for every ), and for every : â€¢ identify in which would be â€¢ Verify that it is indeed the caseâ€© (Q, Î£, Î´, q0, F ) Q Î£ Î´ : Q Ã— Î£ â†’ Q (q, Ïƒ) â†¦ Î´(q, Ïƒ) Î´(q, s) s q0 âˆˆ Q F âŠ‚ Q L M L(M ) = {stringsÂ acceptedÂ byÂ M} L M qi Ti = {stringÂ s | Î´(q0, s) = qi} L Ti âˆ€w, Î´(q0, w) = qi w âˆˆ Ti i Îµ Î´(q0, x) x âˆˆ Ti i Ïƒ Ti x . Ïƒ of 5 17 Example 3 To understand what strings a DFA accepts, try a couple of strings to understand the roles of the states! 34 CHAPTER 1 / REGULAR LANGUAGES In beginning to describe the mathematical theory of ï¬nite automataa we do so in the abstracta without reference to any particular applicationâ€œ The following ï¬gure depicts a ï¬nite automaton called M1â€œ FIGURE 1.4 Aï¬nite automaton called M1 that has three states Figure â€”â€œÂ¸ is called the state diagram of M1â€œIt has three statesalabeled q1a q2a and q3â€œThe start statea q1ais indicated by the arrow pointing at it from nowhereâ€œ The accept statea q2ais the one with a double circleâ€œ The arrows going from one state to another are called transitionsâ€œ When this automaton receives an input string such as 1101ait processes that string and produces an outputâ€œ The output is either accept or rejectâ€œWe will consider only this yesâ€no type of output for now to keep things simpleâ€œ The processing begins in M1â€™s start stateâ€œ The automaton receives the symbols from the input string one by one from left to rightâ€œ After reading each symbola M1 moves from one state to another along the transition that has that symbol as its labelâ€œ When it reads the last symbola M1 produces its outputâ€œ The output is accept if M1 is now in an accept state and reject if it is notâ€œ For examplea when we feed the input string 1101 into the machine M1 in Figure â€”â€œÂ¸a the processing proceeds as follows: 1. Start in state q1â€œ 2. Read 1afollow transition from q1 to q2â€œ 3. Read 1afollow transition from q2 to q2â€œ 4. Read 0afollow transition from q2 to q3â€œ 5. Read 1afollow transition from q3 to q2â€œ 6. Accept because M1 is in an accept state q2 at the end of the inputâ€œ Experimenting with this machine on a variety of input strings reveals that it accepts the strings 1a 01a 11aand 0101010101â€œIn facta M1 accepts any string that ends with a 1aas it goes to its accept state q2 whenever it reads the symbol 1â€œIn additiona it accepts strings 100a 0100a 110000aand 0101000000aand any string that ends with an even number of 0sfollowing the last 1â€œIt rejects other stringsa such as 0a 10a 101000â€œ Can you describe the language consisting of all strings that M1 accepts? We will do so shortlyâ€œ What strings does the DFA accept? Strings with at least one 1 that ends with an even number of 0â€™s Lecture 1, 21.02.2022 REGULAR LANGUAGES AND OPERATIONS DEFINITION A language is regular there is a DFA that accepts that language. COMPLEMENT Construction: UNION Construction: and . INTERSECTION Construction: and . CONCATENATION â‡” Â¯L = {w âˆˆ Î£* : wÂ isÂ notÂ inÂ L} Fâ€² = Q\\F L1 âˆª L2 = {w âˆˆ Î£* : w âˆˆ L1Â orÂ w âˆˆ L2} Qâ€² = Q1 Ã— Q2 Î´((q1, q2), a) = (Î´1(q1, a), Î´2(q2, a)) q0 = (q1, q2) F = {(q1, q2) : q1 âˆˆ F1Â orÂ q2 âˆˆ F2} L1 âˆ© L2 = {w âˆˆ Î£* : w âˆˆ L1Â andÂ w âˆˆ L2} Qâ€² = Q1 Ã— Q2 Î´((q1, q2), a) = (Î´1(q1, a), Î´2(q2, a)) q0 = (q1, q2) F = {(q1, q2) : q1 âˆˆ F1Â andÂ q2 âˆˆ F2} L1 âˆ˜ L2 = {w âˆˆ Î£* : w = w1 . w2, w1 âˆˆ L1Â andÂ w2 âˆˆ L2} of 6 17 NONDETERMINISTIC FINITE AUTOMATON IDEA We want to allow, for a given state and symbol: â€¢ transitions to more than one state â€¢ no transitions â€¢ transitions without reading input symbols ( -transitions). FORMAL DEFINITION A nondeterministic ï¬nite automaton (NFA) is a 5-tuple , where: â€¢ (ï¬nite set) are the states â€¢ (ï¬nite set) is the alphabet â€¢ is the transition function â€¢ is the start state â€¢ is the set of accept states An input is accepted if there exists at least one path that ends at an accepting state. EQUIVALENCE TO DFA Every NFA has a DFA that accepts the same language. It can be created using as the set of states, and using . CONCATENATION A NFA for the concatenation of two preexisting NFAs can be created by adding -transitions from the ï¬rst MFAâ€™s accepting states to the second NFAâ€™s start state. Its transition function is formally deï¬ned as: Îµ (Q, Î£, Î´, q0, F ) Q Î£ Î´ : Q Ã— (Î£ âˆª {Îµ}) â†’ ğ’«(Q) (q, Ïƒ) â†¦ Î´(q, Ïƒ) q0 âˆˆ Q F âŠ‚ Q ğ’«(Q) ËœÎ´(qset, a) = â‹ƒ qâˆˆqset Î´(q, a) Îµ Î´(q, a) = Î´1(q, a) ifÂ q âˆˆ F1Â andÂ q âˆ‰ F1 insideÂ Q1 Î´1(q, a) ifÂ q âˆˆ F1Â andÂ a â‰  Îµ insideÂ Q1 Î´1(q, a) ifÂ q âˆˆF 1Â andÂ a = Îµ Îµ-transit. Î´2(q, a) ifÂ q âˆˆ Q2 insideÂ Q2 of 7 17 Example 1 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic ï¬nite automaton N1 The difference between a deterministic ï¬nite automatona abbreviated DFAa and a nondeterministic ï¬nite automatona abbreviated NFAais immediately apË† parentâ€œ Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabetâ€œ The NFA shown in Figure â€”â€œÂ¨7 violates that ruleâ€œ State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1â€œIn an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbolâ€œ Seconda in a DFAalabels on the transition arrows are symbols from the alphaË† betâ€œ This NFA has an arrow with the label \u0000â€œIn generala an NFA may have arrows labeled with members of the alphabet or \u0000â€œZeroa onea or many arrows may exit from each state with the label \u0000â€œ How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceedâ€œ For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1â€œAfter reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallelâ€œ Each copy of the machine takes one of the possible ways to proceed and continues as beforeâ€œ If there are subsequent choicesa the machine splits againâ€œ If the next input symbol doesnâ€™t appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with itâ€œ Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input stringâ€œ If a state with an \u0000 symbol on an exiting arrow is encountereda something similar happensâ€œ Without reading any inputa the machine splits into multiple copiesa one following each of the exiting \u0000Ë†labeled arrows and one staying at the current stateâ€œ Then the machine proceeds nondeterministically as beforeâ€œ Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent â€œprocessesâ€ or â€œthreadsâ€ can be running concurrentlyâ€œ When the NFA splits to follow several choicesa that corresponds to a process â€œforkingâ€ into several childrena each proceeding separatelyâ€œ If at least one of these processes acceptsa then the entire computation acceptsâ€œ Another way to think of a nondeterministic computation is as a tree of possiË† bilitiesâ€œ The root of the tree corresponds to the start of the computationâ€œ Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choicesâ€œ The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure â€”â€œÂ¨8â€œ What language does the NFA recognize? L = {w Å“ {0, 1} Ãº | w contains 11 or 101 as a substring} Lecture 2, 28.02.2022 Concatenation 1.2 NONDETERMINISM 61 FIGURE 1.48 Construction of N to recognize A1 \u0000 A2 PROOF Let N1 =(Q1, \u0000, \u00001,q1,F1) recognize A1aand N2 =(Q2, \u0000, \u00002,q2,F2) recognize A2â€œ Construct N =(Q, \u0000, \u0000,q1,F2) to recognize A1 \u0000 A2â€œ 1. Q = Q1 \u0000 Q2â€œ The states of N are all the states of N1 and N2â€œ 2. The state q1 is the same as the start state of N1â€œ 3. The accept states F2 are the same as the accept states of N2â€œ 4. Deï¬ne \u0000 so that for any q \u0000 Q and any a \u0000 \u0000\u0000a \u0000(q, a)= \u0000 \u0000\u0000\u0000\u0000 \u0000\u0000\u0000\u0000 \u00001(q, a) q \u0000 Q1 and q \u0000\u0000 F1 \u00001(q, a) q \u0000 F1 and a \u0000= \u0000 \u00001(q, a) \u0000 {q2} q \u0000 F1 and a = \u0000 \u00002(q, a) q \u0000 Q2. Lecture 2, 28.02.2022 Non-Regular Languages PUMPING LEMMA âœ¨ Used to show that a language is not regular. If is a regular language, there exists a number (the pumping length) such that: â‘  for all \t A â€œloopâ€ can be repeated â‘¡ \t It is nonempty â‘¢ \t It is fully followed before Computability Turing Machines DEFINITION A Turing macine is a 7-tuple , where: â€¢ (ï¬nite set) is the set of states. â€¢ (ï¬nite set) is the input alphabet ( ). â€¢ (ï¬nite set) is the tape alphabet, with (blank symbol), and . â€¢ is the transition function.â€¨ From a state and tape symbol, gives the new state and symbol to write + the move to do â€¢ is the start state. â€¢ is the accept state and is the reject state ( ). CONFIGURATIONS The full state of a Turing machine is given by its conï¬guration , where: â€¢ are the tape contents (the current head location is the ï¬rst symbol of ) â€¢ is the current state COMPUTATION We start with the conï¬guration where is the input. If the current conï¬guration is (with , and ), we move to: We repeat until or is reached.â€© L p x yiz âˆˆ L i â‰¥ 0 | y | â‰¥ 1 | x y | â‰¤ p p (Q, Î£, Î“, Î´, q0, qaccept, qreject) Q Î£ âŠ” âˆ‰ Î£ Î“ âŠ” âˆˆ Î“ Î£ âŠ† Î“ Î´ : Q Ã— Î“ â†’ Q Ã— Î“ Ã— {L, R} q0 âˆˆ Q qaccept âˆˆ Q qreject qaccept â‰  qreject u q v uv v q C1 = q0w w âˆˆ Î£* u a qi bv u, v âˆˆ Î“* u, v âˆˆ Î“ qi âˆˆ Q { uabqj v ifÂ Î´(qi, b) = (qj, c, L) uqj abv ifÂ Î´(qi, b) = (qj, c, R) qaccept qreject of 8 17 with , whereâˆ€s âˆˆ A | s | â‰¥ p s = x yz {w : w has an equal number of 0â€™s and 1â€™s} Q = {q0, q1, q2, q3, qA, qR } \u0000 = {0, 1} \u0000 = {0, 1, Ã›, X } â€“ X crossed o\u0000 letter q0 q1 q2 q3 qA qR X Ã¦Ã›, R 0 Ã¦Ã›, R 1 Ã¦Ã›, R Ã›Ã¦ R X , 0 Ã¦ R Ã›Ã¦ R 1 Ã¦ X , L Ã›Ã¦ R 1, X Ã¦ R 0 Ã¦ X , L Ã›Ã¦ R 0, 1, X Ã¦ L Execution of the TM on 0110 Lecture 4, 21.03.2022 EQUIVALENCE TO OTHER MODELS CHURCH-TURING THESIS Intuitive notion of algorithms (= every algorithm we can execute, even on a quantum computer)â€¨ = Turing machine algorithms Decidability and Undecidability DEFINITIONS TURING-RECOGNIZABILITY A Turing machine recognizes a language iï¬€ for all inputs , â€¢ accepts â€¢ rejects or doesnâ€™t halt. This language is then Turing-recognizable. TURING-DECIDABILITY A Turing machine decides a language iï¬€ for all inputs , â€¢ accepts â€¢ rejects . This language is then Turing-decidable. It halts on every input. USING TURING MACHINES AS INPUT Anything can be encoded as a binary stringâ€¨ â†’ we can use Turing Machines or ï¬nite automata as the input for a Turing machine! ğŸ“ Notation: = binary encoding of .â€© L âŠ† Î£* w âˆˆ Î£* w âˆˆ L â‡’ M w w âˆ‰ L â‡’ M w L âŠ† Î£* w âˆˆ Î£* w âˆˆ L â‡’ M w w âˆ‰ L â‡’ M w âŸ¨DâŸ© D of 9 17 EXAMPLES CHECKING WHETHER A DFA IS EMPTY (RECOGNIZES NOTHING) âœ… is decidable. Idea: browse all the DFA nodes and mark the reachable states. Accept iï¬€ there is an accepting state that is marked. CHECKING WHETHER TWO DFA RECOGNIZE THE SAME LANGUAGE âœ… is decidable. Idea: since and are regular, is regular as wellâ€¨ (since can be constructed from and ) and there is a DFA for it.â€¨ â†’ Identify whether this DFA is empty (â†’ same language) or not (â†’ diï¬€erent language). LANGUAGE OF MACHINES THAT DONâ€™T ACCEPT THEMSELVES âŒ is undecidable. Idea: let be the machine that decides . â€¢ If accepts , then (doesnâ€™t match the deï¬nition). â€¢ If rejects , then and shouldnâ€™t have rejected ! CHECKING WHETHER A TURING MACHINE HALTS ON AN INPUT âŒ is undecidable. Idea: we could build a decider for from it. CHECKING WHETHER A TURING MACHINE ACCEPTS AN INPUT âŒ is undecidable. Idea: we could build a decider for from it. CHECKING WHETHER A TURING MACHINE ACCEPTS A REGULAR LANGUAGE âŒ is undecidable. Idea: by reduction to . Run the hypothetical decider on a machine that accepts if doesnâ€™t accept , and if accepts .â€© ğ–¤DFA = {âŸ¨DâŸ© : L(D) = âˆ…} ğ–¤ğ–°DFA = {âŸ¨D, Dâ€² âŸ© : L(D) = L(Dâ€² )} L(D) L(Dâ€² ) L(D) âŠ• L(Dâ€² ) âŠ• âˆª âˆ© ğ–£ğ–¨ğ– ğ–¦ = {âŸ¨MâŸ© : MÂ doesnâ€™tÂ acceptÂ âŸ¨MâŸ©} Mğ–£ ğ–£ğ–¨ğ– ğ–¦ Mğ–£ âŸ¨Mğ–£âŸ© L(Mğ–£) â‰  ğ–£ğ–¨ğ– ğ–¦ Mğ–£ âŸ¨Mğ–£âŸ© Mğ–£ âˆˆ ğ–£ğ–¨ğ– ğ–¦ Mğ–£ âŸ¨Mğ–£âŸ© ğ–§ğ– ğ–«ğ–³ = {âŸ¨M, wâŸ© : MÂ haltsÂ onÂ inputÂ w} ğ–£ğ–¨ğ– ğ–¦ ğ– TM = {âŸ¨M, wâŸ© : MÂ acceptsÂ w} ğ–£ğ–¨ğ– ğ–¦ ğ–±ğ–¤ğ–¦TM = {âŸ¨MâŸ© : L(M )Â isÂ regular} ğ– TM {0n1n : n âˆˆ â„•} M w {0,1}* M w of 10 17 UNRECOGNIZABLE LANGUAGES THEOREM Decidable recognizable and complement recognizable. Proof: run both recognizers and one will stop. Example: , are not recognizable. CHECKING WHETHER TWO TURING MACHINES HAVE THE SAME LANGUAGE âŒ is unrecognizable. Idea: by reduction to . Compare the machine â€œrun on â€ to the machine â€œreject everythingâ€. REDUCTIONS âœ¨ Use the knowledge of another language to determine easily properties of a language. COMPUTABLE FUNCTION A function is a computable function if there exists some Turing machine that for every input halts with just on its tape. MAPPING REDUCIBLE : The language is mapping reducible to language iï¬€ computable with for every THEOREMS Let and be languages such that . â€¢ decidable decidable.\t ( undecidable undecidable.) â€¢ recognizable recognizable.\t ( unrecognizable unrecognizable.) â‡” ğ–§ğ– ğ–«ğ–³ ğ– TM ğ–¤ğ–°TM = {âŸ¨M1, M2âŸ© : L(M1) = L(M2)} ğ– TM M w f : Î£ * â†’ Î£ * w f (w) A â‰¤m B A B âˆƒ f w âˆˆ A â‡” f (w) âˆˆ B w âˆˆ Î£* A B A â‰¤m B B â‡’ A A â‡’ B B â‡’ A A â‡’ B of 11 17 Complexity Deï¬nitions RUNNING TIME OF A TURING MACHINE Let be a decider (TM that halts on every input). Its running time (time complexity) is: TIME COMPLEXITY CLASS For instance, regular languages . P vs. NP CLASS P Languages that are decidable in polynomial time (on a deterministic Turing machine). We can show that a problem is in by giving a polynomial-time algorithm in any language. CLASS NP VERIFIERS A veriï¬er for the language is a Turing machine such that : â€¢ (certiï¬cate/witness) such that accepts â€¢ , rejects CLASS NP Veriï¬er in polynomial time = its running time on any input is polynomial in . PROBLEMS IN NP â€¢ SAT: existence of a satisfying assignment to a CNF formulaâ€¨ (Cook-Levin theorem: )â€¨ kSAT: SAT with a limite of literals in each clause â€¢ GI: existence of a graph isomorphism (bijection that preserves adjacency). â€¢ INDSET: in a graph, existence of a subset of a given size in which all vertices are mutually independent.â€© M t(n) = max wâˆˆÎ£n [stepsÂ ofÂ MÂ onÂ w] TIME(t(n)) = {languagesÂ decidedÂ byÂ aÂ TMÂ inÂ O(t(n))} âŠ† TIME(n) P = â‹ƒ âˆ k=1 TIME(nk) P L M âˆ€x âˆˆ Î£* x âˆˆ L â‡’ âˆƒC M âŸ¨x, C âŸ© x âˆ‰ L â‡’ âˆ€C M âŸ¨x, C âŸ© NP = {languagesÂ withÂ veriï¬ersÂ inÂ polynomialÂ time} âŸ¨x, C âŸ© | x | ğ–²ğ– ğ–³ âˆˆ P â‡” P = NP k of 12 17 NON-DETERMINISTIC TURING MACHINES A non-deterministic Turing machine (NTM) can return several possible transitions. DECIDERS A non-deterministic decider for a language is a NTM which halts on every input , and: â€¢ If , some computation accepts. â€¢ If , every computation rejects. POLYNOMIAL-TIME NTM A polynomial-time NTM has the running time of its longest computation polynomial in . NON-DETERMINISTIC POLYNOMIAL-TIME DECIDER POLYNOMIAL-TIME VERIFIER Since a certiï¬cate can be computed deterministically, this theorem holds. NAMING ON THE NP CLASS NP stands for non-deterministic polynomial-time.\t POLYNOMIAL-TIME REDUCTIONS POLY-TIME COMPUTABLE FUNCTION A function is a poly-time computable function if there exists someâ€¨ polynomial-time Turing machine that for every input halts with just on its tape. POLY-TIME MAPPING REDUCIBLE : is poly-time mapping reducible to with a polynomial-time computable function THEOREMS Let , and be languages such that . â€¢ in in .\t ( not in not in .) â€¢ .\t (Transitivity) NP-COMPLETENESS A language is -complete if and , . To show that a language is -complete, we have to prove: â€¢ -membership: show that (give a polynomial-time veriï¬er). â€¢ -hardness: show that â€¨ (or any other NP-complete language such as INDSET or 3SAT). Î´ : (Q, Î“) â†’ ğ’«(Q, Î“, {L, R}) L x x âˆˆ L x âˆ‰ L | x | â‡” NP = â‹ƒâˆ k=1 NTIME(nk) f : Î£ * â†’ Î£ * w f (w) A â‰¤P B A B A B C A â‰¤P B B P â‡’ A P A P â‡’ B P B â‰¤P C â‡’ A â‰¤P C L NP L âˆˆ NP âˆ€N âˆˆ NP N â‰¤P L L NP NP L âˆˆ NP NP ğ–²ğ– ğ–³ â‰¤P L of 13 17 NP-Complete Problems SAT PROBLEM Does this CNF formula have any satisfying assignment? (For instance: ) NP-COMPLETENESS By the Cook-Levin theorem. 3SAT PROBLEM = where each clause has at most three literals NP-COMPLETENESS reduces to : . âœ¨ However, might not reduce to , which is decidable in polynomial time. INDSET PROBLEM Independent set = subset where no vertices are adjacent. NP-COMPLETENESS reduces to : â€¢ Create a vertex for each clauseâ€™s part â€¢ Link all vertices relative to the same variable but negated (= conï¬‚icting vertices)â€¨ â†’ Avoids conï¬‚ict in the result. â€¢ Link all vertices within a clauseâ€¨ â†’ Avoids using multiple parts of the same clause to reach the goal â€¢ Size of the independent set: number of clausesâ€¨ Ï†1 = (Â¯x âˆ¨ Â¯y âˆ¨ z) âˆ§ (y âˆ¨ Â¯z âˆ¨ a âˆ¨ b) âˆ§ â€¦ ğ–²ğ– ğ–³ ğ–²ğ– ğ–³ ğŸ¥ğ–²ğ– ğ–³ (a âˆ¨ b âˆ¨ c âˆ¨ d ) â†¦ (a âˆ¨ b âˆ¨ Ï†) âˆ§ ( Â¯Ï† âˆ¨ c âˆ¨ d ) ğ–²ğ– ğ–³ ğŸ¤ğ–²ğ– ğ–³ ğ–¨ğ–­ğ–£ğ–²ğ–¤ğ–³ = {âŸ¨G, kâŸ© : GÂ hasÂ anÂ ind.Â setÂ ofÂ sizeÂ k} ğ–²ğ– ğ–³ ğ–¨ğ–­ğ–£ğ–²ğ–¤ğ–³ of 14 17 â†’ Requires one variable in each clause to be true. CLIQUE PROBLEM Clique = subset where all the vertices are pairwise connected. NP-COMPLETENESS reduces to (invert all edges). VERTEX COVER PROBLEM Vertex cover = subset such that every edge is incident to one vertex of the subset. NP-COMPLETENESS reduces to : search a vertex cover of size , where is the number of vertices. SET COVER PROBLEM Let be a set and be a family of subsets of . NP-COMPLETENESS reduces to : â€¢ set = edges, â€¢ family = edges adjacent to one node, â€¢ number of subsets allowed = size .â€© ğ–¢ğ–«ğ–¨ğ–°ğ–´ğ–¤ = {âŸ¨G, kâŸ© : GÂ hasÂ aÂ cliqueÂ ofÂ sizeÂ k} ğ–¨ğ–­ğ–£ğ–²ğ–¤ğ–³ ğ–¢ğ–«ğ–¨ğ–°ğ–´ğ–¤ ğ–µğ–¾ğ—‹ğ—ğ–¾ğ—‘ğ–¢ğ—ˆğ—ğ–¾ğ—‹ = {âŸ¨G, kâŸ© : GÂ hasÂ aÂ vertexÂ coverÂ ofÂ sizeÂ k} ğ–¨ğ–­ğ–£ğ–²ğ–¤ğ–³ ğ–µğ–¾ğ—‹ğ—ğ–¾ğ—‘ğ–¢ğ—ˆğ—ğ–¾ğ—‹ n âˆ’ k n U â„± = {T1, â€¦, TM} âŠ‚ ğ’«(U ) U ğ–²ğ–¾ğ—ğ–¢ğ—ˆğ—ğ–¾ğ—‹ = {âŸ¨U, â„±, kâŸ© : â„±Â hasÂ aÂ vertexÂ coverÂ ofÂ sizeÂ k} = {âŸ¨U, â„±, kâŸ© : âˆƒi1, â€¦, inÂ suchÂ thatÂ â‹ƒk j=1 Tij = U} ğ–µğ–¾ğ—‹ğ—ğ–¾ğ—‘ğ–¢ğ—ˆğ—ğ–¾ğ—‹ ğ–²ğ–¾ğ—ğ–¢ğ—ˆğ—ğ–¾ğ—‹ k of 15 17 PERFECT 3 MATCHING PROBLEM Let (where ). NP-COMPLETENESS reduces to : â€¢ For each variable, create a â€œgadgetâ€ (pairs of nodes in / which are connected in a cycle) â€¢ Extend each link to connect to an usage of this variableâ€¨ (connect the direct usages to one half of the cycles, and the negated usages to the other half) â€¢ Create some â€œdummyâ€ nodes in and connect them to the remaining cycle nodes. SUBSET SUM PROBLEM NP-MEMBERSHIP In when the input numbers are given in binary (not unary!). NP-COMPLETENESS reduces to : encode each edge as a vector whose columns contain â€œ1â€ when the column corresponds to one of the connected nodes, and â€œ0â€ otherwise. The vector is in base to avoid any issues with sum overï¬‚ows. â€© E âŠ‚ U Ã— V Ã— W | U | = | V | = | W | = n ğ–¯ğ–¾ğ—‹ğ–¿ğ–¾ğ–¼ğ—ğŸ¥ğ–¬ğ–ºğ—ğ–¼ğ—ğ—‚ğ—‡ğ—€ = {âŸ¨EâŸ© : âˆƒm âŠ‚ EÂ whereÂ eachÂ v âˆˆ U âˆª V âˆª WÂ appearsÂ once} ğ–²ğ– ğ–³ ğ–¯ğ–¾ğ—‹ğ–¿ğ–¾ğ–¼ğ—ğŸ¥ğ–¬ğ–ºğ—ğ–¼ğ—ğ—‚ğ—‡ğ—€ U V W ğ–²ğ—ğ–»ğ—Œğ–¾ğ—ğ–²ğ—ğ—† = {âŸ¨X âŠ‚ â„•, sâŸ© : XÂ hasÂ aÂ subsetÂ whoseÂ elementsÂ sumÂ toÂ s} NP ğ–¯ğ–¾ğ—‹ğ–¿ğ–¾ğ–¼ğ—ğŸ¥ğ–¬ğ–ºğ—ğ–¼ğ—ğ—‚ğ—‡ğ—€ ğ–²ğ—ğ–»ğ—Œğ–¾ğ—ğ–²ğ—ğ—† b â‰¥ | E | of 16 17 Circuit Complexity CIRCUIT FOR A TURING MACHINE Given a Turing machine , for an input length and a runtime ,â€¨ we can comput in a circuit of size such that . COOK-LEVIN THEOREM WITNESSEXISTENCE WitnessExistence: general problem (existence of a certiï¬cate) We can reduce WitnessExistence to CircuitSAT (transform into a circuit and force assign ). CIRCUITSAT = Satisï¬ability of a given circuit We can reduce CircuitSAT to SAT (remove all intermediary variables). M n t (n) poly(t (n)) Cn O(t (n)2) Cn(x) = m(x) âˆ€x âˆˆ {0,1} n ğ–¶ğ–¤ = {âŸ¨V, x, 1 t âŸ unary âŸ© : âˆƒyÂ (certiï¬cate)Â suchÂ thatÂ VÂ acceptsÂ yÂ inÂ timeÂ t} V x ğ–¢ğ—‚ğ—‹ğ–¼ğ—ğ—‚ğ—ğ–²ğ– ğ–³ = {âŸ¨CnâŸ© : âˆƒx âˆˆ {0,1}n, Cn(x) = 1} of 17 17","libVersion":"0.5.0","langs":""}