{"path":"Exam/Solutions/Exam3-sols.pdf","text":"Exam III, Theory of Computation 2018-2019 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in the class including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 8 points / 6 points / 8 points / 6 points / 6 points / 6 points Total / 40 Page 1 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 1 Basic questions. (8 pts) Let A ⊆ {0, 1}∗ and B ⊆ {0, 1}∗ be two languages. Which of the following statements are true? 1. A ≤m B =⇒ A ≤p B. 2. If P = NP, then {⟨φ⟩ | φ is a satisﬁable CNF formula} is in P. 3. {⟨M, w⟩ | M is a TM and M doesn’t halt on input w} is in NP. 4. A is recognized by a DFA ⇐⇒ A is recognized by an NFA. 5. A is regular and A ≤m B =⇒ B is regular. 6. A is regular =⇒ A is decidable =⇒ A is in P =⇒ A is in NP. 7. A is in P and B ≤p A =⇒ B is in P. 8. A ∈ TIME(n100) =⇒ A ∈ NP. 9. Suppose A is NP-hard and B is NP-complete. If B is in P then A is in P. 10. A is in P and B is in P =⇒ A ◦ B is in P. 11. A is recognizable by a TM =⇒ its complement ¯A is recognizable by a TM. 12. {w ∈ {0, 1}∗ | number of 1’s in w is divisible by 2019} is regular. (A complete solution identiﬁes all true statements. A fully correct solution is worth 8 points. A solution with one mistake is worth 7 points. A solution with two mistakes is worth 5 point. A solution with three mistakes is worth 3 points. A solution with four mistakes is worth 1 point. Solutions with more mistakes are worth 0 points. A mistake is to either indicate falsely that a false statement is true or to not indicate that a true statement is true.) Solution: 2, 4, 7,8, 10, 12 Page 2 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 2 Regular languages. (6 pts) Consider the following language on alphabet Σ = {0, 1}: L2 = {w ∈ {0, 1}∗ | w has more 0’s than 1’s} . Is L2 regular? Provide a proof of your claim. (In this problem you should decide whether L2 is regular or not, and to give a proof of your claim. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: L2 is a non-regular language. We will prove our claim by contradiction. We use the Pumping Lemma. Suppose that L2 is a regular language and that its pumping length is p. Consider the string s := 1p0p+1 ∈ L2. By the Pumping Lemma, s can be decomposed as s = xyz where |xy| ≤ p, |y| ≥ 1, and xyiz ∈ A for all i ∈ N. Since s starts with p ones, y = 1k for some integer k, 1 ≤ k ≤ p. Then xy2z = 1p+k0p+1 ∈ L2 by the Pumping Lemma. However, p + k ≥ (p + 1) for all 1 ≤ k ≤ p, which contradicts that xy2z ∈ L2. Hence, L2 is not regular. Page 3 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 3 Graph coloring. (8 pts, consisting of subproblems (a) and (b)) A coloring of an undirected graph is an assignment of colors to its vertices so that no two adjacent vertices are assigned the same color. For each positive integer k, let k-COL = {⟨G⟩ | G is colorable with k colors} . In Homework 3 you proved that 3-COL is NP-complete. In this problem we will consider the related languages 2-COL and 4-COL. Speciﬁcally, we will show that 2-COL is in P whereas 4-COL is NP-hard. 3a (3 pts) Show that 2-COL is in P. (In this problem you should show that 2-COL is in P. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: The following algorithm decides 2-COL: Algorithm 1 Is2Col(G = (V, E)) procedure Dfs(G, w, col) color(w) = col for u ∈ N (w) do if color(u) == color(w) then return false if color(u) == ⊥ then Dfs(G, u, col ⊕ 1) return true procedure Is2Col(G = (V, E)) for v ∈ V do color(v) = ⊥ for v ∈ V do if color(v) == ⊥ and Dfs(G, v, 0) == false then return false return true First notice that the following algorithm runs in time O(|V |+|E|) as the algorithm is basically running a DFS. The algorithm visits each vertex and each edge exactly twice. Moreover notice that in any correct 2-coloring for each edge its endpoints have to be colored with opposite colors. So for each connected component if we color one vertex, let’s call it v, then if correct coloring of this component exists it is uniquely deﬁned by color assigned to v (neighbours of v are colored with opposite color to v, neighbours of neighbours are colored with the same colors as v, ...). Algorithm 1 uses that fact, for each connected component it picks a starting vertex v, colors it with color 0 and then explores this connected component using a DFS algorithm. At each point of the algorithm let S ⊂ V be the set of vertices with assigned colors (which is exactly the set of all explored vertices). At each step the algorithm looks at an edge (w, u), w ∈ S. If u ̸∈ S then set S grows by u and u is assigned the only color consistent with the edge (u, w) and the previous coloring. If u ∈ S then the Algorithm checks if the so far built coloring is consistent with edge (u, w). So at each point of the algorithm the following invariant is satisﬁed: color(S) is a valid coloring for graph G′ = (S, E′), where E′ ⊂ E is a set of visited edges or G is not 2-colorable and Algorithm has returned false. Properties of DFS guarantee that it will visit Page 4 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson all the edges and that set S is always connected within one component. These facts guarantee correctness of the Algorithm as if G is 2-colorable the Algorithm will ﬁnd the right coloring and if it’s not it will detect that fact. Page 5 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 3b (5 pts) Show that 3-COL ≤p 4-COL. (In this problem you should describe a polynomial time reduction from 3-COL to 4-COL and prove its correctness. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Given an instance G = (V, E) of 3-COL, create the following instance G′ = (V ′, E′) of 4-COL where V ′ = V ∪ {u} (add a new vertex u) E′ = E ∪ {uv | v ∈ V } (add an edge from u to every vertex in V). This reduction is polynomial since we added 1 vertex and n edges, where n = |V |. To prove correctness of the reduction: Suppose G ∈ 3-COL. Then a valid 4-colouring of G′ is to assign to v ∈ V ′ the same colour as v in the 3-colouring of G, if v ∈ V . Then we can assign the fourth colour to u and so G′ ∈ 4-COL. Now suppose G′ ∈ 4-COL. Since there is an edge from u to every other vertex in G′, these vertices must be a diﬀerent colour from u in a valid 4-colouring. So G can be coloured with 3 colours and hence G ∈ 3-COL. Page 6 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 4 The traveling salesman problem. (6 pts) An instance of the classic traveling salesman problem is deﬁned by a tuple H = (V, d) where V is a set of cities and d : V × V → Z deﬁnes their pairwise distances. That is for two cities i ∈ V and j ∈ V , d(i, j) = d(j, i) equals the distance required to travel between cities i and j. Notice that H can be thought of as a complete graph (every possible edge is present) with weights on the edges corresponding to the distances. A tour is a cycle that visits every city exactly once, i.e., it is a cycle of length |V |. The length of a tour is the total distance travelled which equals the sum of the distances of the edges in the tour. An example is depicted below. The instance has 4 cities and the thick edges depict a tour of length 0 + 2 + 1 + 3 = 6. 2 4 3 5 1 0 Show that the following language is NP-complete: TSP = {⟨H = (V, d), k⟩ | H has a tour of length at most k}. In your proof you may use that the following language is NP-complete: HAM = {⟨G⟩ | G is an undirected graph that is Hamiltonian} . An undirected graph G = (V, E) is said to be Hamiltonian if it contains a cycle of length |V |, i.e., a cycle that visits every vertex. Two examples of Hamiltonian graphs are the complete graph and the graph consisting of a single cycle of length |V |. (In this problem you are asked to prove that the language TSP is NP-complete. Recall that you are allowed to use that HAM is NP-complete and to refer to material covered in the class including theorems without reproving them.) Solution: For proving the NP completeness of the TSP problem we have to prove that: (1) the problem is in NP (2) the problem is NP-Hard. We ﬁrst prove that the problem belongs in NP. Given a certiﬁcate C, which we assume that is an ordered set of edges (the assumption is not restrictive, that means that it can either be a list of edges or a list of vertices) we have to check the following: • The set of edges form a cycle • Every vertex is visited • Every vertex is visited at most once • the sum of the weights of the edges is at most k These four properties can be checked in parallel. Indeed while trasversing the presumed cycle we sum the weight of every new encountered edge, at the same time we keep a counter for every vertex in the graph (all counters were initialized to zero), in this manner a counter value of 0,1,2 Page 7 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson means that the vertex was not visited, visited once, visited twice respectively. The trasversing of the set of edges has to end by encountering a vertex with counter equal to 1. At any point in time, if one of the four properties stop to hold we stop and output False, otherwise True. Note that, since one of the four properties will break if the set of edges has a cardinality bigger that |V | that means that the running time of the veriﬁer is O(|V |). We continue by proving the NP-hardness of TSP, by reducing the Hamiltonian graph problem to TSP. We take as input a graph G and we construct a complete graph G′ with the same set of vertices and the following weights on the edges: d(i, j) = 0 ∀(i, j) ∈ G(E) d(i, j) = ∞ ∀(i, j) ̸∈ G(E) We set k = 0. Now we will prove that G is Hamiltonian iﬀ G′ has a tour of weight at most k • =⇒ If graph G is Hamiltonian then the same tour in G′ will be formed from edges of weight 0. Thus the tour will weight 0. • ⇐= If G′ has a tour of at most lenght 0, then this tour can only contain edges of weight 0 (if it contains an edge with weight strictly greater than zero, then the total weight will be more than 0). All these edges from the deﬁnition of the weight function existed in G, therefore the same tour was present in G, which makes G a Hamiltonian graph. Page 8 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 5 Perfect matchings of a given weight. (6 pts) Let G = (V, E, w) be an undirected graph with edge-weights w : E → Z. A subset M ⊆ E of the edges is a perfect matching if every vertex is incident to exactly one edge in M . In other words, the edges in M pair up all the vertices. The weight of a matching M is the total weight of its edges, i.e., ∑ e∈M w(e). An example is depicted below. The graph consists of 4 vertices, 5 edges with integer weights, and the thick edges indicate a perfect matching of weight 2 + 3 = 5. 2 4 3 5 1 Show that the following language is NP-complete: L5 = {⟨G = (V, E, w), k⟩ | G has a perfect matching of weight k} . (In this problem you are asked to show that the language L5 is NP-complete. Recall that you are allowed to refer to material covered in the class including theorems without reproving them. In particular, you are allowed to use any of the NP-complete languages that we saw in class.) Solution: We ﬁrst need to show that L5 ∈ NP. Given an instance ⟨G = (V, E, w), k⟩ and a certiﬁcate consisting of edges M ⊆ E, the veriﬁer ﬁrst checks if the sum of weights of edges in M is k and then checks that every vertex v occurs in exactly one edge in M . The ﬁrst operation takes |E| time and the second operation takes |V | · |E| time. Hence the veriﬁer takes time polynomial in the size of the input and so L5 ∈ NP. To show that L5 is NP-hard, we perform the following reduction: SUBSET-SUM ≤p L5. Given an instance of SUBSET-SUM ⟨S = {s1, · · · , sn}, t⟩, we construct an instance of L5 as follows: For each number si, create 4 vertices vi,1, vi,2, vi,3, vi,4. Connect (vi,1, vi,2) with an edge of weight si; connect (vi,2, vi,3) with an edge of weight 0; connect (vi,3, vi,4) with an edge of weight 0; connect (vi,4, vi,1) with an edge of weight 0. Let G denote the new graph. Then ⟨G, t⟩ is the constructed instance of L5. For each si, we add 4 vertices and 4 edges to the graph; hence the construction is polynomial time in the size of the input. Claim 1 If there is a subset S such that ∑ j∈S sj = t, then G has a perfect matching of size t. Proof. For every i ∈ S, choose the following edges as part of the matching: (vi,1, vi,2) and (vi,3, vi,4). If i /∈ S, then choose (vi,2, vi,3) and (vi,4, vi,1) as part of the matching. It can be seen that this subset of edges is a perfect matching as it covers all the vertices. Furthermore, the only edges contributing to the weight of the matching are (vj,1, vj,2), for every j ∈ S. Therefore, the weight of the matching is t. □ Claim 2 If G has a perfect matching of size t, then there exist a subset S such that ∑ j∈S sj = t, then Proof. Consider any connected square {vi,1, vi,2, vi,3, vi,4}. Since there are 4 edges in this square, two of these edges will be included in the perfect matching. It will either be (vi,1, vi,2) and (vi,3, vi,4), or (vi,2, vi,3) and (vi,4, vi,1). If (vi,1, vi,2) and (vi,3, vi,4) is part of the matching add i to S, otherwise don’t add it. Since edge (vi,1, vi,2) has weight si, that means that adding i to S results in adding si weight to the subset S. Therefore, the matching of size k implies that the sum of weights of elements in S is also t. □ Page 9 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson Since L5 is in NP and is NP-hard, it is also NP-complete. Page 10 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson 6 Decidability. (6 pts) Consider the following language on alphabet Σ = {0, 1}: L6 = {⟨M ⟩ | M is a TM and the language recognized by M is NP-complete} . Is L6 decidable? Provide a proof of your claim. (In this problem you should decide whether L6 is decidable or not, and give a proof of your claim. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: L6 is undecidable. We will prove this by reduction from AT M . Reduction: Let us deﬁne a computable function f from the inputs of AT M to the inputs of L6. f : ⟨M, w⟩ ↦→ ⟨TM,w⟩ Let us deﬁne the Turing machine TM,w : On input x 1. Run M on w. 2. If M accepts w test if x ∈ SAT . If it is, accept. 3. Else reject. Note that testing if a string is in SAT can be easily done in exponential time. Analysis: • If M accepts w, L(TM,w) = SAT which is N P -complete, as seen in class. Therefore TM,w ∈ L6. • If M does not accept w, (both if it rejects and if it never halts,) L(TM,w) = ∅ which is not N P -complete and therefore TM,w ̸∈ L6. Indeed, if ∅ was N P -complete there would have to be a reduction from SAT to ∅. This reduction would have to map elements of SAT to elements of ∅, which is impossible by deﬁnition. Page 11 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson (This page is intentionally left blank.) Page 12 (of 12) CS-251 Theory of Computation, Exam III • Spring 2019 Ola Svensson","libVersion":"0.5.0","langs":""}