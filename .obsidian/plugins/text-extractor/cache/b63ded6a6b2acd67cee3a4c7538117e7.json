{"path":"Exercises/FinalExam.pdf","text":"Final Exam, Theory of Computation 2019-2020 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in the class including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 18 points / 12 points / 20 points / 15 points / 20 points / 15 points Total / 100 Page 1 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 1 (consisting of subproblems a-b, 18 pts) Basic questions. 1a (8 pts) Write the formal deﬁnition of the class NP. If you use the concept of a veriﬁer or a non-deterministic Turing machine, then explain what it is. Solution: Page 2 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 1b (10 pts) Which of the following statements are true? 1. All regular languages are in NP. 2. All languages in P are regular. 3. All irregular languages are decidable. 4. All decidable languages are in NP. 5. All decidable languages are recognizable. 6. If a language L is decidable, then its complement ¯L is decidable. 7. If a language L is recognizable, then its complement ¯L is recognizable. 8. If a language is NP-hard, then it is NP-complete. 9. The language {w ∈ {0, 1}∗ | number of 0’s in w is divisible by 2020} is regular. 10. The language {0n1n | n ≥ 0} is in NP. 11. {⟨M ⟩ | M is a TM that halts on all inputs of length at least 2020} is recognizable. 12. If languages L1 and L2 are unrecognizable then L1 ∪ L2 is unrecognizable. (A complete solution identiﬁes all true statements. A fully correct solution is worth 10 points. A solution with one mistake is worth 9 points. A solution with two mistakes is worth 7 point. A solution with three mistakes is worth 4 points. A solution with four mistakes is worth 1 point. Solutions with more mistakes are worth 0 points. A mistake is to either indicate falsely that a false statement is true or to not indicate that a true statement is true.) Solution: Among the above statements, the following are true (In this problem you do not need to justify your answer.) Page 3 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 2 (12 pts) NP-completeness. Prove that the following language LONGCYCLE is NP-complete: LONGCYCLE = {⟨G⟩ | G is an undirected graph with a cycle that visits at least half the vertices} . In your proof you may use that the following language is NP-complete: HAM = {⟨G⟩ | G is an undirected graph that is Hamiltonian} . An undirected graph G = (V, E) is said to be Hamiltonian if it contains a cycle of length |V |, i.e., a cycle that visits every vertex. Two examples of Hamiltonian graphs are the complete graph and the graph consisting of a single cycle of length |V |. (In this problem you are asked to prove that the language LONGCYCLE is NP-complete. Recall that you are allowed to use that HAM is NP-complete and to refer to material covered in the class including theorems without reproving them.) Page 4 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 3 (consisting of subproblems a-b, 20 pts) Reductions. In the next two subproblems, we are going to consider reductions between languages INDSET and ODD. Recall from class that INDSET denotes the NP-complete language INDSET = {⟨G, k⟩ | G is an undirected graph with an independent set of size k} and we deﬁne ODD to be the following regular language ODD = {w ∈ {0, 1} ∗ | w has an odd number of 1’s} . 3a (10 pts) In this subproblem, we are going to show that if INDSET is poly-time mapping reducible to ODD then P = NP. Speciﬁcally, your task is to prove the following statement: If INDSET ≤p ODD then P = NP. (In this problem you are asked to prove that if INDSET ≤p ODD then P = NP. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Page 5 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 3b (10 pts) In this subproblem, we are going to show that INDSET is mapping reducible to ODD. Speciﬁcally, your task is to show that INDSET ≤m ODD. (In this problem you are asked to give a mapping reduction from INDSET to ODD. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Page 6 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 4 (15 pts) Regular languages. Given a language A ⊆ {0, 1}∗, let B = {EVEN(w) | w ∈ A} , where EVEN(w) denotes the string with only the even-positioned letters of w. For example, EVEN(11101011) = 1001. Describe an NFA that shows that B is regular if A is regular. (In this problem you are asked to construct an NFA that shows that if A is regular then so is B.) Solution: Page 7 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson (This page is intentionally left blank.) Page 8 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 5 (20 pts) Computability. Classify the following language into one of: decidable, undecidable but recognizable, unrecognizable. SLOWHALT = {⟨M, x⟩ | M is a TM that halts on input x after taking at least 2020 steps} . Justify your answer with a formal proof. (In this problem, you are asked to identify whether SLOWHALT is (decidable and recognizable), (undecidable and recognizable), or (unrecognizable) and provide a formal correctness proof. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Page 9 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson (This page is intentionally left blank.) Page 10 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson 6 (15 pts) Large DFAs. Let LARGE = {0n1n | 1 ≤ n ≤ 106}. That is LARGE contains all strings that have n zeros followed by n ones where n is an integer between 1 and 106. As LARGE contains a ﬁnite number of strings (106 many strings), LARGE is a regular language. However, in this problem you are asked to prove that there is no “small” DFA that recognizes LARGE. More speciﬁcally, your task is to prove the following statement: Any DFA that recognizes LARGE has at least 105 states. (In this problem you should give a proof of the statement that any DFA that recognizes LARGE has at least 105 states. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Page 11 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson (This page is intentionally left blank.) Page 12 (of 12) CS-251 Theory of Computation, Final Exam • Spring 2020 Ola Svensson","libVersion":"0.5.0","langs":""}