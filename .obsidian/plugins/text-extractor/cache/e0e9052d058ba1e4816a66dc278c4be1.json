{"path":"Exam/Solutions/ExamPart2-a.pdf","text":"Exam II, Theory of Computation 2018-2019 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in the class including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 / 7 points / 6 points / 6 points / 6 points Total / 25 Page 1 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 1 (consisting of subproblems a-b, 7 pts) Basic questions. 1a (4 pts) Consider two languages A and B. Which of the following statements are true? 1. A is regular =⇒ A is decidable =⇒ A is recognizable. 2. A and B are decidable =⇒ A ∪ B is decidable. 3. A and B are unrecognizable =⇒ A ∪ B is unrecognizable. 4. A is undecidable and recognizable =⇒ A is unrecognizable. 5. A is decidable =⇒ A is decidable. 6. {0n1n : n ≥ 0} is decidable. 7. A is decidable and A ≤m B =⇒ B decidable. 8. {⟨M, w⟩ | M is a TM and M doesn’t halt on input w} is recognizable. (A complete solution identiﬁes all true statements. A fully correct solution is worth 4 points. A solution with one mistake is worth 3 points. A solution with two mistakes is worth 1 point. Solutions with more mistakes are worth 0 points. A mistake is to either indicate falsely that a false statement is true or to not indicate that a true statement is true.) Solution: Among the above statements, the following are true 1,2,4,5,6 Page 2 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 1b (3 pts) Let B be an undecidable language. Show that B ≤m B implies that B and B are unrecognizable. (In this problem you are asked to provide a formal proof of the statement. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: From the class, we know that: B is decidable iﬀ B is recognizable and Bis recognizable, which is equivalent to B is undecidable iﬀ B is unrecognizable or B is unrecognizable. [1 point for stating the theorem and the equivalent formulation] We will now prove that B is unrecognizable implies B is unrecognizable, and that B is unrecog- nizable implies B is unrecognizable. 1. if B is unrecognizable then from B ≤m B we get that B is also unrecognizable. [1 point for considering the two cases, and proving the ﬁrst one] 2. if B is unrecognizable then from Exercise set VI we know that B ≤m B implies B ≤m B, and thus, B is also unrecognizable. [1 point, correct proofs of the fact B ≤m B ⇐⇒ B ≤m B have a positive impact on the grading of the whole exercise, but are not required to get full points ] Page 3 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 2 (6 pts) A DFA D = (Q, Σ ,δ, q, F ) is deﬁned to be minimal if it has the minimum number of states among all DFAs that recognize the same language as D. More formally, D is minimal if |Q| = min D′=(Q′,Σ,δ′,q′,F ′): L(D)=L(D′) |Q′|. Show that the following language is decidable. L2 = {⟨D⟩ | D is a minimal DFA} . (In this problem you are asked to show that the language L2 is decidable. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: We will design an algorithm that given a description of a DFA D decides whether D is minimal. The algorithm works as follows: Algorithm 1 IsMinimal(D = (Q, Σ, δ, qs, F )) procedure IsMinimal(D = (Q, Σ, δ, qs, F )) for i ∈ [1, |Q| − 1] do for D′ ∈ {(Q′, Σ, δ′, q′, F ′) : |Q′| = i ∧ (Q′, Σ, δ′, q′, F ′) is a description of a DFA} do if EQ(D, D′) == true then return false return true where EQ is a Turing machine that for descriptions of two DFAs decides if they recognize the same language. We know that such a machine exists from the lectures. We need to explain how can we implement second for in the algorithm. Notice that the number of DFAs on i states is bounded by 2i · i · ii·|Σ|, as the number of diﬀerent δ′ is at most ii·|Σ| (for every state q and every letter a ∈ Σ we have i choices for δ′(q, a)), number of diﬀerent q′ is at most i and number of diﬀerent F ′ is at most 2i. In particular the number of DFAs on i states is ﬁnite so we can iterate over them in some arbitrary order (for instance we could iterate over binary strings of length ⌈log(i)⌉ + i + (i · |Σ|) ⌈log(i)⌉, where ﬁrst ⌈log(i)⌉ bits encode the starting state q′, next i bits encode set F ′ and ﬁnal (i·|Σ|) ⌈log(i)⌉ encode the transition function δ′). Now we will prove that this Algorithm decides L2. Previous discussion guarantees that Algorithm terminates. Moreover: • If D = (Q, Σ, δ, qs, F ) ∈ L2 then no DFA with the number of states smaller than |Q| will recognize the same language as D, so EQ will always return false and in turn the Algorithm will return true, • If D = (Q, Σ, δ, qs, F ) ̸∈ L2 then there exists DFA D′ = (Q′, Σ, δ′, q′, F ′) such that |Q′| < |Q| and L(D) = L(D′). As the Algorithm checks all DFAs with smaller than D number of states it also, in particular, checks D′ for which EQ will return true and in turn the Algorithm returns false. Common mistake 1 Many solutions were based on ideas of the form: Page 4 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 1. remove unreachable states, 2. merge a set of states S if once reaching S you cannot escape S and all the states in S are either accepting or rejecting, 3. merge indistinguishable states. These ideas make sense but it’s really hard to make them work. For instance: 1) and 2) alone are not enough to rule out some non-minimal DFAs. The problem with 3) is that it’s not trivial to come up with a correct deﬁnition for indistinguishable states and even with a correct deﬁnition an algorithm for removing them is not trivial. Common mistake 2 Some solutions had the following idea \"Iterate over all DFAs that recognize the same language as D and then check if the number of states is smaller\". There are two problems with this solution: ﬁrst is that the number of such DFAs is inﬁnite (For instance all DFAs with F = ∅ recognize the same (empty) language) so it’s not possible to iterate over them, second is that it’s not clear how to even generate such a set of DFAs. The overall grading scheme was the following: • [6 points] Correct solution and proof. • [5 points] Correct solution with mistakes or missing parts in the proof (for instance not saying why the number of DFAs is ﬁnite) • [1-2 points] Various ideas that work for some cases (of the form of \"Common mistake 1\"). Page 5 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 (This page is intentionally left blank.) Page 6 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 3 (6 pts) Consider the following language L3 = {⟨M ⟩ | M is a TM that halts on every input} . Show that L3 is unrecognizable by giving a mapping reduction from the unrecognizable language N R deﬁned as follows: N R = {⟨M, w⟩ | M is a TM and M does not reject input w} . In other words, show that N R ≤m L3. (In this problem you are asked to give a mapping reduction from the language N R to the language L3 and to provide a formal proof of its correctness. A mapping reduction from another unrecognizable language, such as AT M , only gives partial points. You are not required to prove that L3 and N R are unrecognizable. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: As a reduction consider the following computable function f that maps a pair (Turing machine, string) to a Turing machine: f (⟨M, w⟩) = the following Turing machine: «On input x: 1. Simulate M with w as input for |x| steps. 2. If M rejects w (in |x| steps or less) then go into an inﬁnite loop. 3. Otherwise accept x. » First if ⟨M, w⟩ ∈ N R, then M either accepts w or loops with w as input. In any of these cases, for any input x the if condition in line 2 of f (⟨M, w⟩) will not be satisﬁed. Hence for any input x, f (⟨M, w⟩) will accept x hence f (⟨M, w⟩) ∈ L3. Second if ⟨M, w⟩ /∈ N R then M rejects w in k steps (for some k > 0). Hence, for all inputs x such that |x| ≥ k, the if condition in line 2 will be satisﬁed therefore f (⟨M, w⟩) loops on all inputs x such that |x| ≥ k. In particular f (⟨M, w⟩) /∈ L3. Notice that f is indeed computable (it is just the deﬁnition of a Turing machine) and we just proved that ⟨M, w⟩ ∈ N R ⇐⇒ f (⟨M, w⟩) ∈ L3 which ends the proof. Page 7 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 (This page is intentionally left blank.) Page 8 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019 4 (6 pts) Classify the following language into one of: decidable, undecidable but recognizable, unrecognizable. L4 = {⟨M, D⟩ | M is a TM, D is a DFA and L(D) ∩ L(M ) ̸= φ} . Justify your answer with a formal proof. (In this problem, you are asked to identify whether L4 is (decidable and recognizable), (unde- cidable and recognizable), or (unrecognizable) and provide a formal correctness proof. Recall that you are allowed to refer to material covered in the class including theorems without reproving them.) Solution: Added 2025: See your Homework 2, Problem 1 :) Page 9 (of 9) CS-251 Theory of Computation, Exam II • Spring 2019","libVersion":"0.5.0","langs":""}