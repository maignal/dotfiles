{"path":"Lectures/Lecture1.pdf","text":"Welcome to CS-251: Theory of Computation! Mika Göös School of Computer and Communication Sciences Lecture 1 CS-251 course overview What is CS-251? ▶ Mathematical — problem solving, ability to write proofs. Must attend exercise sessions and solve homework problems. . . ▶ Challenging — abstract thinking, how to reduce one problem to another? What are the fundamental capabilities and limitations of computers? This question goes back to the 1930s... Lecture 1 1930s — Computability Lecture 1 Gödel: What can be mathematically proved? Turing: What can be computed? ? Alan Turing ? Jack Edmonds ? Stephen Cook & Leonid Levin ? Avi Wigderson Seen as the father of computer science “On Computable Numbers, with an Application to the Entscheidungsproblem” ▶ Introduced “Universal machine” that is capable of computing anything that is computable ▶ “Central concept of modern computer” was due to this theoretical paper published in 1936 Introduced the class P — the idea that practical computation is polynomial time computation In the ﬁrst fast algorithm for the matching problem published in 1965 Introduced the concept of NP-complete problems ▶ Stephen Cook was denied tenure at Berkeley (1970); Invented NP-completeness (1971); Won Turing Award (1982) ▶ Leonid Levin’s seminal paper obscured by Russian and Cold War Modern era ▶ Abel prize (2021) and Turing award (2023) Lecture 1 The Computational Universe What computational resources do we need to solve this problem? How much time? How much space? How much communication? The Computational UniverseThe Computational Universe What are the relations between different problems and between different computational models? Does randomness help? Quantum? If I can solve problem A, can I solve problem B? A B Lecture 1 Test whether a computer program finishes running or continues forever Undecidable The Computational Universe Sorting Shortest path P (efficient solvable) Traveling salesman problem Satisfiability Graph Coloring NP (efficient verifiable) Lecture 1 Why I (and hopefully you will) love this topic ▶ Abstraction ▶ No limits ▶ “model of computing” introduced before computers ▶ Quantum computers ▶ Profound impact not only on computer science ▶ P vs NP one of the seven most important math problems ▶ Biology: nature does computation all the time (e.g. evolution) ▶ Game theory: analysis of city planning, economics, etc. Lecture 1Lecture 1Lecture 1Lecture 1 WHO WILL TEACH YOU ALL THE COOL MATERIAL? Lecture 1 The Dream Team of Teaching Assistants Happy to help and answer any questions! PhD BA/MA Ziyi (head TA) Fedor Valentin (exercises) Antoine Anastasia Adrien Artur Madeline Hristo Georgios Ekaterina Martin Zijing Pierre Lecture 1 Who am I (the course responsible)? ▶ Mika Göös ▶ mika.goos@epﬂ.ch ▶ https://theory.epﬂ.ch/mika/ ▶ Faculty of computer science ▶ Research in Complexity Theory ▶ Feedback welcome! Lecture 1 THE COURSE ESSENTIALS Lecture 1 Resources Moodle: http://moodle.epﬂ.ch/ Dynamic: course material (these slides will be there), exercises+solutions, links, etc. Textbook Introduction to the Theory of Computation, 3rd international edition (2013) by Michael Sipser Nice reading. To learn best solve as many exercises as you can Lecture 1 Time and Location Lectures: ▶ Monday 13:15–15:00 Exercise Session: ▶ Monday 15:15–17:00 Oﬃce hours: TBD Ed Discussion forum: All questions about course admin and content All links on Moodle! Lecture 1 Grading 30% — 3 sets of homeworks in groups of 2–4 students 70% — Final exam in June/July Lecture 1 Content Understanding the limits of computational models ▶ Part I — What problems can we solve with constant memory? ▶ Finite Automaton and Regular Languages ▶ Non-determinism ▶ Non-regular languages ▶ Part II — What is computable with any computer? ▶ Turing Machines ▶ Decidability/Undecidability ▶ Part III — What is computable eﬃciently? ▶ Time complexity ▶ P, NP ▶ NP-completeness Lecture 1 Let’s start our journey! What can we do with limited memory? Lecture 1 Example: Parity Input: A string s made of symbols M and W Output: Yes if M appears in s an even number of times. No otherwise Examples: MWMWMW → No MWMMMW→ Yes Computational model: Use just 1 bit of memory What can algorithm on a 1-bit computer do? ▶ Initialize memory ▶ Scan input from left to right ▶ For every symbol seen, change the memory state based on ▶ the current state ▶ the current symbol ▶ Provide an answer based on the ﬁnal state of memory Memory states: ODD and EVEN ODD EVEN M ? ? W ? ? =⇒ Lecture 1 Our ﬁrst algorithm on a 1-bit computer EVEN ODD W W M M State diagram of Deterministic Finite Automaton (DFA) 1 Alphabet Σ = {M, W } (given by problem description) 2 States (memory allowance). In this case 2 but in general any ﬁnite number independent of input length 3 Transition function (arrows) 4 Starting state 5 Accepting state(s) Lecture 1 How to check if a DFA accepts a string? EVEN ODD W W M M M M W W M W M M E O O O E E O EStart Accepting W W M M W W M E E O E E E O Not Accepting This DFA accepts even if the input string is empty! ε Lecture 1 Example 1 To understand what strings a DFA accepts, try a couple of strings to understand the roles of the states! 1.1 FINITE AUTOMATA 37 In our examplea let A = {w| w contains at least one 1 and an even number of 0sfollow the last 1}. Then L(M1)= Aaor equivalentlya M1 recognizes A“ EXAMPLES OF FINITE AUTOMATA EXAMPLE 1.7 Here is the state diagram of ﬁnite automaton M2“ FIGURE 1.8 State diagram of the twoˆstate ﬁnite automaton M2 In the formal descriptiona M2 is ( {q1,q2}, {0,1}, δ,q1, {q2}) “The transition function δ is 01 q1 q1 q2 q2 q1 q2. Remember that the state diagram of M2 and the formal description of M2 contain the same informationa only in different forms“ You can always go from one to the other if necessary“ Agood way to begin understanding any machine is to try it on some sample input strings“ When you do these “experiments” to see how the machine is workinga its method of functioning often becomes apparent“ On the sample string 1101athe machine M2 starts in its start state q1 and proceeds ﬁrst to state q2 after reading the ﬁrst 1aand then to states q2a q1aand q2 after reading 1a 0a and 1“The string is accepted because q2 is an accept state“ But string 110 leaves M2 in state q1aso it is rejected“ After trying a few more examplesayou would see that M2 accepts all strings that end in a 1“Thus L(M2)= {w| w ends in a 1}“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm What strings does the DFA accept? Strings ending with a 1 Lecture 1 Example 2 To understand what strings a DFA accepts, try a couple of strings to understand the roles of the states! 38 CHAPTER 1 / REGULAR LANGUAGES EXAMPLE 1.9 Consider the ﬁnite automaton M3“ FIGURE 1.10 State diagram of the twoˆstate ﬁnite automaton M3 Machine M3 is similar to M2 except for the location of the accept state“ As usuala the machine accepts all strings that leave it in an accept state when it has ﬁnished reading“ Note that because the start state is also an accept statea M3 accepts the empty string ε“As soon as a machine begins reading the empty stringa it is at the end; so if the start state is an accept statea ε is accepted“ In addition to the empty stringa this machine accepts any string ending with a 0“ Herea L(M3)= {w| w is the empty string ε or ends in a 0}. EXAMPLE 1.11 The following ﬁgure shows a ﬁveˆstate machine M4“ FIGURE 1.12 Finite automaton M4 ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm What strings does the DFA accept? Strings ending with a 0 plus empty string ε Lecture 1 Example 3 To understand what strings a DFA accepts, try a couple of strings to understand the roles of the states! 34 CHAPTER 1 / REGULAR LANGUAGES In beginning to describe the mathematical theory of ﬁnite automataa we do so in the abstracta without reference to any particular application“ The following ﬁgure depicts a ﬁnite automaton called M1“ FIGURE 1.4 Aﬁnite automaton called M1 that has three states Figure —“¸ is called the state diagram of M1“It has three statesalabeled q1a q2a and q3“The start statea q1ais indicated by the arrow pointing at it from nowhere“ The accept statea q2ais the one with a double circle“ The arrows going from one state to another are called transitions“ When this automaton receives an input string such as 1101ait processes that string and produces an output“ The output is either accept or reject“We will consider only this yes”no type of output for now to keep things simple“ The processing begins in M1’s start state“ The automaton receives the symbols from the input string one by one from left to right“ After reading each symbola M1 moves from one state to another along the transition that has that symbol as its label“ When it reads the last symbola M1 produces its output“ The output is accept if M1 is now in an accept state and reject if it is not“ For examplea when we feed the input string 1101 into the machine M1 in Figure —“¸a the processing proceeds as follows: 1. Start in state q1“ 2. Read 1afollow transition from q1 to q2“ 3. Read 1afollow transition from q2 to q2“ 4. Read 0afollow transition from q2 to q3“ 5. Read 1afollow transition from q3 to q2“ 6. Accept because M1 is in an accept state q2 at the end of the input“ Experimenting with this machine on a variety of input strings reveals that it accepts the strings 1a 01a 11aand 0101010101“In facta M1 accepts any string that ends with a 1aas it goes to its accept state q2 whenever it reads the symbol 1“In additiona it accepts strings 100a 0100a 110000aand 0101000000aand any string that ends with an even number of 0sfollowing the last 1“It rejects other stringsa such as 0a 10a 101000“ Can you describe the language consisting of all strings that M1 accepts? We will do so shortly“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm What strings does the DFA accept? Strings with at least one 1 that ends with an even number of 0’s Lecture 1 Is the concept of DFAs clear? NO! Although state diagrams are easier to grasp intuitively, we need the formal deﬁnition, too, for two speciﬁc reasons: ▶ Clarify uncertainties ▶ Are 0 accept states allowed? ▶ Must have exactly one transition exiting every state for each possible input symbol? ▶ A formal deﬁnition provides notation ▶ Good notation helps you think and express your thoughts clearly Lecture 1 Formal deﬁnitions A deterministic ﬁnite automaton (DFA) M is a 5-tuple (Q, Σ, δ, q0, F ), where ▶ Q is a ﬁnite set called the states, ▶ Σ is a ﬁnite set called the alphabet, ▶ δ : Q × Σ → Q is the transition function, ▶ q0 ∈ Q is the start state, and ▶ F ⊆ Q is the set of accept states. (allow F = ∅) ▶ δ(q, σ) encodes the state we go to from q when reading σ ∈ Σ. For a string s we use δ(q, s) to denote the state obtained by reading all of s starting in state q. ▶ If A is the set of all strings that machine M accepts, we say that A is the language of machine M and write L(M) = A. We say that M recognizes A or that M accepts A. If the machine accepts no strings, it still recognizes one language — namely, the empty language ∅. Lecture 1 Example 34 CHAPTER 1 / REGULAR LANGUAGES In beginning to describe the mathematical theory of ﬁnite automataa we do so in the abstracta without reference to any particular application“ The following ﬁgure depicts a ﬁnite automaton called M1“ FIGURE 1.4 Aﬁnite automaton called M1 that has three states Figure —“¸ is called the state diagram of M1“It has three statesalabeled q1a q2a and q3“The start statea q1ais indicated by the arrow pointing at it from nowhere“ The accept statea q2ais the one with a double circle“ The arrows going from one state to another are called transitions“ When this automaton receives an input string such as 1101ait processes that string and produces an output“ The output is either accept or reject“We will consider only this yes”no type of output for now to keep things simple“ The processing begins in M1’s start state“ The automaton receives the symbols from the input string one by one from left to right“ After reading each symbola M1 moves from one state to another along the transition that has that symbol as its label“ When it reads the last symbola M1 produces its output“ The output is accept if M1 is now in an accept state and reject if it is not“ For examplea when we feed the input string 1101 into the machine M1 in Figure —“¸a the processing proceeds as follows: 1. Start in state q1“ 2. Read 1afollow transition from q1 to q2“ 3. Read 1afollow transition from q2 to q2“ 4. Read 0afollow transition from q2 to q3“ 5. Read 1afollow transition from q3 to q2“ 6. Accept because M1 is in an accept state q2 at the end of the input“ Experimenting with this machine on a variety of input strings reveals that it accepts the strings 1a 01a 11aand 0101010101“In facta M1 accepts any string that ends with a 1aas it goes to its accept state q2 whenever it reads the symbol 1“In additiona it accepts strings 100a 0100a 110000aand 0101000000aand any string that ends with an even number of 0sfollowing the last 1“It rejects other stringsa such as 0a 10a 101000“ Can you describe the language consisting of all strings that M1 accepts? We will do so shortly“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm We can describe this DFA M formally by writing M = (Q, Σ, δ, q1, F ), where ▶ Q = {q1, q2, q3}, ▶ Σ = {0, 1}, ▶ δ is described as 36 CHAPTER 1 / REGULAR LANGUAGES The formal deﬁnition precisely describes what we mean by a ﬁnite automaˆ ton“ For examplea returning to the earlier question of whether 0 accept states is allowablea you can see that setting F to be the empty set ∅ yields 0 accept statesa which is allowable“ Furthermorea the transition function δ speciﬁes exactly one next state for each possible combination of a state and an input symbol“ That anˆ swers our other question afﬁrmativelya showing that exactly one transition arrow exits every state for each possible input symbol“ We can use the notation of the formal deﬁnition to describe individual ﬁnite automata by specifying each of the ﬁve parts listed in Deﬁnition —“5“ For examˆ plea let’s return to the ﬁnite automaton M1 we discussed earliera redrawn here for convenience“ FIGURE 1.6 The ﬁnite automaton M1 We can describe M1 formally by writing M1 =(Q, Σ, δ,q1,F )awhere 1. Q = {q1,q2,q3}a 2. Σ = {0,1}a 3. δ is described as 01 q1 q1 q2 q2 q3 q2 q3 q2 q2, 4. q1 is the start statea and 5. F = {q2}“ If A is the set of all strings that machine M acceptsa we say that A is the language of machine M and write L(M )= A“We say that M recognizes A or that M accepts A“Because the term accept has different meanings when we refer to machines accepting strings and machines accepting languagesa we prefer the term recognize for languages in order to avoid confusion“ Amachine may accept several stringsa but it always recognizes only one lanˆ guage“ If the machine accepts no stringsa it still recognizes one language— namelya the empty language ∅“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm ▶ q1 is the start state, and ▶ F = {q2}. M recognizes the language L(M) = {w | w contains at least one 1 and an even number of 0s follow the last 1} Lecture 1 PROVING CORRECTNESS OF AUTOMATA Induction! Lecture 1 Does your DFA accept the correct language? Σ = {a, b}, L = {w | w contains an even number of a’s︸ ︷︷ ︸ count(w , a) is even } q0 q1 b b a a DFA M: How do you prove that M is correct, that is, M accepts exactly L? ▶ To prove: For all strings w , M accepts w iﬀ count(w , a) is even ▶ To prove: For all strings w , δ(q0, w ) = q0 iﬀ count(w , a) is even Lecture 1 Proof of correctness To prove: For all strings w , δ(q0, w ) = q0 iﬀ count(w , a) is even Proof by induction on string length/structure Base case: Prove the claim for w = ε Inductive case: ▶ Assume that claim holds for an arbitrary string x ▶ Prove the claim for w = x .σ, where σ is a symbol (either a or b) Lecture 1 q0 q1 b b a a Proof of correctness: Base Case To prove: For all strings w , δ(q0, w ) = q0 iﬀ count(w , a) is even Base case: Prove the claim for w = ε ▶ We have δ(q0, ε) = q0 ▶ The empty string has 0 number of a’s, which is an even number ▶ So the claim holds Lecture 1 q0 q1 b b a a Inductive Case To prove: For all strings w , δ(q0, w ) = q0 iﬀ count(w , a) is even Inductive case: Assume that the claim holds for an arbitrary string x : that is, assume: δ(q0, x ) = q0 iﬀ count(x , a) is even ▶ Need to show the claim for x .σ, where σ is symbol in {a, b} ▶ δ(q0, x ) can be q0 or q1, and σ can be a or b. ▶ Gives four cases to consider. Let us consider the case δ(q0, x ) = q0 and σ = b, rest three are similar Lecture 1 q0 q1 b b a a Inductive Case To prove: For all strings w , δ(q0, w ) = q0 iﬀ count(w , a) is even Case δ(q0, x ) = q0 and σ = b: ▶ By Induction Hypothesis, count(x , a) is even ▶ To prove δ(q0, x .b) = q0 iﬀ count(x .b, a) is even ▶ By deﬁnition of δ: δ(q0, x .b) = δ(δ(q0, x ), b) = δ(q0, b) = q0 ▶ Adding b to a string does not change the number of a’s it contains, so count(x .b, a) equals count(x , a), which is even in this case. QED Lecture 1 q0 q1 b b a a Another Example What language does this DFA accept? q0 q1 q2 b b a,b a a DFA M: Claim: L(M) = {w | w contains at least two a’s}. Lecture 1 Proof of correctness To prove: For all strings w , δ(q0, w ) = q2 iﬀ count(w , a) is at least 2 Proof by induction on string w Base case: Prove the claim for w = ε ▶ We have δ(q0, ε) = q0 ▶ count(w , a) = 0 ▶ So the claim holds Lecture 1 q0 q1 q2 b b a,b a a Inductive case Induction hypothesis, δ(q0, x ) = q2 iﬀ count(x , a) is at least 2 To prove, for σ ∈ {a, b}, δ(q0, x .σ) = q2 iﬀ count(x .σ, a) is at least 2. Case δ(q0, x ) = q0 and σ = a: ▶ In this case, by induction hypothesis, count(x , a) < 2 ▶ To prove: δ(q0, x .a) = q2 iﬀ count(x .a, a) is at least 2 ▶ The proof fails!! ▶ count(x , a) = 1 and δ(q0, x ) = q0 is consistent with the assumptions ▶ In such a case, count(x .a, a) = 2 but δ(q0, x .a) = δ(q0, a) = q1 ▶ Claim does not hold. How to ﬁx the proof? Lecture 1 q0 q1 q2 b b a,b a a Stronger claim For all strings w , δ(q0, w ) =    q0 if count(w , a) = 0 q1 if count(w , a) = 1 q2 if count(w , a) ≥ 2 The claim is stronger than the original claim: ▶ If we prove this, it follows that δ(q0, w ) = q2 iﬀ count(w , a) ≥ 2 Instead of just saying “strings in L lead to a ﬁnal state and strings not in L lead to a non-ﬁnal state”, we have strengthened the claim by identifying, for each state, which strings lead to that state Lecture 1 q0 q1 q2 b b a,b a a Correctness Proof To prove: For all strings w , δ(q0, w ) =    q0 if count(w , a) = 0 q1 if count(w , a) = 1 q2 if count(w , a) ≥ 2 Proof by induction on string w Base case: Prove the claim for w = ε ▶ We have δ(q0, ε) = q0 ▶ count(w , a) = 0 ▶ So the claim holds Lecture 1 q0 q1 q2 b b a,b a a Inductive case Assume that δ(q0, x ) equals q0 if count(x , a) = 0, equals q1 if count(x , a) = 1 and equals q2 if count(x , a) ≥ 2 Prove that, for each σ ∈ {a, b}, δ(q0, x .σ) equals q0 if count(x .σ, a) = 0, equals q1 if count(x .σ, a) = 1 and equals q2 if count(x .σ, a) ≥ 2 Proof by cases: δ(q0, x ) can be q0 or q1 or q2, and σ can be a or b Case δ(q0, x ) = q0 and σ = a: ▶ count(x , a) = 0 by induction hypothesis and so count(x .a, a) = 1 ▶ δ(q0, x .a) = δ(δ(q0, x ), a) = δ(q0, a) = q1. ▶ So claim holds Remaining ﬁve cases are similar Lecture 1 q0 q1 q2 b b a,b a a Recipe for Proving Correctness of Automata Given a language L described by a mathematical constraint and a DFA M = ({q0, q1, . . . , qn}, Σ, δ, q0, F ), to prove that L(M) = L: ▶ Find a precise descriptions of the sets T0, T1, . . . , Tn of strings that take the machine from initial state to the corresponding states ▶ Language L should match sets corresponding to accepting states ▶ Prove by induction on string w : For all w , δ(q0, w ) = qi if w is in set Ti , for i = 0, 1, . . . , n ▶ Base case ▶ Prove claim for w = ε ▶ Inductive case ▶ Assume: δ(q0, x ) = qi if x ∈ Ti for i = 0, 1, . . . , n ▶ To prove: for each σ ∈ Σ, δ(q0, x .σ) = qi if x .σ ∈ Ti for i = 0, 1, . . . , n. ▶ Proof by case analysis on what σ is and what δ(q0, x ) is. Lecture 1 REGULAR LANGUAGES AND OPERATIONS Lecture 1 Regular Languages ▶ Σ∗ set of all strings composed of symbols from Σ ▶ Includes the empty string ε ▶ L(M) ⊆ Σ∗ set of strings accepted by M ▶ L is a regular language if there is a DFA such that L = L(M) Regular expressions for pattern matching in documents (supported by all modern programming languages and editors) So DFAs not only beautiful theory but of practical importance!! Are all languages regular? If not which ones are? Lecture 1 New languages from old ▶ Complement ▶ ¯L = {w ∈ Σ∗ : w is not in L} ▶ Union ▶ L1 ∪ L2 = {w ∈ Σ∗ : w ∈ L1 or w ∈ L2} ▶ Intersection ▶ L1 ∩ L2 = {w ∈ Σ∗ : w ∈ L1 and w ∈ L2} ▶ Concatenation ▶ L1 ◦ L2 = {w ∈ Σ∗ : w = w1.w2, w1 ∈ L1 and w2 ∈ L2} Lecture 1 Complement If L is regular is its complement ¯L = {w ∈ Σ∗ : w is not in L} regular? ▶ Let M = (Q, Σ, δ, q0, F ) be a DFA that accepts L ▶ Let M ′ = (Q, Σ, δ, q0, ¯F = Q \\ F ) be the DFA where accepting states are complemented ▶ w ∈ L(M) ⇐⇒ w < L(M ′) Theorem: L(M ′) = ¯L Hence complement of a regular language is regular Lecture 1 Example 1.1 FINITE AUTOMATA 37 In our examplea let A = {w| w contains at least one 1 and an even number of 0sfollow the last 1}. Then L(M1)= Aaor equivalentlya M1 recognizes A“ EXAMPLES OF FINITE AUTOMATA EXAMPLE 1.7 Here is the state diagram of ﬁnite automaton M2“ FIGURE 1.8 State diagram of the twoˆstate ﬁnite automaton M2 In the formal descriptiona M2 is ( {q1,q2}, {0,1}, δ,q1, {q2}) “The transition function δ is 01 q1 q1 q2 q2 q1 q2. Remember that the state diagram of M2 and the formal description of M2 contain the same informationa only in different forms“ You can always go from one to the other if necessary“ Agood way to begin understanding any machine is to try it on some sample input strings“ When you do these “experiments” to see how the machine is workinga its method of functioning often becomes apparent“ On the sample string 1101athe machine M2 starts in its start state q1 and proceeds ﬁrst to state q2 after reading the ﬁrst 1aand then to states q2a q1aand q2 after reading 1a 0a and 1“The string is accepted because q2 is an accept state“ But string 110 leaves M2 in state q1aso it is rejected“ After trying a few more examplesayou would see that M2 accepts all strings that end in a 1“Thus L(M2)= {w| w ends in a 1}“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm is the complement of 38 CHAPTER 1 / REGULAR LANGUAGES EXAMPLE 1.9 Consider the ﬁnite automaton M3“ FIGURE 1.10 State diagram of the twoˆstate ﬁnite automaton M3 Machine M3 is similar to M2 except for the location of the accept state“ As usuala the machine accepts all strings that leave it in an accept state when it has ﬁnished reading“ Note that because the start state is also an accept statea M3 accepts the empty string ε“As soon as a machine begins reading the empty stringa it is at the end; so if the start state is an accept statea ε is accepted“ In addition to the empty stringa this machine accepts any string ending with a 0“ Herea L(M3)= {w| w is the empty string ε or ends in a 0}. EXAMPLE 1.11 The following ﬁgure shows a ﬁveˆstate machine M4“ FIGURE 1.12 Finite automaton M4 ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Lecture 1 Union ▶ L1 = L(M1), M1 = (Q1, Σ, δ1, q1, F1) ▶ L2 = L(M2), M2 = (Q2, Σ, δ2, q2, F2) If M1’s alphabet Σ1 is diﬀerent from M2’s alphabet Σ2 then ﬁrst extend them to the alphabet Σ = Σ1 ∪ Σ2 before taking the union The union is recognized by the DFA M = (Q, Σ, δ, q0, F ) where ▶ Q = Q1 × Q2 ▶ δ((q1, q2), a) = (δ1(q1, a), δ2(q2, a)) ▶ q0 = (q1, q2) ▶ F = {(q1, q2) : q1 ∈ F1 or q2 ∈ F2} Run M1 and M2 in parallel and accept if one of them does Lecture 1 Example q0 q1 0 0,1 1 h0 h1 0 1 10 q0h0 q1h0 q0h1 q1h1 0 1 0 1 1 0 1 0 The union Lecture 1 Intersection ▶ L1 = L(M1), M1 = (Q1, Σ, δ1, q1, F1) ▶ L2 = L(M2), M2 = (Q2, Σ, δ2, q2, F2) If M1’s alphabet Σ1 is diﬀerent from M2’s alphabet Σ2 then ﬁrst extend them to the alphabet Σ = Σ1 ∪ Σ2 before taking the intersection The union is recognized by the DFA M = (Q, Σ, δ, q0, F ) where ▶ Q = Q1 × Q2 ▶ δ((q1, q2), a) = (δ1(q1, a), δ2(q2, a)) ▶ q0 = (q1, q2) ▶ F = {(q1, q2) : q1 ∈ F1 and q2 ∈ F2} Run M1 and M2 in parallel and accept if both of them do Lecture 1 Example q0 q1 0 0,1 1 h0 h1 0 1 10 q0h0 q1h0 q0h1 q1h1 0 1 0 1 1 0 1 0 The intersection Lecture 1 Concatenation? Lecture 1","libVersion":"0.5.0","langs":""}