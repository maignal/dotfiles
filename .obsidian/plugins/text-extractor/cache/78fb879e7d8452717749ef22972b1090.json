{"path":"Homeworks/Solutions/HW2_sol.pdf","text":"Homework III, Theory of Computation 2025 Submission: The deadline for Homework 3 is 23:59 on 22 May. Please submit your solutions on Moodle. Typing your solutions using a typesetting system such as LATEX is strongly encouraged! If you must handwrite your solutions, write cleanly and with a pen. Messy and unreadable homeworks will not be graded. No late homeworks will be accepted. Writing: Please be precise, concise and (reasonably) formal. Keep in mind that many of the problems ask you to provide a proof of a statement (as opposed to, say, just to provide an example). Therefore, make sure that your reasoning is correct and there are no holes in it. A solution that is hard/impossible to decipher/follow might not get full credit (even if it is in principle correct). You do not need to reprove anything that was shown in the class—just state clearly what was proved and where. Collaboration: These problem sets are meant to be worked on in groups of 2–4 students. Please submit only one writeup per team—it should contain the names of all the students. You are strongly encouraged to solve these problems by yourself. If you must, you may use books or online resources to help solve homework problems, but you must credit all such sources in your writeup and you must never copy material verbatim. Even though only one writeup is submitted, it is expected that each one of the team members is able to fully explain the solutions if requested to do so. Grading: Each of the two problems will be graded on a scale from 0 to 5. Warning: Your attention is drawn to the EPFL policy on academic dishonesty. In particular, you should be aware that copying solutions, in whole or in part, from other students in the class or any other source (e.g., ChatGPT) without acknowledgement constitutes cheating. Any student found to be cheating risks automatically failing the class and being referred to the appropriate office. Page 1 (of 4) CS-251 Theory of Computation • Spring 2025 Homework 3 In the following problems, you may assume the NP-completeness of any of the problems discussed in the lectures: SAT, Independent-Set, Clique, Vertex-Cover, Set-Cover, Subset-Sum, etc. Make sure to prove that your reductions are correct! 1 Let G = (V, E, w) be an undirected graph with edge-weights w : E → Z. A subset M ⊆ E of the edges is a perfect matching if every vertex is incident to exactly one edge in M . In other words, the edges in M pair up all the vertices. The weight of a matching M is the total weight of its edges, that is, ∑e∈M w(e). An example is depicted below. The graph consists of 4 vertices, 5 edges with integer weights, and the thick edges indicate a perfect matching of weight 2 + 3 = 5. 2 4 3 5 1 Show that the following problem is NP-complete: ExactMatch = {⟨G = (V, E, w), k⟩ : G has a perfect matching of weight exactly k} . Page 2 (of 4) CS-251 Theory of Computation • Spring 2025 1 Solution to Question 1 We first need to show that ExactMatch ∈ NP. Given an instance ⟨G = (V, E, w), k⟩ and a certificate consisting of edges M ⊆ E, the verifier first checks if the sum of weights of edges in M is k and then checks that every vertex v occurs in exactly one edge in M . The first operation takes |E| time and the second operation takes |V | · |E| time. Hence the verifier takes time polynomial in the size of the input and so ExactMatch ∈ NP. To show that ExactMatch is NP-hard, we perform the following reduction: SUBSET-SUM ≤p ExactMatch. Given an instance of SUBSET-SUM ⟨S = {s1, · · · , sn}, t⟩, we construct an instance of ExactMatch as follows: For each number si, create 4 vertices vi,1, vi,2, vi,3, vi,4. Connect (vi,1, vi,2) with an edge of weight si; connect (vi,2, vi,3) with an edge of weight 0; connect (vi,3, vi,4) with an edge of weight 0; connect (vi,4, vi,1) with an edge of weight 0. Let G denote the new graph. Then ⟨G, t⟩ is the constructed instance of ExactMatch. For each si, we add 4 vertices and 4 edges to the graph; hence the construction is polynomial time in the size of the input. Claim 1.1. If there is a subset S such that ∑ j∈S sj = t, then G has a perfect matching of size t. Proof. For every i ∈ S, choose the following edges as part of the matching: (vi,1, vi,2) and (vi,3, vi,4). If i /∈ S, then choose (vi,2, vi,3) and (vi,4, vi,1) as part of the matching. It can be seen that this subset of edges is a perfect matching as it covers all the vertices. Furthermore, the only edges contributing to the weight of the matching are (vj,1, vj,2), for every j ∈ S. Therefore, the weight of the matching is t. Claim 1.2. If G has a perfect matching of size t, then there exist a subset S such that ∑j∈S sj = t. Proof. Consider any connected square {vi,1, vi,2, vi,3, vi,4}. Since there are 4 edges in this square, two of these edges will be included in the perfect matching. It will either be (vi,1, vi,2) and (vi,3, vi,4), or (vi,2, vi,3) and (vi,4, vi,1). If (vi,1, vi,2) and (vi,3, vi,4) is part of the matching add i to S, otherwise don’t add it. Since edge (vi,1, vi,2) has weight si, that means that adding i to S results in adding si weight to the subset S. Therefore, the matching of size k implies that the sum of weights of elements in S is also t. Grading scheme: 1.5 point for proof of NP-membership (0.5 for minor inaccuracies and 0.5 for missing running time analysis), 1.5 point for constructing a correct reduction f from an NP-complete problem P to ExactMatch, and 1 point for each direction of the proof that f (x) ∈ ExactMatch iff x ∈ P . 2 Let G = (V, E) be an undirected graph. We say that S ⊆ V is a blocking set if it contains at least one node from each cycle in G. In other words, if we remove the nodes S (and all edges adjacent to S) from G, then we are left with a forest (graph with no cycles). For example, the highlighted nodes below form a blocking set of size 2. Page 3 (of 4) CS-251 Theory of Computation • Spring 2025 Show that the following problem is NP-complete: Block = {⟨G, k⟩ : G is a graph that contains a blocking set of size k}. 2 Solution to Question 2 For NP-membership, let us describe a polynomial-time verifier. As a certificate, it takes a blocking set of size k. Verifier deletes all the vertices from blocking set with their adjacent edges from a graph G, and then checks that G does not contain any cycles (for example, with DFS or BFS). For NP-hardness, let us describe a reduction from Vertex-Cover to Block. Given an instance of Vertex-Cover, ⟨G, k⟩, we map it to an instance of Block, ⟨G′, k⟩. G′ is constructed from G as follows. For every edge e = (v1, v2) ∈ G we have 3 vertices in G′: v1, v2, ve, and we connect each two of them with an edge such that they form a cycle of length 3. Consider a vertex cover of size k in G. Its vertices exactly correspond to a blocking set in G′. Let us note that it is enough for a blocking set to hit at least one vertex in every simple cycle, and from that it follows that it contains at least one node in every cycle. Any cycle in G′ is either a cycle in G or contains a newly introduced vertex ve for some e = (v1, v2). All cycles of the first kind are broken, as vertex cover in G is also a blocking set in G. All cycles of the second kind are also broken, since ve ∈ C ⇒ (v1, ve), (ve, v2) ∈ C for (v1, v2) = e. Since either v1 or v2 belongs to the vertex cover, C is broken. For the other direction, consider a blocking set of size k in G′. Without loss of generality, we can assume that it does not contain any ve for e an edge in G. If it does, simply swap this vertex for any of the two vertices v1, v2 such that (v1, v2) = e ∈ G. After that, the blocking set in G′ exactly corresponds to a vertex cover in G, as for every edge in contains at least one its endpoint. Grading scheme: 1 point for proof of NP-membership (0.5 for minor inaccuracies) and 4 for NP-hardness (3 − 3.5 points for correct reductions with minor inaccuracies in the proof, 0 − 2.5 points for more severe mistakes). Page 4 (of 4) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}