{"path":"Exam/Solutions/examsol2023.pdf","text":"Final Exam, Theory of Computation 2023 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in lectures (but not exercises) including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 15 points / 15 points / 20 points / 20 points / 15 points / 15 points Total / 100 Page 1 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 1 (15 pts) Quick-ﬁre round. Consider the following statements. 1. Every regular language is in P. 2. If A ⊆ B ⊆ C and both A and C are regular, then B is regular. 3. If A and B are regular, then A \\ B = {x : x ∈ A and x /∈ B} is regular. 4. If A ≤m HALT and A ≤m HALT, then A is decidable. 5. If A is recognisable, then A is recognisable. 6. If HALT ≤p A, then A /∈ NP. 7. If A ∈ NP and B ≤p A, then B ∈ NP. 8. Graph-Isomorphism is NP-complete. 9. SAT /∈ coNP. 10. Every CNF formula of size n can be equivalently written as DNF formula of size O(n2). 11. The language {(ab)n : n is divisible by 2023} is regular. 12. The language {⟨M ⟩ : M is a TM that halts on all inputs} is recognisable. 13. The language {⟨ϕ⟩ : ϕ is a CNF such that ϕ(x) = ϕ(x′) for all inputs x, x′} is in NP. 14. The language {⟨p⟩ : p is an n-variate polynomial s.t. p(x) = 0 for some x ∈ Zn} is decidable. 15. The language {⟨D, 1n⟩ : D is a DFA that rejects some n-bit string x ∈ {0, 1}n} is in P. (Compare this to Problems 3 and 5 below! ,) For each box below, write one of the following symbols: − T if the statement is known to be true. − F if the statement is false or not known to be true. E.g., both P = NP and P ̸= NP should be marked F. − or leave the box empty. A correct T/F answer is worth +1 point, an incorrect answer is worth −1 point, and an empty answer is worth 0 points. Solution: 1. T 2. F 3. T 4. T 5. F 6. T 7. T 8. F 9. F 10. F 11. T 12. F 13. F 14. F 15. T Page 2 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 2 (15 pts) Regular languages. Let D = (Q, Σ, δ, q0, F ) be a DFA. Show that L(D) is inﬁnite if and only if D accepts some string x ∈ Σ∗ whose length |x| satisﬁes |Q| ≤ |x| ≤ 2|Q|. Solution: Let us ﬁrst suppose D accepts some string x ∈ ∑∗ whose length satisﬁes |Q| ≤ |x| ≤ 2|Q|. Let m := |x| denote the length of x, and a0, a1, . . . , am denote the states visited when running D with input x. Since m ≥ |Q|, by the pigeonhole principle, there is some state which has been visited at least twice, i.e. there exists 0 ≤ i < j ≤ m s.t. ai = aj. Let x = pqr be a decomposition of x where |p| = i, |q| = j − i, |r| = m − j. Then if we run from the state ai with input y, we will get back to ai. Thus for any k ≥ 0, pqkr ∈ L(D), which implies L(D) is inﬁnite. (The above is essentially the proof of pumping lemma.) Now let us prove the other direction. Suppose that L(D) is inﬁnite. Then there is some x ∈ L(D) of length |x| ≥ |Q|. If |x| ≤ 2|Q|, we are done. Otherwise, using the same argument as above, there is a decomposition of x = pqr, such that |pq| ≤ |Q| and pr ∈ L(D). We then replace x with pr and repeat the above process until we get some x∗ of length at most 2|Q|. We claim that x∗ must have length at least |Q|. This is because if |x∗| < |Q|, then we remove at least |Q| + 1 letters in the last iteration, a contradiction. Therefore, there exists x ∈ L(D) s.t. |Q| ≤ |x| ≤ 2|Q|. Common mistakes and grading scheme: • 7 points for the if direction, 8 points for the only if direction • (if ) -2 points for not showing why there is a cycle. • (if ) -5/6 points for incorrect or very incomplete solutions • (only if ) -1/2 points for small bugs (uncommon) • (only if ) -4/5 points for using the pumping lemma in a wrong way. In fact, one can only apply the pumping lemma to a string of length at least |Q|. Thus the right way to ﬁnd the desired string is to remove cycles instead of adding ones. • (only if ) -6/7 points for answers even farther from the right solution Page 3 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 3 (20 pts) NFAs and NP-completeness. Show that the following language is NP-complete: RNFA = { ⟨N, 1 n⟩ : N is an NFA that rejects some n-bit string x ∈ {0, 1} n}. (Hint: Reduce from SAT: given a CNF formula ϕ over n variables, show how to construct a polynomial-size NFA N such that ϕ(x) = 1 iﬀ N rejects x.) Solution: NP membership. The certiﬁcate for our veriﬁer is the string x ∈ {0, 1}n that is potentially rejected. The veriﬁer checks whether x is indeed rejected. For a DFA this task is trivial, we simply traverse it from the starting state according to the symbols of x and check whether we reached the ﬁnal state. For an NFA this is less trivial, we need to determine whether any accepting state of the NFA is reachable from the starting state if the transitions are made according to x. Let Cl(S) for a set of states S be deﬁned as the set of states reachable from S by ϵ-transitions. Observe that Cl can be computed in linear time in the size of the NFA with depth-ﬁrst-search. Let Si for i ∈ {0, 1, . . . , n} be the set of states reachable from the starting state of the NFA if the transitions are made according to x1 . . . xi. We have S0 = Cl({qstart}). Moreover, Si is computed from Si−1 by Si := Cl(⋃ q∈Si−1 δ(q, xi)). All of this can be done in polynomial time. Then Sn contains accepting states iﬀ the NFA accepts x. Remark: Using a similar idea, one can check whether a DFA rejects any string in {0, 1}n in polynomial time (keep track of a set Si ⊆ Q consisting of the states that are reachable from q0 by some string of length i). Thus RDFA ∈ P, which shows that item 15 in Problem 1 is true. This implies, in particular, that no reduction from SAT to RNFA that constructs a DFA can be correct (unless P = NP). NP hardness. Let φ = ⋀i∈[m] Ci (where [m] = {1, . . . , m}) be a 3-CNF with clauses C1, . . . , Cm. We are going to design an NFA that recognizes the language of assignments x ∈ {0, 1}n that fal- sify φ. First, we construct DFAs N1, . . . , Nm such that Ni recognizes the language {x ∈ {0, 1} | Ci(x) = 0}. Each of those DFAs is going to have n + 2 states. Then we construct an NFA N that recognizes the union of the languages recognized by Ni, which is exactly {x ∈ {0, 1}n | φ(x) = 0}. Then N rejects some string x if and only if φ is satisﬁable. Now we need to check two things: (a) we can indeed construct Ni (b) we can construct a polynomial-size NFA recognising the union of the languages. Notice that step (b) is where this solution fails for DFAs. Part (a). Let Ci = ℓ1 ∨ ℓ2 ∨ ℓ3, where ℓj is a literal (a variable or negation of a variable). Let the set of states of Ni be [n + 1] ∪ {⊥} and let for j ∈ [n], σ ∈ {0, 1} set δ(j, σ) = j + 1 if xj, ¬xj ̸∈ {ℓ1, ℓ2, ℓ3} or if the value σ falsiﬁes the literal of the variable xj appearing in Ci. Otherwise let δ(j, σ) = ⊥. Let 1 be the starting state and n + 1 be the only accepting state. Clearly a word x1, . . . , xj reaches the state j +1 in Ni if and only if none of the values of x1, . . . , xj falsify the corresponding literals of Ci. Part (b). Let us unite the sets of states of N1, . . . , Nm, and add an additional starting state q0, that we connect to the starting state of each of N1, . . . , Nm with an ϵ-transition. The set of accepting states is the union of these sets for N1, . . . , Nm. Grading scheme: Up to 8 points for the NP membership and up to 12 points for reducing SAT to RNFA. Common mistakes and penalties: • (Membership) Not describing how one checks if an NFA accepts or rejects a string: -4 points. Page 4 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 1 2 3 4 5 6 ⊥ 1 0 0 1 1 0 0 1 0 1 Figure 1. An NFA corresponding to a clause x2 ∨ ¬x3 ∨ x5. • (Membership) Giving an exponential-time veriﬁer -3 to -5 points, depending on the reﬂection on the issue above. • (Hardness) Incorrect DFAs for clauses (e.g. assuming that a clause mentions all the variables of the CNF), but correct and well-explained construction for the part (b): -6 points. • (Hardness) Having an exponential blow-up in the reduction: -10 points. If ideas about part (b) are explained, the ﬁne is reduced by 2-3 points. • (Hardness) Severe ﬂaws (-9 to -12 points): – the reduction is in the wrong direction: -12; – the reduction maps a pair (φ, x) to an NFA: -11 (notice that this is a reduction from the problem of checking whether the given assignment satisﬁes the given CNF, not from checking whether such an assignment exists). – the reduction implies P = NP: -10. • (Hardness) Correct reduction that was not clearly explained -1 to -4 points depending on the severity. If what is left vague may lead to one of the issues above, the corresponding ﬁnes above apply. Page 5 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 4 (20 pts) NP-completeness. Let G = (V, E) be an undirected graph. We say that S ⊆ V is a blocking set if it contains at least one node from each cycle in G. In other words, if we remove the nodes S (and all edges adjacent to S) from G, then we are left with a forest (graph with no cycles). For example, the highlighted nodes below form a blocking set of size 2. Show that the following problem is NP-complete: Block = {⟨G, k⟩ : G is a graph that contains a blocking set of of size k}. (You may assume the NP-completeness of any of the problems discussed in the lectures: SAT, Independent-Set, Clique, Vertex-Cover, Set-Cover, Subset-Sum, etc. Make sure to prove that your reduction is correct!) Solution: For NP-membership, let us describe a polynomial-time veriﬁer. As a certiﬁcate, it takes a blocking set of size k. Veriﬁer deletes all the vertices from blocking set with their adjacent edges from a graph G, and then checks that G does not contain any cycles (for example, with DFS or BFS). For NP-hardness, let us describe a reduction from Vertex-Cover to Block. Given an instance of Vertex-Cover, ⟨G, k⟩, we map it to an instance of Block, ⟨G′, k⟩. G′ is constructed from G as follows. For every edge e = (v1, v2) ∈ G we have 3 vertices in G′: v1, v2, ve, and we connect each two of them with an edge such that they form a cycle of length 3. Consider a vertex cover of size k in G. Its vertices exactly correspond to a blocking set in G′. Let us note that it is enough for a blocking set to hit at least one vertex in every simple cycle, and from that it follows that it contains at least one node in every cycle. As vertex cover in G contains as least one endpoint of each edge, in graph G′ this set contains at least one vertex from each cycle of length 3 that we introduced in our reduction. The same is true for the rest of the cycles of the graph G′, as vertex cover in G is also a blocking set in G. For the other direction, consider a blocking set of size k in G′. Without loss of generality, we can assume that it does not contain any ve for e an edge in G. If it does, simply swap this vertex for any of the two vertices v1, v2 such that (v1, v2) = e ∈ G. After that, the blocking set in G′ exactly corresponds to a vertex cover in G, as for every edge in contains at least one its endpoint. Grading scheme: 5 points for proof of NP-membership and 15 for NP-hardness. Partial solution are graded as follows. NP-membership: • 4 points if veriﬁer has minor inaccuracies; • 3 points if veriﬁer is not polynomial (e.g., “ﬁnd all cycles in the graph”), but still works; • 0 − 2 for more serious bugs. Page 6 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös NP-hardness: • 10 points for correct reductions that have moderate bugs in the proof; • 3 − 5 for reductions that do not work, but are in the right direction and show some level of understanding of what it means to construct a reduction and to prove its correctness; • 0 − 2 for more severe mistakes. Page 7 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 5 (15 pts) Undecidability. Consider the language RTM = {⟨M, 1n⟩ : M is a TM that rejects some n-bit string x ∈ {0, 1}n}. Classify RTM as one of (i) decidable, (ii) undecidable but recognisable, (iii) unrecognisable. Justify your answer with a proof. Solution: The correct answer is (ii), RTM is undecidable but recognizable. Part 1. We will prove that RTM is recognizable by providing the following recognizer Mr: Mr(⟨M, 1n⟩): 1. For every l ∈ N and every x ∈ {0, 1}n: (a) Simulate M (x) for l steps. (b) If M rejects within l steps, accept. For every TM M and n ∈ N, if ⟨M, 1n⟩ ∈ RTM, then M must reject some input x ∈ {0, 1}n after a ﬁnite amount of steps k. The recognizer Mr is simulating the TM M on all of the 2n inputs of interest, for an increasing amount of steps, in parallel. When Mr will simulate M for k steps, then M will reject and Mr will accept the input ⟨M, 1n⟩. Apart from that, if it accepts some input ⟨M, 1n⟩, it means that it found M rejecting some x ∈ {0, 1}n, therefore it holds that ⟨M, 1n⟩ ∈ RTM. Part 2. We will prove the undecidability of RTM by proving that HALTTM ≤m RTM. We construct f as follows: f (⟨M, w⟩): 1. Simulate M (w). 2. If M halts on w then reject. We now have to show that ⟨M, w⟩ ∈ ATM ⇔ f (⟨M, w⟩) ∈ RTM (⇒) If ⟨M, w⟩ ∈ HALTTM, this means that M halts on w. Therefore, f (⟨M, w⟩) is a TM that rejects all inputs. As a result, f (⟨M, w⟩) ∈ RTM. (⇐) If T = f (⟨M, w⟩) ∈ RTM, then there exists some x ∈ {0, 1}n for which T rejects x. However, T is a TM that ignores the input and simulates M (w). This means that if T rejected some input, then M must have halted w. Therefore ⟨M, w⟩ ∈ HALTTM. Grading Scheme: Choosing the correct answer takes 3 points and each of the two necessary proofs are awarded 6 points each. Each of the proofs is graded in the following way: • 6 points (out of 6) for a complete and formal proof • 5 points (out of 6) for a formal proof that has minor inaccuracies • 4 points (out of 6) for a proof attempt that has wrong details • 2 points (out of 6) for informal/hand-waving attempts or major mistakes • 0 points (out of 6) for fundamentally ﬂawed hand-waving attempts Page 8 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös In the case of a wrong answer, the attempts are graded in the following way: • 4 points (out of 15) for an almost technically sound proof that is wrong due to small inaccuracies or correct proofs whose implications are interpreted incorrectly. • 2 points (out of 15) for formal proof attempts that have wrong details or wrong assumptions (e.g. using wrong deﬁnitions of languages). • 0 points (out of 15) for no justiﬁcation at all or largely ﬂawed hand-waving arguments Page 9 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös 6 (15 pts) Busy Beaver. Deﬁne the n-th Busy Beaver number, denoted BB(n), as the largest number k ∈ N such that there exists a TM M = (Q, Σ, Γ, δ, q0, qhalt) such that (1) M has |Q| = n + 1 states (that is, n states in addition to its halting state qhalt), (2) M has a binary input/tape alphabet, Σ = Γ = {0, 1}, (3) M , on the empty input ε, halts with 1k written on its tape. In other words, amongst all (n + 1)-state TMs that halt on the empty input, what is the longest all-1 string that it can output? Note that BB(n) is always ﬁnite, as there are only ﬁnitely many distinct TMs satisfying (1)–(3) for any given n. Show that the function BB : N → N is not computable. That is, show that there is no TM that on input n will always halt with BB(n) on its tape. (Hint: If BB were computable, how would you decide the Halting problem? ) Solution: Assume for contradiction that BB is computable and let M be a TM that on input n computes BB(n). Consider a pair ⟨T, w⟩ for which we want to decide whether the TM T halts on input w. Construct a TM N that simulates T on input w step by step while writing a 1 on the tape during every such step. Let n = |Q(N )| be the number of states of the TM N . Note that by the deﬁnition of BB, N cannot write more than BB(n − 1) 1’s on the tape under the condition that it halts. Moreover, N halts if and only if T halts. Hence, BB(n − 1) is also an upper bound on the number of steps T can make under the condition that it halts. We can decide the Halting problem for ⟨T, w⟩ in the following way. Run M (n) to determine the upper bound BB(n − 1). Run T (w) for BB(n − 1) steps. If T (w) halts within BB(n − 1) steps, answer ’yes’ otherwise answer ’no’. By the arguments above, T (w) halts if and only if it halts within BB(n − 1) steps. Grading Scheme: • 15 points for solutions that build N , obtain the upper bound on the number of steps of T (w) and check accordingly. • 8 points if the student simply claims that BB(n) is an upper bound on the number of steps a TM T with |Q| = n + 1 states can make on the empty input. • 7 points if the student simply claims that BB(n) is an upper bound on the number of steps a TM T with |Q| = n + 1 states can make on input w. • 3 points if the student simply runs the TM T and compares the number of 1’s it outputs against some upper bound obtained through BB. • -2 points if mistakes were made when calculating BB(n). In particular, if the student calculated BB(|w|) where |w| does not correspond to the number of states of a TM. • -2 points for incorrect statements such as claiming a TM that halts within k steps on the empty input halts within |w| ∗ k steps on input w. • -2 points if the solution was missing important arguments or contained ﬂawed constructions. • For solutions that tried to give a mapping reduction: 2 points if the student deﬁned a language to reduce to, even if they did not prove that the language is decidable. 2 more points if the reduction is correct or 1 more point if the reduction builds on reasonable ideas. Page 10 (of 10) CS-251 Theory of Computation, Final Exam • Spring 2023 Mika Göös","libVersion":"0.5.0","langs":""}