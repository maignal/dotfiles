{"path":"Lectures/Lecture3.pdf","text":"Non-regular Languages Mika Göös School of Computer and Communication Sciences Lecture 3 Should I stay or should I go (left or right) RECALL: NFAs, Subset Construction Lecture 3 Nondeterminism vs Determinism 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic ﬁnite automaton N1 The difference between a deterministic ﬁnite automatona abbreviated DFAa and a nondeterministic ﬁnite automatona abbreviated NFAais immediately apˆ parent“ Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet“ The NFA shown in Figure —“¨7 violates that rule“ State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1“In an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbol“ Seconda in a DFAalabels on the transition arrows are symbols from the alphaˆ bet“ This NFA has an arrow with the label ε“In generala an NFA may have arrows labeled with members of the alphabet or ε“Zeroa onea or many arrows may exit from each state with the label ε“ How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed“ For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1“After reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallel“ Each copy of the machine takes one of the possible ways to proceed and continues as before“ If there are subsequent choicesa the machine splits again“ If the next input symbol doesn’t appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with it“ Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input string“ If a state with an ε symbol on an exiting arrow is encountereda something similar happens“ Without reading any inputa the machine splits into multiple copiesa one following each of the exiting εˆlabeled arrows and one staying at the current state“ Then the machine proceeds nondeterministically as before“ Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent “processes” or “threads” can be running concurrently“ When the NFA splits to follow several choicesa that corresponds to a process “forking” into several childrena each proceeding separately“ If at least one of these processes acceptsa then the entire computation accepts“ Another way to think of a nondeterministic computation is as a tree of possiˆ bilities“ The root of the tree corresponds to the start of the computation“ Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choices“ The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure —“¨8“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm State diagram of a Nondeterministic Finite Automaton (NFA) Diﬀerences to DFAs: 1 Ability to transition to more than one state on a given symbol Ex: q1 has two outgoing transitions for symbol 1 2 A state may have no transition on a particular symbol Ex: q3 has no outgoing transitions for symbol 0 3 Ability to take a step without reading any input symbol (ε-transitions) Ex: q2 can transition to q3 without reading a symbol Lecture 3 Formal deﬁnitions A nondeterministic ﬁnite automaton (NFA) M is a 5-tuple (Q, Σ, δ, q0, F ), where ▶ Q is a ﬁnite set called the states, ▶ Σ is a ﬁnite set called the alphabet, ▶ δ : Q × (Σ ∪ {ε}) → 2 Q is the transition function, ▶ q0 ∈ Q is the start state, and ▶ F ⊆ Q is the set of accept states. (allow F = ∅) ▶ Here 2Q denotes the power set of Q. Ex: Q = {q1, q2}, 2Q = {∅, {q1}, {q2}, {q1, q2}} ▶ An input is accepted if there exists at least one path that ends at an accepting state ▶ An input is rejected if no computation path end at an accepting state Lecture 3 Example 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic ﬁnite automaton N1 The difference between a deterministic ﬁnite automatona abbreviated DFAa and a nondeterministic ﬁnite automatona abbreviated NFAais immediately apˆ parent“ Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet“ The NFA shown in Figure —“¨7 violates that rule“ State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1“In an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbol“ Seconda in a DFAalabels on the transition arrows are symbols from the alphaˆ bet“ This NFA has an arrow with the label ε“In generala an NFA may have arrows labeled with members of the alphabet or ε“Zeroa onea or many arrows may exit from each state with the label ε“ How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed“ For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1“After reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallel“ Each copy of the machine takes one of the possible ways to proceed and continues as before“ If there are subsequent choicesa the machine splits again“ If the next input symbol doesn’t appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with it“ Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input string“ If a state with an ε symbol on an exiting arrow is encountereda something similar happens“ Without reading any inputa the machine splits into multiple copiesa one following each of the exiting εˆlabeled arrows and one staying at the current state“ Then the machine proceeds nondeterministically as before“ Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent “processes” or “threads” can be running concurrently“ When the NFA splits to follow several choicesa that corresponds to a process “forking” into several childrena each proceeding separately“ If at least one of these processes acceptsa then the entire computation accepts“ Another way to think of a nondeterministic computation is as a tree of possiˆ bilities“ The root of the tree corresponds to the start of the computation“ Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choices“ The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure —“¨8“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm 54 CHAPTER 1 / REGULAR LANGUAGES EXAMPLE 1.38 Recall the NFA N1: The formal description of N1 is (Q, Σ, δ,q1,F )awhere 1. Q = {q1,q2,q3,q4}a 2. Σ = {0,1}a 3. δ is given as 01 ε q1 {q1}{q1,q2} ∅ q2 {q3} ∅ {q3} q3 ∅ {q4} ∅ q4 {q4}{q4} ∅, 4. q1 is the start statea and 5. F = {q4}“ The formal deﬁnition of computation for an NFA is similar to that for a DFA“ Let N =(Q, Σ, δ,q0,F ) be an NFA and w astring over the alphabet Σ“Then we say that N accepts w if we can write w as w = y1y2 ··· ymawhere each yi is a member of Σε and a sequence of states r0,r1,... ,rm exists in Q with three conditions: 1. r0 = q0a 2. ri+1 ∈ δ(ri,yi+1)afor i =0,... ,m − 1aand 3. rm ∈ F “ Condition — says that the machine starts out in the start state“ Condition ¨ says that state ri+1 is one of the allowable next states when N is in state ri and reading yi+1“Observe that δ(ri,yi+1) is the set of allowable next states and so we say that ri+1 is a member of that set“ Finallya condition ´ says that the machine accepts its input if the last state is an accept state“ EQUIVALENCE OF NFAS AND DFAS Deterministic and nondeterministic ﬁnite automata recognize the same class of languages“ Such equivalence is both surprising and useful“ It is surprising beˆ cause NFAsappear to have more power than DFAsa so we might expect that NFAs recognize more languages“ It is useful because describing an NFA for a given language sometimes is much easier than describing a DFA for that language“ Say that two machines are equivalent if they recognize the same language“ ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Lecture 3 Concatenation 1.2 NONDETERMINISM 61 FIGURE 1.48 Construction of N to recognize A1 ◦ A2 PROOF Let N1 =(Q1, Σ, δ1,q1,F1) recognize A1aand N2 =(Q2, Σ, δ2,q2,F2) recognize A2“ Construct N =(Q, Σ, δ,q1,F2) to recognize A1 ◦ A2“ 1. Q = Q1 ∪ Q2“ The states of N are all the states of N1 and N2“ 2. The state q1 is the same as the start state of N1“ 3. The accept states F2 are the same as the accept states of N2“ 4. Deﬁne δ so that for any q ∈ Q and any a ∈ Σεa δ(q, a)= ⎧ ⎪⎪⎪⎨ ⎪⎪⎪⎩ δ1(q, a) q ∈ Q1 and q ̸∈ F1 δ1(q, a) q ∈ F1 and a ̸= ε δ1(q, a) ∪ {q2} q ∈ F1 and a = ε δ2(q, a) q ∈ Q2. ⁄ÉÊÖÈÁ³©Ï_qopq_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³m_¢ÀÀ_·Á³©ÏÎ_·ðÎðÈÑð−m_ﬁ¾Ö_ÃÉÏ_²ð_®ÉÊÁð−k_Î®¾ÃÃð−k_ÉÈ_−ÌÊÀÁ®¾Ïð−k_ÁÃ_Ó©ÉÀð_ÉÈ_ÁÃ_Ê¾ÈÏm_¥Ìð_ÏÉ_ðÀð®ÏÈÉÃÁ®_ÈÁ³©ÏÎk_ÎÉÅð_Ï©ÁÈ−_Ê¾ÈÏÖ_®ÉÃÏðÃÏ_Å¾Ö_²ð_ÎÌÊÊÈðÎÎð−_×ÈÉÅ_Ï©ð_ ð£ÉÉÄ_¾Ã−nÉÈ_ð⁄©¾ÊÏðÈgÎhm_ƒ−ÁÏÉÈÁ¾À_ÈðÑÁðÓ_©¾Î_−ððÅð−_Ï©¾Ï_¾ÃÖ_ÎÌÊÊÈðÎÎð−_®ÉÃÏðÃÏ_−ÉðÎ_ÃÉÏ_Å¾ÏðÈÁ¾ÀÀÖ_¾××ð®Ï_Ï©ð_ÉÑðÈ¾ÀÀ_Àð¾ÈÃÁÃ³_ðÔÊðÈÁðÃ®ðm_⁄ðÃ³¾³ð_›ð¾ÈÃÁÃ³_ÈðÎðÈÑðÎ_Ï©ð_ÈÁ³©Ï_ÏÉ_ÈðÅÉÑð_¾−−ÁÏÁÉÃ¾À_ ®ÉÃÏðÃÏ_¾Ï_¾ÃÖ_ÏÁÅð_Á×_ÎÌ²ÎðËÌðÃÏ_ÈÁ³©ÏÎ_ÈðÎÏÈÁ®ÏÁÉÃÎ_ÈðËÌÁÈð_ÁÏm Lecture 3 Theorem. Every nondeterministic ﬁnite automaton has an equivalent deterministic ﬁnite automaton. Corollary. A language is regular if and only if some nondeterministic ﬁnite automaton recognizes it. Lecture 3 Example p q r 0,1 1 0,1 ˜δ : 2Q × Σ → 2 Q ˜δ(A, a) = ⋃ q∈A δ(q, a) ˜δ 0 1 ∅ ∅ ∅ {p} {p} {p, q} {q} {r } {r } {r } ∅ ∅ {p, q} {p, r } {p, q, r } {p, r } {p} {p, q} {q, r } {r } {r } {p, q, r } {p, r } {p, q, r } {q} {r } {q, r } ∅ 0,1 0,10,1 0,1 {p} {p, q} {p, r } {p,q,r} 0 1 1 0 0 1 0 1 Lecture 3 Is every Language Regular? Lecture 3 What DFAs/NFAs Can Do ▶ Pattern matching ▶ L = {w ∈ {0, 1}∗ | w contains 1011011 as a substring} ▶ Checking parity of numbers, checking divisibility, counting “modulo some number” ▶ L = {w ∈ {0, 1}∗ | #ones(w ) is divisible by 5} ▶ Skipping preﬁxes, suﬃxes, . . . (e.g. 2nd last bit is 1) More generally – “regular” expressions ▶ L = 0∗110∗ − {0n110m | n, m ∈ N} ▶ Closure under complements, unions, intersections, . . . Lecture 3 Test your intuition Are these languages regular? B = {0 n1 n | n ≥ 0} = {ε, 01, 0011, 000111, . . .} C = {w | w has an equal number of 0’s and 1’s} D = {w | w has an equal number of occurrences of 01 and 10 as substrings} Lecture 3 B = {0 n1 n | n ≥ 0} = {ε, 01, 0011, 000111, . . .} is not regular q0 q1 q2 q3 q4 0 00 00000 000 0000 ▶ Suppose on the contrary that B is recognized by a DFA with p states (e.g. p = 5) ▶ Consider what happens when the input is long enough, e.g., 0p ▶ Thus, for two strings 0 i , 0 j , i , j we must end up in the same state ▶ Since 0i 1 i is accepted 0j 1i is also accepted – contradiction! Thus B is NOT regular! Lecture 3 Pumping Lemma and its Proof Sketch If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i ≥ 0, xy i z ∈ A 2 |y | ≥ 1, and 3 |xy | ≤ p. (What if A is ﬁnite?) ▶ Let M = (Q, Σ, δ, q0, F ) s.t. L(M) = A ▶ Consider a string s ∈ A s.t. |s| ≥ |Q| = p ▶ Stop once in a state for the 2nd time, say at times j, k ▶ s = xyz where x is the ﬁrst j letters, y is letter j + 1 to k, z is from k + 1 to end x y z Lecture 3 More formal proof If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i ≥ 0, xy i z ∈ A 2 |y | ≥ 1, and 3 |xy | ≤ p. ▶ Let p = |Q| be the number of states in a DFA M = (Q, Σ, δ, q0, F ) accepting A ▶ Let s be an accepted string of length |s| ≥ p ▶ Let q be the ﬁrst state that is repeated when starting at q0 and feeding s and let x , y , z be the strings s.t. |xy | is minimized and δ(q0, x ) = q and δ(q0, xy ) = q and δ(q, z) = r ∈ F ▶ Then δ(q0, xy i z) = r for all i ≥ 0 ▶ Note that |y | ≥ 1 as there are two distinct occurences of q ▶ |xy | ≤ p by piqeonhole principle and that |xy | equals the number of steps until a state is visited twice. Lecture 3 Applications Lecture 3 F = {ww | w ∈ {0, 1} ∗} F is not regular! Proof: (by contradiction) ▶ Assume F is regular, let p be its pumping length ▶ Pick s = 0 p1 p0p1p ∈ F All strings don’t work! Fun part is guessing which string to pick ▶ Pumping lemma: s = xyz, |xy | ≤ p, |y | ≥ 1, xy i z ∈ F for all i ≥ 0 Pumping lemma tells us there is such a decomposition – we can’t choose it! Your reasoning should work for any decomposition ▶ Since |xy | ≤ p and |y | ≥ 1, y = 0 k for some k > 0 ▶ According to pumping lemma, xy 2z ∈ F ▶ xy 2z = 0p+k 1 p0 p1 p < F ▶ Contradiction! Lecture 3 E = {0m1n | m > n} E is not regular! Proof: (by contradiction) ▶ Assume E is regular, let p be its pumping length ▶ Pick s = 0 p+11 p ∈ E ▶ Pumping lemma: s = xyz, |xy | ≤ p, |y | ≥ 1, xy i z ∈ E for all i ≥ 0 ▶ Since s = 0p+11p, |xy | ≤ p, |y | ≥ 1, we have y = 0 k for some k > 0 ▶ Need to ﬁnd a string of the type xy i z < E for some i ≥ 0 ▶ However, xy 2z = 0 p+k+11p, xy 3z = 0 p+2k+11p, . . . ∈ E ▶ Try i = 0. According to pumping lemma, xy 0z = xz ∈ E ▶ But xz = 0p+1−k 1 p and p + 1 − k ≤ p. Thus, xz < E . Contradiction! Lecture 3 C = {w | w has equal number of 0’s and 1’s} C is not regular! Reduction from B = {0 n1 n | n ≥ 0} ▶ B ⊆ C and B is non-regular does not imply C is non-regular. . . ▶ e.g. B ⊆ {0, 1} ∗ as well but {0, 1} ∗ is regular! ▶ However we can still use non-regularity of B Proof: (by contradiction) ▶ Assume C is regular ▶ Let 0∗1∗ = {0 m1n | m, n ≥ 0} ▶ 0∗1 ∗ is regular 𝐵𝐵 ⊆𝐶𝐶 and 𝐵𝐵 is non-regular does not imply 𝐶𝐶 is non-regular ... e.g. 𝐵𝐵 ⊆{0,1} ⋆as well but {0,1}⋆is regular! However we can still use non-regularity of 𝑩𝑩! Proof (by CONTRADICTION) 1. Assume 𝐶𝐶 is regular 2. Let 0⋆1⋆= {0𝑚𝑚1𝑛𝑛: 𝑚𝑚, 𝑐𝑐 ≥0} 3. 0⋆1⋆is regular 4. Claim: 𝑩𝑩 = 𝑪𝑪 ∩(𝟎𝟎 ⋆𝟏𝟏 ⋆) 5. Intersection of two regular languages is regular 6. 𝐵𝐵 is regular – a contradiction! 𝐶𝐶 = {𝑤𝑤| 𝑤𝑤has equal number of 0’s and 1’s } 𝐶𝐶 is not regular! Reduction from 𝐵𝐵 = 0𝑛𝑛1𝑛𝑛 | 𝑐𝑐 ≥0 ▶ Claim: B = C ∩ (0∗1 ∗) ▶ Intersection of two regular languages is regular ▶ ⇒ B is regular – a contradiction! Lecture 3 C = {w | w has equal number of 0’s and 1’s} C is not regular! (Proof using Pumping Lemma) Proof: (by contradiction) ▶ Assume C is regular, let p be the pumping length ▶ We need to ﬁnd a string which cannot be “pumped” ▶ Try s = 010101010101 = (01)p ▶ s = xyz with |xy | ≤ p, |y | ≥ 1 and xy i z ∈ C for every i ≥ 0 ▶ What if x = ε and y = 01 then indeed xy i z ∈ C ? ▶ Our choice of s gives no contradiction! ▶ Try s = 0 p1 p ▶ s = xyz with |xy | ≤ p, |y | ≥ 1 and xy i z ∈ C for every i ≥ 0 ▶ In every possible case y is composed of 0s only! ▶ Say y = 0k for some k > 0 then xy 2z = 0p+k 1p < C ▶ Contradiction! Lecture 3 Assume L is regular Let’s try to use the Pumping Lemma Task: Prove that L is not regular .. p : the pumping length Pick s in L with |s| ≥ p s=xyz s.t. |xy|≤ p and |y|≥1 and 𝑥𝑥𝑏𝑏𝑖𝑖𝑧𝑧 ∈𝐿𝐿∀𝑐𝑐≥0 xz, xyyz,xyyyz,xyyyyz,… If one of them NOT in L – DONE! If all of them in L – Try again! Your reasoning should work for any decomposition Fun part is guessing which string to pick! Lecture 3 Test your intuition. . . D = {w | w has equal nr of occurrences of 01 and 10 as substrings} D is regular! Test your intuition .. 𝐷𝐷= { 𝑤𝑤| 𝑤𝑤has an equal number of occurences of 01 and 10 as substrings } Define 𝑁𝑁1(w) ∶= number of occurences of 01 in w 𝑁𝑁2(𝑤𝑤) ≔ number of occurences of 10 in 𝑤𝑤 Observation: 𝑁𝑁1 𝑤𝑤 −𝑁𝑁2(𝑤𝑤) ∈{0,1} Example: 𝑤𝑤= 001011101001 𝑁𝑁1 𝑤𝑤 = 4, 𝑁𝑁2 𝑤𝑤 = 3 𝑤𝑤 ′= 1000101101 𝑁𝑁1 𝑤𝑤𝑤= 𝑁𝑁2 𝑤𝑤𝑤= 3 If the starting and the ending symbols are the same then 𝑵𝑵𝟏𝟏 𝒘𝒘 −𝑵𝑵𝟐𝟐(𝒘𝒘) =0 otherwise 𝑵𝑵𝟏𝟏 𝒘𝒘 −𝑵𝑵𝟐𝟐(𝒘𝒘) =1 Lecture 3 Beyond Regular Languages Turing Machines . . . Lecture 3","libVersion":"0.5.0","langs":""}