{"path":"Lectures/Lecture3.pdf","text":"Non-regular Languages Mika G√∂√∂s School of Computer and Communication Sciences Lecture 3 Should I stay or should I go (left or right) RECALL: NFAs, Subset Construction Lecture 3 Nondeterminism vs Determinism 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic Ô¨Ånite automaton N1 The difference between a deterministic Ô¨Ånite automatona abbreviated DFAa and a nondeterministic Ô¨Ånite automatona abbreviated NFAais immediately apÀÜ parent‚Äú Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet‚Äú The NFA shown in Figure ‚Äî‚Äú¬®7 violates that rule‚Äú State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1‚ÄúIn an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbol‚Äú Seconda in a DFAalabels on the transition arrows are symbols from the alphaÀÜ bet‚Äú This NFA has an arrow with the label Œµ‚ÄúIn generala an NFA may have arrows labeled with members of the alphabet or Œµ‚ÄúZeroa onea or many arrows may exit from each state with the label Œµ‚Äú How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed‚Äú For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1‚ÄúAfter reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallel‚Äú Each copy of the machine takes one of the possible ways to proceed and continues as before‚Äú If there are subsequent choicesa the machine splits again‚Äú If the next input symbol doesn‚Äôt appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with it‚Äú Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input string‚Äú If a state with an Œµ symbol on an exiting arrow is encountereda something similar happens‚Äú Without reading any inputa the machine splits into multiple copiesa one following each of the exiting ŒµÀÜlabeled arrows and one staying at the current state‚Äú Then the machine proceeds nondeterministically as before‚Äú Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent ‚Äúprocesses‚Äù or ‚Äúthreads‚Äù can be running concurrently‚Äú When the NFA splits to follow several choicesa that corresponds to a process ‚Äúforking‚Äù into several childrena each proceeding separately‚Äú If at least one of these processes acceptsa then the entire computation accepts‚Äú Another way to think of a nondeterministic computation is as a tree of possiÀÜ bilities‚Äú The root of the tree corresponds to the start of the computation‚Äú Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choices‚Äú The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure ‚Äî‚Äú¬®8‚Äú ‚ÅÑ√â√ä√ñ√à√Å¬≥¬©√è_qopq_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥m_¬¢√Ä√Ä_¬∑√Å¬≥¬©√è√é_¬∑√∞√é√∞√à√ë√∞‚àím_Ô¨Å¬æ√ñ_√É√â√è_¬≤√∞_¬Æ√â√ä√Å√∞‚àík_√é¬Æ¬æ√É√É√∞‚àík_√â√à_‚àí√å√ä√Ä√Å¬Æ¬æ√è√∞‚àík_√Å√É_√ì¬©√â√Ä√∞_√â√à_√Å√É_√ä¬æ√à√èm_¬•√å√∞_√è√â_√∞√Ä√∞¬Æ√è√à√â√É√Å¬Æ_√à√Å¬≥¬©√è√ék_√é√â√Ö√∞_√è¬©√Å√à‚àí_√ä¬æ√à√è√ñ_¬Æ√â√É√è√∞√É√è_√Ö¬æ√ñ_¬≤√∞_√é√å√ä√ä√à√∞√é√é√∞‚àí_√ó√à√â√Ö_√è¬©√∞_ √∞¬£√â√â√Ñ_¬æ√É‚àín√â√à_√∞‚ÅÑ¬©¬æ√ä√è√∞√àg√éhm_∆í‚àí√Å√è√â√à√Å¬æ√Ä_√à√∞√ë√Å√∞√ì_¬©¬æ√é_‚àí√∞√∞√Ö√∞‚àí_√è¬©¬æ√è_¬æ√É√ñ_√é√å√ä√ä√à√∞√é√é√∞‚àí_¬Æ√â√É√è√∞√É√è_‚àí√â√∞√é_√É√â√è_√Ö¬æ√è√∞√à√Å¬æ√Ä√Ä√ñ_¬æ√ó√ó√∞¬Æ√è_√è¬©√∞_√â√ë√∞√à¬æ√Ä√Ä_√Ä√∞¬æ√à√É√Å√É¬≥_√∞√î√ä√∞√à√Å√∞√É¬Æ√∞m_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥_√à√∞√é√∞√à√ë√∞√é_√è¬©√∞_√à√Å¬≥¬©√è_√è√â_√à√∞√Ö√â√ë√∞_¬æ‚àí‚àí√Å√è√Å√â√É¬æ√Ä_ ¬Æ√â√É√è√∞√É√è_¬æ√è_¬æ√É√ñ_√è√Å√Ö√∞_√Å√ó_√é√å¬≤√é√∞√ã√å√∞√É√è_√à√Å¬≥¬©√è√é_√à√∞√é√è√à√Å¬Æ√è√Å√â√É√é_√à√∞√ã√å√Å√à√∞_√Å√èm State diagram of a Nondeterministic Finite Automaton (NFA) DiÔ¨Äerences to DFAs: 1 Ability to transition to more than one state on a given symbol Ex: q1 has two outgoing transitions for symbol 1 2 A state may have no transition on a particular symbol Ex: q3 has no outgoing transitions for symbol 0 3 Ability to take a step without reading any input symbol (Œµ-transitions) Ex: q2 can transition to q3 without reading a symbol Lecture 3 Formal deÔ¨Ånitions A nondeterministic Ô¨Ånite automaton (NFA) M is a 5-tuple (Q, Œ£, Œ¥, q0, F ), where ‚ñ∂ Q is a Ô¨Ånite set called the states, ‚ñ∂ Œ£ is a Ô¨Ånite set called the alphabet, ‚ñ∂ Œ¥ : Q √ó (Œ£ ‚à™ {Œµ}) ‚Üí 2 Q is the transition function, ‚ñ∂ q0 ‚àà Q is the start state, and ‚ñ∂ F ‚äÜ Q is the set of accept states. (allow F = ‚àÖ) ‚ñ∂ Here 2Q denotes the power set of Q. Ex: Q = {q1, q2}, 2Q = {‚àÖ, {q1}, {q2}, {q1, q2}} ‚ñ∂ An input is accepted if there exists at least one path that ends at an accepting state ‚ñ∂ An input is rejected if no computation path end at an accepting state Lecture 3 Example 48 CHAPTER 1 / REGULAR LANGUAGES FIGURE 1.27 The nondeterministic Ô¨Ånite automaton N1 The difference between a deterministic Ô¨Ånite automatona abbreviated DFAa and a nondeterministic Ô¨Ånite automatona abbreviated NFAais immediately apÀÜ parent‚Äú Firsta every state of a DFA always has exactly one exiting transition arrow for each symbol in the alphabet‚Äú The NFA shown in Figure ‚Äî‚Äú¬®7 violates that rule‚Äú State q1 has one exiting arrow for 0abut it has two for 1; q2 has one arrow for 0abut it has none for 1‚ÄúIn an NFAaa state may have zeroa onea or many exiting arrows for each alphabet symbol‚Äú Seconda in a DFAalabels on the transition arrows are symbols from the alphaÀÜ bet‚Äú This NFA has an arrow with the label Œµ‚ÄúIn generala an NFA may have arrows labeled with members of the alphabet or Œµ‚ÄúZeroa onea or many arrows may exit from each state with the label Œµ‚Äú How does an NFA compute? Suppose that we are running an NFA on an input string and come to a state with multiple ways to proceed‚Äú For examplea say that we are in state q1 in NFA N1 and that the next input symbol is a 1‚ÄúAfter reading that symbola the machine splits into multiple copies of itself and follows all the possibilities in parallel‚Äú Each copy of the machine takes one of the possible ways to proceed and continues as before‚Äú If there are subsequent choicesa the machine splits again‚Äú If the next input symbol doesn‚Äôt appear on any of the arrows exiting the state occupied by a copy of the machinea that copy of the machine diesa along with the branch of the computation associated with it‚Äú Finallya if any one of these copies of the machine is in an accept state at the end of the inputa the NFA accepts the input string‚Äú If a state with an Œµ symbol on an exiting arrow is encountereda something similar happens‚Äú Without reading any inputa the machine splits into multiple copiesa one following each of the exiting ŒµÀÜlabeled arrows and one staying at the current state‚Äú Then the machine proceeds nondeterministically as before‚Äú Nondeterminism may be viewed as a kind of parallel computation wherein multiple independent ‚Äúprocesses‚Äù or ‚Äúthreads‚Äù can be running concurrently‚Äú When the NFA splits to follow several choicesa that corresponds to a process ‚Äúforking‚Äù into several childrena each proceeding separately‚Äú If at least one of these processes acceptsa then the entire computation accepts‚Äú Another way to think of a nondeterministic computation is as a tree of possiÀÜ bilities‚Äú The root of the tree corresponds to the start of the computation‚Äú Every branching point in the tree corresponds to a point in the computation at which the machine has multiple choices‚Äú The machine accepts if at least one of the computation branches ends in an accept statea as shown in Figure ‚Äî‚Äú¬®8‚Äú ‚ÅÑ√â√ä√ñ√à√Å¬≥¬©√è_qopq_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥m_¬¢√Ä√Ä_¬∑√Å¬≥¬©√è√é_¬∑√∞√é√∞√à√ë√∞‚àím_Ô¨Å¬æ√ñ_√É√â√è_¬≤√∞_¬Æ√â√ä√Å√∞‚àík_√é¬Æ¬æ√É√É√∞‚àík_√â√à_‚àí√å√ä√Ä√Å¬Æ¬æ√è√∞‚àík_√Å√É_√ì¬©√â√Ä√∞_√â√à_√Å√É_√ä¬æ√à√èm_¬•√å√∞_√è√â_√∞√Ä√∞¬Æ√è√à√â√É√Å¬Æ_√à√Å¬≥¬©√è√ék_√é√â√Ö√∞_√è¬©√Å√à‚àí_√ä¬æ√à√è√ñ_¬Æ√â√É√è√∞√É√è_√Ö¬æ√ñ_¬≤√∞_√é√å√ä√ä√à√∞√é√é√∞‚àí_√ó√à√â√Ö_√è¬©√∞_ √∞¬£√â√â√Ñ_¬æ√É‚àín√â√à_√∞‚ÅÑ¬©¬æ√ä√è√∞√àg√éhm_∆í‚àí√Å√è√â√à√Å¬æ√Ä_√à√∞√ë√Å√∞√ì_¬©¬æ√é_‚àí√∞√∞√Ö√∞‚àí_√è¬©¬æ√è_¬æ√É√ñ_√é√å√ä√ä√à√∞√é√é√∞‚àí_¬Æ√â√É√è√∞√É√è_‚àí√â√∞√é_√É√â√è_√Ö¬æ√è√∞√à√Å¬æ√Ä√Ä√ñ_¬æ√ó√ó√∞¬Æ√è_√è¬©√∞_√â√ë√∞√à¬æ√Ä√Ä_√Ä√∞¬æ√à√É√Å√É¬≥_√∞√î√ä√∞√à√Å√∞√É¬Æ√∞m_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥_√à√∞√é√∞√à√ë√∞√é_√è¬©√∞_√à√Å¬≥¬©√è_√è√â_√à√∞√Ö√â√ë√∞_¬æ‚àí‚àí√Å√è√Å√â√É¬æ√Ä_ ¬Æ√â√É√è√∞√É√è_¬æ√è_¬æ√É√ñ_√è√Å√Ö√∞_√Å√ó_√é√å¬≤√é√∞√ã√å√∞√É√è_√à√Å¬≥¬©√è√é_√à√∞√é√è√à√Å¬Æ√è√Å√â√É√é_√à√∞√ã√å√Å√à√∞_√Å√èm 54 CHAPTER 1 / REGULAR LANGUAGES EXAMPLE 1.38 Recall the NFA N1: The formal description of N1 is (Q, Œ£, Œ¥,q1,F )awhere 1. Q = {q1,q2,q3,q4}a 2. Œ£ = {0,1}a 3. Œ¥ is given as 01 Œµ q1 {q1}{q1,q2} ‚àÖ q2 {q3} ‚àÖ {q3} q3 ‚àÖ {q4} ‚àÖ q4 {q4}{q4} ‚àÖ, 4. q1 is the start statea and 5. F = {q4}‚Äú The formal deÔ¨Ånition of computation for an NFA is similar to that for a DFA‚Äú Let N =(Q, Œ£, Œ¥,q0,F ) be an NFA and w astring over the alphabet Œ£‚ÄúThen we say that N accepts w if we can write w as w = y1y2 ¬∑¬∑¬∑ ymawhere each yi is a member of Œ£Œµ and a sequence of states r0,r1,... ,rm exists in Q with three conditions: 1. r0 = q0a 2. ri+1 ‚àà Œ¥(ri,yi+1)afor i =0,... ,m ‚àí 1aand 3. rm ‚àà F ‚Äú Condition ‚Äî says that the machine starts out in the start state‚Äú Condition ¬® says that state ri+1 is one of the allowable next states when N is in state ri and reading yi+1‚ÄúObserve that Œ¥(ri,yi+1) is the set of allowable next states and so we say that ri+1 is a member of that set‚Äú Finallya condition ¬¥ says that the machine accepts its input if the last state is an accept state‚Äú EQUIVALENCE OF NFAS AND DFAS Deterministic and nondeterministic Ô¨Ånite automata recognize the same class of languages‚Äú Such equivalence is both surprising and useful‚Äú It is surprising beÀÜ cause NFAsappear to have more power than DFAsa so we might expect that NFAs recognize more languages‚Äú It is useful because describing an NFA for a given language sometimes is much easier than describing a DFA for that language‚Äú Say that two machines are equivalent if they recognize the same language‚Äú ‚ÅÑ√â√ä√ñ√à√Å¬≥¬©√è_qopq_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥m_¬¢√Ä√Ä_¬∑√Å¬≥¬©√è√é_¬∑√∞√é√∞√à√ë√∞‚àím_Ô¨Å¬æ√ñ_√É√â√è_¬≤√∞_¬Æ√â√ä√Å√∞‚àík_√é¬Æ¬æ√É√É√∞‚àík_√â√à_‚àí√å√ä√Ä√Å¬Æ¬æ√è√∞‚àík_√Å√É_√ì¬©√â√Ä√∞_√â√à_√Å√É_√ä¬æ√à√èm_¬•√å√∞_√è√â_√∞√Ä√∞¬Æ√è√à√â√É√Å¬Æ_√à√Å¬≥¬©√è√ék_√é√â√Ö√∞_√è¬©√Å√à‚àí_√ä¬æ√à√è√ñ_¬Æ√â√É√è√∞√É√è_√Ö¬æ√ñ_¬≤√∞_√é√å√ä√ä√à√∞√é√é√∞‚àí_√ó√à√â√Ö_√è¬©√∞_ √∞¬£√â√â√Ñ_¬æ√É‚àín√â√à_√∞‚ÅÑ¬©¬æ√ä√è√∞√àg√éhm_∆í‚àí√Å√è√â√à√Å¬æ√Ä_√à√∞√ë√Å√∞√ì_¬©¬æ√é_‚àí√∞√∞√Ö√∞‚àí_√è¬©¬æ√è_¬æ√É√ñ_√é√å√ä√ä√à√∞√é√é√∞‚àí_¬Æ√â√É√è√∞√É√è_‚àí√â√∞√é_√É√â√è_√Ö¬æ√è√∞√à√Å¬æ√Ä√Ä√ñ_¬æ√ó√ó√∞¬Æ√è_√è¬©√∞_√â√ë√∞√à¬æ√Ä√Ä_√Ä√∞¬æ√à√É√Å√É¬≥_√∞√î√ä√∞√à√Å√∞√É¬Æ√∞m_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥_√à√∞√é√∞√à√ë√∞√é_√è¬©√∞_√à√Å¬≥¬©√è_√è√â_√à√∞√Ö√â√ë√∞_¬æ‚àí‚àí√Å√è√Å√â√É¬æ√Ä_ ¬Æ√â√É√è√∞√É√è_¬æ√è_¬æ√É√ñ_√è√Å√Ö√∞_√Å√ó_√é√å¬≤√é√∞√ã√å√∞√É√è_√à√Å¬≥¬©√è√é_√à√∞√é√è√à√Å¬Æ√è√Å√â√É√é_√à√∞√ã√å√Å√à√∞_√Å√èm Lecture 3 Concatenation 1.2 NONDETERMINISM 61 FIGURE 1.48 Construction of N to recognize A1 ‚ó¶ A2 PROOF Let N1 =(Q1, Œ£, Œ¥1,q1,F1) recognize A1aand N2 =(Q2, Œ£, Œ¥2,q2,F2) recognize A2‚Äú Construct N =(Q, Œ£, Œ¥,q1,F2) to recognize A1 ‚ó¶ A2‚Äú 1. Q = Q1 ‚à™ Q2‚Äú The states of N are all the states of N1 and N2‚Äú 2. The state q1 is the same as the start state of N1‚Äú 3. The accept states F2 are the same as the accept states of N2‚Äú 4. DeÔ¨Åne Œ¥ so that for any q ‚àà Q and any a ‚àà Œ£Œµa Œ¥(q, a)= ‚éß ‚é™‚é™‚é™‚é® ‚é™‚é™‚é™‚é© Œ¥1(q, a) q ‚àà Q1 and q Ã∏‚àà F1 Œ¥1(q, a) q ‚àà F1 and a Ã∏= Œµ Œ¥1(q, a) ‚à™ {q2} q ‚àà F1 and a = Œµ Œ¥2(q, a) q ‚àà Q2. ‚ÅÑ√â√ä√ñ√à√Å¬≥¬©√è_qopq_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥m_¬¢√Ä√Ä_¬∑√Å¬≥¬©√è√é_¬∑√∞√é√∞√à√ë√∞‚àím_Ô¨Å¬æ√ñ_√É√â√è_¬≤√∞_¬Æ√â√ä√Å√∞‚àík_√é¬Æ¬æ√É√É√∞‚àík_√â√à_‚àí√å√ä√Ä√Å¬Æ¬æ√è√∞‚àík_√Å√É_√ì¬©√â√Ä√∞_√â√à_√Å√É_√ä¬æ√à√èm_¬•√å√∞_√è√â_√∞√Ä√∞¬Æ√è√à√â√É√Å¬Æ_√à√Å¬≥¬©√è√ék_√é√â√Ö√∞_√è¬©√Å√à‚àí_√ä¬æ√à√è√ñ_¬Æ√â√É√è√∞√É√è_√Ö¬æ√ñ_¬≤√∞_√é√å√ä√ä√à√∞√é√é√∞‚àí_√ó√à√â√Ö_√è¬©√∞_ √∞¬£√â√â√Ñ_¬æ√É‚àín√â√à_√∞‚ÅÑ¬©¬æ√ä√è√∞√àg√éhm_∆í‚àí√Å√è√â√à√Å¬æ√Ä_√à√∞√ë√Å√∞√ì_¬©¬æ√é_‚àí√∞√∞√Ö√∞‚àí_√è¬©¬æ√è_¬æ√É√ñ_√é√å√ä√ä√à√∞√é√é√∞‚àí_¬Æ√â√É√è√∞√É√è_‚àí√â√∞√é_√É√â√è_√Ö¬æ√è√∞√à√Å¬æ√Ä√Ä√ñ_¬æ√ó√ó√∞¬Æ√è_√è¬©√∞_√â√ë√∞√à¬æ√Ä√Ä_√Ä√∞¬æ√à√É√Å√É¬≥_√∞√î√ä√∞√à√Å√∞√É¬Æ√∞m_‚ÅÑ√∞√É¬≥¬æ¬≥√∞_‚Ä∫√∞¬æ√à√É√Å√É¬≥_√à√∞√é√∞√à√ë√∞√é_√è¬©√∞_√à√Å¬≥¬©√è_√è√â_√à√∞√Ö√â√ë√∞_¬æ‚àí‚àí√Å√è√Å√â√É¬æ√Ä_ ¬Æ√â√É√è√∞√É√è_¬æ√è_¬æ√É√ñ_√è√Å√Ö√∞_√Å√ó_√é√å¬≤√é√∞√ã√å√∞√É√è_√à√Å¬≥¬©√è√é_√à√∞√é√è√à√Å¬Æ√è√Å√â√É√é_√à√∞√ã√å√Å√à√∞_√Å√èm Lecture 3 Theorem. Every nondeterministic Ô¨Ånite automaton has an equivalent deterministic Ô¨Ånite automaton. Corollary. A language is regular if and only if some nondeterministic Ô¨Ånite automaton recognizes it. Lecture 3 Example p q r 0,1 1 0,1 ÀúŒ¥ : 2Q √ó Œ£ ‚Üí 2 Q ÀúŒ¥(A, a) = ‚ãÉ q‚ààA Œ¥(q, a) ÀúŒ¥ 0 1 ‚àÖ ‚àÖ ‚àÖ {p} {p} {p, q} {q} {r } {r } {r } ‚àÖ ‚àÖ {p, q} {p, r } {p, q, r } {p, r } {p} {p, q} {q, r } {r } {r } {p, q, r } {p, r } {p, q, r } {q} {r } {q, r } ‚àÖ 0,1 0,10,1 0,1 {p} {p, q} {p, r } {p,q,r} 0 1 1 0 0 1 0 1 Lecture 3 Is every Language Regular? Lecture 3 What DFAs/NFAs Can Do ‚ñ∂ Pattern matching ‚ñ∂ L = {w ‚àà {0, 1}‚àó | w contains 1011011 as a substring} ‚ñ∂ Checking parity of numbers, checking divisibility, counting ‚Äúmodulo some number‚Äù ‚ñ∂ L = {w ‚àà {0, 1}‚àó | #ones(w ) is divisible by 5} ‚ñ∂ Skipping preÔ¨Åxes, suÔ¨Éxes, . . . (e.g. 2nd last bit is 1) More generally ‚Äì ‚Äúregular‚Äù expressions ‚ñ∂ L = 0‚àó110‚àó ‚àí {0n110m | n, m ‚àà N} ‚ñ∂ Closure under complements, unions, intersections, . . . Lecture 3 Test your intuition Are these languages regular? B = {0 n1 n | n ‚â• 0} = {Œµ, 01, 0011, 000111, . . .} C = {w | w has an equal number of 0‚Äôs and 1‚Äôs} D = {w | w has an equal number of occurrences of 01 and 10 as substrings} Lecture 3 B = {0 n1 n | n ‚â• 0} = {Œµ, 01, 0011, 000111, . . .} is not regular q0 q1 q2 q3 q4 0 00 00000 000 0000 ‚ñ∂ Suppose on the contrary that B is recognized by a DFA with p states (e.g. p = 5) ‚ñ∂ Consider what happens when the input is long enough, e.g., 0p ‚ñ∂ Thus, for two strings 0 i , 0 j , i , j we must end up in the same state ‚ñ∂ Since 0i 1 i is accepted 0j 1i is also accepted ‚Äì contradiction! Thus B is NOT regular! Lecture 3 Pumping Lemma and its Proof Sketch If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i ‚â• 0, xy i z ‚àà A 2 |y | ‚â• 1, and 3 |xy | ‚â§ p. (What if A is Ô¨Ånite?) ‚ñ∂ Let M = (Q, Œ£, Œ¥, q0, F ) s.t. L(M) = A ‚ñ∂ Consider a string s ‚àà A s.t. |s| ‚â• |Q| = p ‚ñ∂ Stop once in a state for the 2nd time, say at times j, k ‚ñ∂ s = xyz where x is the Ô¨Årst j letters, y is letter j + 1 to k, z is from k + 1 to end x y z Lecture 3 More formal proof If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. 1 for each i ‚â• 0, xy i z ‚àà A 2 |y | ‚â• 1, and 3 |xy | ‚â§ p. ‚ñ∂ Let p = |Q| be the number of states in a DFA M = (Q, Œ£, Œ¥, q0, F ) accepting A ‚ñ∂ Let s be an accepted string of length |s| ‚â• p ‚ñ∂ Let q be the Ô¨Årst state that is repeated when starting at q0 and feeding s and let x , y , z be the strings s.t. |xy | is minimized and Œ¥(q0, x ) = q and Œ¥(q0, xy ) = q and Œ¥(q, z) = r ‚àà F ‚ñ∂ Then Œ¥(q0, xy i z) = r for all i ‚â• 0 ‚ñ∂ Note that |y | ‚â• 1 as there are two distinct occurences of q ‚ñ∂ |xy | ‚â§ p by piqeonhole principle and that |xy | equals the number of steps until a state is visited twice. Lecture 3 Applications Lecture 3 F = {ww | w ‚àà {0, 1} ‚àó} F is not regular! Proof: (by contradiction) ‚ñ∂ Assume F is regular, let p be its pumping length ‚ñ∂ Pick s = 0 p1 p0p1p ‚àà F All strings don‚Äôt work! Fun part is guessing which string to pick ‚ñ∂ Pumping lemma: s = xyz, |xy | ‚â§ p, |y | ‚â• 1, xy i z ‚àà F for all i ‚â• 0 Pumping lemma tells us there is such a decomposition ‚Äì we can‚Äôt choose it! Your reasoning should work for any decomposition ‚ñ∂ Since |xy | ‚â§ p and |y | ‚â• 1, y = 0 k for some k > 0 ‚ñ∂ According to pumping lemma, xy 2z ‚àà F ‚ñ∂ xy 2z = 0p+k 1 p0 p1 p < F ‚ñ∂ Contradiction! Lecture 3 E = {0m1n | m > n} E is not regular! Proof: (by contradiction) ‚ñ∂ Assume E is regular, let p be its pumping length ‚ñ∂ Pick s = 0 p+11 p ‚àà E ‚ñ∂ Pumping lemma: s = xyz, |xy | ‚â§ p, |y | ‚â• 1, xy i z ‚àà E for all i ‚â• 0 ‚ñ∂ Since s = 0p+11p, |xy | ‚â§ p, |y | ‚â• 1, we have y = 0 k for some k > 0 ‚ñ∂ Need to Ô¨Ånd a string of the type xy i z < E for some i ‚â• 0 ‚ñ∂ However, xy 2z = 0 p+k+11p, xy 3z = 0 p+2k+11p, . . . ‚àà E ‚ñ∂ Try i = 0. According to pumping lemma, xy 0z = xz ‚àà E ‚ñ∂ But xz = 0p+1‚àík 1 p and p + 1 ‚àí k ‚â§ p. Thus, xz < E . Contradiction! Lecture 3 C = {w | w has equal number of 0‚Äôs and 1‚Äôs} C is not regular! Reduction from B = {0 n1 n | n ‚â• 0} ‚ñ∂ B ‚äÜ C and B is non-regular does not imply C is non-regular. . . ‚ñ∂ e.g. B ‚äÜ {0, 1} ‚àó as well but {0, 1} ‚àó is regular! ‚ñ∂ However we can still use non-regularity of B Proof: (by contradiction) ‚ñ∂ Assume C is regular ‚ñ∂ Let 0‚àó1‚àó = {0 m1n | m, n ‚â• 0} ‚ñ∂ 0‚àó1 ‚àó is regular ùêµùêµ ‚äÜùê∂ùê∂ and ùêµùêµ is non-regular does not imply ùê∂ùê∂ is non-regular ... e.g. ùêµùêµ ‚äÜ{0,1} ‚ãÜas well but {0,1}‚ãÜis regular! However we can still use non-regularity of ùë©ùë©! Proof (by CONTRADICTION) 1. Assume ùê∂ùê∂ is regular 2. Let 0‚ãÜ1‚ãÜ= {0ùëöùëö1ùëõùëõ: ùëöùëö, ùëêùëê ‚â•0} 3. 0‚ãÜ1‚ãÜis regular 4. Claim: ùë©ùë© = ùë™ùë™ ‚à©(ùüéùüé ‚ãÜùüèùüè ‚ãÜ) 5. Intersection of two regular languages is regular 6. ùêµùêµ is regular ‚Äì a contradiction! ùê∂ùê∂ = {ùë§ùë§| ùë§ùë§has equal number of 0‚Äôs and 1‚Äôs } ùê∂ùê∂ is not regular! Reduction from ùêµùêµ = 0ùëõùëõ1ùëõùëõ | ùëêùëê ‚â•0 ‚ñ∂ Claim: B = C ‚à© (0‚àó1 ‚àó) ‚ñ∂ Intersection of two regular languages is regular ‚ñ∂ ‚áí B is regular ‚Äì a contradiction! Lecture 3 C = {w | w has equal number of 0‚Äôs and 1‚Äôs} C is not regular! (Proof using Pumping Lemma) Proof: (by contradiction) ‚ñ∂ Assume C is regular, let p be the pumping length ‚ñ∂ We need to Ô¨Ånd a string which cannot be ‚Äúpumped‚Äù ‚ñ∂ Try s = 010101010101 = (01)p ‚ñ∂ s = xyz with |xy | ‚â§ p, |y | ‚â• 1 and xy i z ‚àà C for every i ‚â• 0 ‚ñ∂ What if x = Œµ and y = 01 then indeed xy i z ‚àà C ? ‚ñ∂ Our choice of s gives no contradiction! ‚ñ∂ Try s = 0 p1 p ‚ñ∂ s = xyz with |xy | ‚â§ p, |y | ‚â• 1 and xy i z ‚àà C for every i ‚â• 0 ‚ñ∂ In every possible case y is composed of 0s only! ‚ñ∂ Say y = 0k for some k > 0 then xy 2z = 0p+k 1p < C ‚ñ∂ Contradiction! Lecture 3 Assume L is regular Let‚Äôs try to use the Pumping Lemma Task: Prove that L is not regular .. p : the pumping length Pick s in L with |s| ‚â• p s=xyz s.t. |xy|‚â§ p and |y|‚â•1 and ùë•ùë•ùëèùëèùëñùëñùëßùëß ‚ààùêøùêø‚àÄùëêùëê‚â•0 xz, xyyz,xyyyz,xyyyyz,‚Ä¶ If one of them NOT in L ‚Äì DONE! If all of them in L ‚Äì Try again! Your reasoning should work for any decomposition Fun part is guessing which string to pick! Lecture 3 Test your intuition. . . D = {w | w has equal nr of occurrences of 01 and 10 as substrings} D is regular! Test your intuition .. ùê∑ùê∑= { ùë§ùë§| ùë§ùë§has an equal number of occurences of 01 and 10 as substrings } Define ùëÅùëÅ1(w) ‚à∂= number of occurences of 01 in w ùëÅùëÅ2(ùë§ùë§) ‚âî number of occurences of 10 in ùë§ùë§ Observation: ùëÅùëÅ1 ùë§ùë§ ‚àíùëÅùëÅ2(ùë§ùë§) ‚àà{0,1} Example: ùë§ùë§= 001011101001 ùëÅùëÅ1 ùë§ùë§ = 4, ùëÅùëÅ2 ùë§ùë§ = 3 ùë§ùë§ ‚Ä≤= 1000101101 ùëÅùëÅ1 ùë§ùë§ùë§= ùëÅùëÅ2 ùë§ùë§ùë§= 3 If the starting and the ending symbols are the same then ùëµùëµùüèùüè ùíòùíò ‚àíùëµùëµùüêùüê(ùíòùíò) =0 otherwise ùëµùëµùüèùüè ùíòùíò ‚àíùëµùëµùüêùüê(ùíòùíò) =1 Lecture 3 Beyond Regular Languages Turing Machines . . . Lecture 3","libVersion":"0.5.0","langs":""}