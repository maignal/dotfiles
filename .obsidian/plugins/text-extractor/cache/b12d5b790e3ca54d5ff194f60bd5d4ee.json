{"path":"Homeworks/Solutions/HW2-sol.pdf","text":"Homework II, Theory of Computation 2025 Submission: The deadline for Homework 2 is 23:59 on 17 April. Please submit your solutions on Moodle. Typing your solutions using a typesetting system such as LATEX is strongly encouraged! If you must handwrite your solutions, write cleanly and with a pen. Messy and unreadable homeworks will not be graded. No late homeworks will be accepted. Writing: Please be precise, concise and (reasonably) formal. Keep in mind that many of the problems ask you to provide a proof of a statement (as opposed to, say, just to provide an example). Therefore, make sure that your reasoning is correct and there are no holes in it. A solution that is hard/impossible to decipher/follow might not get full credit (even if it is in principle correct). You do not need to reprove anything that was shown in the class—just state clearly what was proved and where. Collaboration: These problem sets are meant to be worked on in groups of 2–4 students. Please submit only one writeup per team—it should contain the names of all the students. You are strongly encouraged to solve these problems by yourself. If you must, you may use books or online resources to help solve homework problems, but you must credit all such sources in your writeup and you must never copy material verbatim. Even though only one writeup is submitted, it is expected that each one of the team members is able to fully explain the solutions if requested to do so. Grading: Each of the two problems will be graded on a scale from 0 to 5. Warning: Your attention is drawn to the EPFL policy on academic dishonesty. In particular, you should be aware that copying solutions, in whole or in part, from other students in the class or any other source (e.g., ChatGPT) without acknowledgement constitutes cheating. Any student found to be cheating risks automatically failing the class and being referred to the appropriate office. Page 1 (of 4) CS-251 Theory of Computation • Spring 2025 Homework 2 1 Classify each of the following languages into one of the following three categories: decidable, undecidable but recognizable, unrecognizable Justify your answers with proofs. (Recall below that L(M ) = {w : M accepts w} is the language recognized by M .) 1a L1 = {⟨M ⟩ : M is a TM and L(M ) is decidable} 1b L2 = {⟨M, N ⟩ : M and N are TMs and L(M ) ∩ L(N ) ̸= ∅ } 1 Solution to Question 1 • L1 is an unrecognisable language. Recall from the course that language AT M , defined as AT M := {⟨M, w⟩ : M does not accept w} is an unrecognisable language. If we show a reduction AT M ≤m L1 then we prove that L1 is unrecognisable too which follows from the theorem shown in class: If A ≤m B and B is recognisable, then A is recognisable. We aim to build a function f (⟨M, w⟩) = ⟨M ′⟩ which maps a pair of a Turing machine and a string to a Turing machine so that M accepts w if and only if L(M ′) is undecidable. We define M ′ so that on an input string y 1. M ′ first simulates M on w. 2. In case if this computation halts and accepts, M ′ reads string y. If y has the form ⟨N, z⟩ (that is, if the input string contains one special symbol ’,’), M ′ interprets N as a code for a Turing machine and z as the input and simulates N on z. 3. If at any step the computation fails or rejects, M ′ enters an infinite loop. By Church-Turing thesis, a code for the described Turing machine M ′ can be obtained by executing a Turing machine algorithm on input ⟨M, w⟩, so f is computable. It remains to show that that M accepts w if and only if L(M ′) is undecidable: 1. If M accepts w then M only reaches an accept state if the input y has the form ⟨N, z⟩ and if N accepts z. In other words, L(M ′) = AT M which is known to be an undecidable language. 2. If M rejects w or loops on w then M ′ enters an infinite loop and does not accept any input y. In other words, L(M ′) = ∅, which is a decidable language. • L2 is an undecidable but a recognisable language. We prove the two statements separately, starting with undecidability. From the course we know that AT M is an undecidable language, so it suffices to show a reduction AT M ≤m L2. In other words, we aim to build a function f (⟨M, w⟩) = ⟨M ′, N ′⟩ which maps a pair of a Turing machine and a string to two Turing machines so that M accepts w if and only if the languages of these two Turing machines have at least one string in common. We define M ′ = N ′ so that on an input string y Page 2 (of 4) CS-251 Theory of Computation • Spring 2025 1. M ′ first simulates M on w. 2. In case if this computation halts and accepts, M ′ accepts y. 3. Otherwise, M ′ enters an infinite loop. By Church-Turing thesis, a code for the described Turing machine M ′ can be obtained by executing a Turing machine algorithm on input ⟨M, w⟩, so f is computable. It remains to show that that M accepts w if and only if L(M ′) ∩ L(N ′) ̸= ∅ or, equivalently, L(M ′) ̸= ∅: 1. If M accepts w then M ′ accepts all strings which means that L(M ) = Σ∗ ̸= ∅. 2. If M rejects w or loops on w then M ′ enters an infinite loop and does not accept any input y. In other words, L(M ′) = ∅. To show that L2 is recognisable, we provide a Turing machine algorithm which recognises L2. We would want to check for every string in Σ∗ whether M and N accept it – if such a string exists, we report that ⟨M, N ⟩ ∈ L2, and if not then our algorithm will never halt and therefore ⟨M, N ⟩ /∈ L2. We cannot, however, simply check all the strings one by one since M and N might never halt on some strings. We have to carefully check all the strings in parallel, for example, with the algorithm below. 1. Enumerate all the strings in Σ∗ in an arbitrary order (for example, start by enumerating all strings of length one, then length 2, and so on). 2. If at any step of the algorithm below we discover a string wi such that both M and N accept wi, then accept the pair ⟨M, N ⟩ : 3. Complete one step of simulating M on string w1. 4. Complete one step of simulating M on strings w1 and w2. 5. . . . These useful scheme of executing multiple computations in parallel is called dovetailing. By Church-Turing thesis, there exists a Turing machine which performs this algorithm. Grading scheme: • 2.5 points for correctly proving that L1 is unrecognisable. 1 point for a proof with an incorrect reduction function f . • 2.5 points for correctly proving that L2 is undecidable but recognisable. The score may be lowered because of alternative errors; these errors are outlined in the comment section of the submission. 2 Busy Beaver. Define the n-th Busy Beaver number, denoted BB(n), as the largest number k ∈ N such that there exists a TM M = (Q, Σ, Γ, δ, q0, qhalt) such that (1) M has |Q| = n + 1 states (that is, n states in addition to its halting state qhalt), (2) M has a binary input/tape alphabet, Σ = Γ = {0, 1}, (3) M , on the empty input ε, halts with 1k written on its tape. In other words, amongst all (n + 1)-state TMs that halt on the empty input, what is the longest all-1 string that it can output? Note that BB(n) is always finite, as there are only finitely many distinct TMs satisfying (1)–(3) for any given n. Show that the function BB : N → N is not computable. That is, show that there is no TM that on input n (given in binary) will always halt with BB(n) (in binary) on its tape. (Hint: If BB were computable, how would you decide the Halting problem? ) Page 3 (of 4) CS-251 Theory of Computation • Spring 2025 Solution: Assume for contradiction that BB is computable. We will show that this leads to a computable solution to the Halting Problem. For a given Turing machine M and input w ∈ {0, 1}⋆, consider the Turing machine T⟨M,w⟩, which does the following on empty input: • Run M on w while recording somewhere on the tape the number of the current step. • If M (w) halts, use the recorded number of steps to write as many 1s on the tape, delete everything else, and halt. Creating the description of T⟨M,w⟩ from ⟨M, w⟩ is clearly a computable operation. Now, we design the following Turing machine H, which will solve the Halting problem: H = \"On input ⟨M, w⟩: 1. Create the description of T⟨M,w⟩. Calculate the number of states of T⟨M,w⟩: n = |Q(T⟨M,w⟩)|. 2. Compute B = BB(n − 1). 3. Run M on w. 4. If M (w) halts in B steps, accept. Otherwise, reject. Notice that H solves the Halting Problem because if M (w) halts after more than BB(n − 1) steps, then T⟨M,w⟩ would output more than BB(n − 1) 1s and halt on the empty input – a contradiction. Grading Scheme: • 2 points for correctly defining T⟨M,w⟩. 0.5-point deduction for small errors in the description. • 2 points for correctly defining H. 0.5-point deduction for small errors in the description. • 1 point for correct argument that H solves the Halting Problem. • 0.5-point deduction for poorly structured solution with ambiguous arguments. Alternative solutions will be graded on a case-by-case basis. Page 4 (of 4) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}