{"path":"Homeworks/Submitted Answers/Theory_of_Computation___WH3.pdf","text":"Theory of Computation - HW3 Romeo Maignal, Alexandre Margery, Nobel Jaison May 2025 1 Problem 1 Let’s denote this problem as ExactMatch. We first recall that an instance of the SubsetSum problem consists of a set of integers S and a set of integers M . (S, M ) ∈ SubsetSum if and only if there is some subset T of S such that sum of elements of T is M . We now show that ExactMatch ∈ NP. An instance of ExactMatch is a triple (V, E, w) where E → Z, and as a witness we can take the edge set S. The verifier B can be constructed as follows. On input ((V, E, w), S), do: 1. If S ̸⊆ E, reject. 2. Let u = {0, 0, . . . , 0} ︸ ︷︷ ︸ |V | elements , which acts as a set of flags that indicate whether a vertex has been used or not. 3. For every v ∈ V with index iv, do: (a) For every e ∈ E with index ie, do: i. If v ∈ e, do A. If uiv = 1, reject. Otherwise, let uiv = 1. 4. For every v ∈ V with index iv, do: (a) If uiv = 0, reject. 5. Compute s1 = ∑ e∈S w(e). 6. If s1 = k, accept. Otherwise, reject. Now that we have proven the problem is in NP, we need to prove that it is NP-Hard. We do so by reducing from Subset-Sum. We first recall that an instance to the SubsetSum problem consists of a set of integers S and an integer M . (S, M ) ∈ SubsetSum if and only if there is some subset T of S such that the sum of elements of T is M . To complete the reduction, we must prove that for every instance of SubsetSum, we can build a graph such that 1 solving ExactMatch for that graph also gives us the answer to our instance of SubsetSum. The graph G is built using the following method: 1. Vertex Set: • Create two sets of vertices, A and B, each containing |S| vertices. • Label the vertices in A as {a1, a2, a3, ..., an}. • Label the vertices in B as {b1, b2, b3, ..., bn}. • Create two additional vertices ca and cb 2. Edges and Weights: • Add edges between corresponding pairs of vertices (ai, bi) such that w(ai, bi) = Si • Add edges between every pair of vertices (ai, aj) such that w(ai, aj) = 0 • Add edges between every pair of vertices (bi, bj) such that w(bi, bj) = 0 • Add an edge between ca and every vertex in A such that w(ca, ai) = 0 • Add an edge between cb and every vertex in B such that w(cb, bi) = 0 3. We set our ExactMatch target k to be equal our SubsetSum target M We now show that (S, M ) ∈ SubsetSum if and only if (G, k) ∈ Exact- Match • Assume that (S, M ) ∈ SubsetSum: Then there exists some T ⊆ {1, 2, . . . , n} such that ∑ i∈T si = M . This subset will correspond to a subset of edges between A and B in our graph G, whose weight will add up to the same total value as the elements in T . Our ExactMatch solution can be found by choosing all those edges. Then, if there is a pair of remaining AB pairs, noted (aj, bj), (ak, bk), they can be paired off to each-other by selecting the edges (aj, ak) and (bj, bk). Since all the edges within the sets have weight 0, this will not change our total weight. We repeat this until either: – There is one remaining AB pair (ai, bi) not connected to any edges, in which case we pair off (ca, ai) and (cb, bi). – There are no remaining AB pairs not connected to any edges, in which case we pair off (ca, cb). Through this process, every vertex in G will have exactly one connected edge selected. We call this selected set E. Since any edge with weight 0 won’t have an effect on the total sum, we can set them aside and see that the sum of edge weights equals ∑ i∈T w(ai, bi) = M . Since we set M = k, we have that the sum of edge weights equals k. We therefore have a valid solution to ExactMatch. 2 • Assume that (G, M) ∈ ExactMatch: Then there exists some E ⊆ {1, 2, . . . , n} such that for every edge (ai, bi), the edge is in the Exact- Match solution if and only if i ∈ E. By simply setting T = E, we have a T ⊆ {1, 2, . . . , n} such that ∑ i∈T si = k. Since k = M, this also solves our SubsetSum problem. Below is an example graph built for a 3-element SubsetSum S = {s1, s2, s3} a1 a2 a3 b1 b2 b3 ca cb 0 0 0 0 0 0 s1 s2 s3 0 0 0 0 0 0 0 2 Problem 2 To show a problem is NP-Complete, we need to first show that the problem is in NP, and then show that it is NP-Hard. We construct a verifier V for the problem. The instance is the graph G = (V, E) and the integer k, and as the witness we take a subset S ⊆ V . Now define V as follows. On input ((G, k), S), do: 1. If |S| ̸= k, reject. 2. If S ̸⊆ V , reject. 3. Construct the graph G ′ = G[V \\ S] by removing the vertices in S and all their incident edges. 4. Use DFS or BFS to check whether G ′ contains a cycle. If it does, reject. 5. Accept. One can easily see that V runs in polynomial time. Moreover, we observe that there exists some set S ⊆ V such that V ((G, k), S) accepts if and only if removing S from G results in a forest — that is, if and only if S is a blocking set of size at most k. Therefore, the problem is in NP. 3 Now we show that this problem is NP-Hard. From lecture, we know that the VertexCover problem is NP-Complete. In the undirected case, is defined as follows: Given a graph G = (V, E) and integer k, does there exist a subset S ⊆ V of size at most k such that every edge in E has at least one endpoint in S. This is exactly the same as our problem, which we call Block. Therefore, if we can provide a polynomial-time reduction from the VertexCover to Block, then Block is also NP-Hard. We construct the function f for the reduction by the following algorithm. On input (G = (V, E), k), do: 1. Output the same graph G and the same integer k, i.e. f (G, k) = (G, k). Clearly, f is polynomial-time computable. It remains to show that (G, k) ∈ VertexCover if and only if f (G, k) ∈ Block. • Assume that (G, k) ∈ the VertexCover: Then there exists a set S ⊆ V of size at most k such that removing S from G results in a forest. But this is precisely the definition of a blocking set, so (G, k) ∈ Block. • Assume that f (G, k) = (G, k) ∈ Block: Then there exists a set S ⊆ V of size at most k such that removing S from G leaves a forest. By definition, this means (G, k) ∈ VertexCover. Therefore, we can conclude that Block is NP-Complete. 4","libVersion":"0.5.0","langs":""}