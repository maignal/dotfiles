{"path":"Exercises/Solutions/ToC ex 11 sol.pdf","text":"Exercise XI, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. More Problems on Complexity Classes 1 Define coNP = {L : L ∈ NP} as the class of languages whose complements are in NP. Show that if any NP-complete problem lies in coNP, then NP = coNP. Solution: Suppose L ∈ coNP is NP-complete. We only show that NP ⊆ coNP as the other inclusion, coNP ⊆ NP, is analogous. Let L′ ∈ NP. Since L is NP-complete, we have L′ ≤p L or equivalently L′ ≤p L. But L ∈ NP so we get that L′ ∈ NP. This is equivalent to L′ ∈ coNP as desired. 2 Denote by RE the class of recognisable languages. We say that a language L is RE-complete iff L ∈ RE and for every L′ ∈ RE we have L′ ≤m L. Show that HALT is RE-complete. Solution: We have seen that AT M ≤m HALT, so it suffices to show instead that AT M is RE- complete, which is what we will do. We know that AT M ∈ RE so it remains to show that L ≤m AT M for every L ∈ RE. Let L ∈ RE be arbitrary. Then there is some Turing machine M that recognises L, that is, w ∈ L ⇐⇒ M accepts w. We define a reduction L ≤m AT M by f (w) = ⟨M, w⟩, which is clearly computable. Now w ∈ L ⇐⇒ M accepts w ⇐⇒ ⟨M, w⟩ ∈ AT M ⇐⇒ f (w) ∈ AT M . Problems on Circuit Complexity 3 Complete the proof of Circuit-SAT ≤p SAT from the lecture by finding an equivalent CNF formula for each of the three logical predicates y ↔ (x ∨ z), y ↔ (x ∧ z) and y ↔ ¬x. Solution: One can find an equivalent CNF formula by applying standard boolean algebra identities. We provide the details for the first item only. y ↔ (x ∨ z) = (y → (x ∨ z)) ∧ ((x ∨ z) → y) = (¬y ∨ x ∨ z) ∧ (¬(x ∨ z) ∨ y) = (¬y ∨ x ∨ z) ∧ (¬x ∧ ¬z) ∨ y) = (¬y ∨ x ∨ z) ∧ (¬x ∨ y) ∧ (¬z ∨ y) y ↔ (x ∧ z) = (¬y ∨ x) ∧ (¬z ∨ z) ∧ (¬x ∨ ¬z ∨ y) y ↔ ¬x = (¬x ∨ ¬y) ∧ (x ∨ y) Page 1 (of 2) CS-251 Theory of Computation • Spring 2025 4 The function Xorn : {0, 1}n → {0, 1} outputs 1 iff the number of 1-bits in the input is odd. Show that Xorn can be computed with a boolean circuit (gates ∨, ∧, ¬) of size O(n). Hint: Constructacircuitforn=2andthenusemanycopiesofthatcircuitforgeneraln. Solution: Proof by picture: 5 Let φ be any DNF formula over n variables that computes Xorn. Recall that φ = T1 ∨ · · · ∨ Tm where each Tj is a term, that is, a conjunction of literals. 5a* Show that any term Tj either contains n distinct variables or is contradictory, meaning that it contains xi and xi for some variable xi. Hint: UsethefactthatthevalueofXornisflippedifweflipthevalueofanyxi. Solution: Suppose Tj is not contradictory. Then it accepts some input x ∈ {0, 1}n so that Tj(x) = 1 and hence φ(x) = Xorn(x) = 1. Suppose for the sake of contradiction that Ti does not contain all n variables. Without loss of generality, assume xi is not included. Consider x′ ∈ {0, 1}n which is the same as x but with the value of variable xi flipped. We still have that Tj(x′) = 1 and hence φ(x′) = Xorn(x′) = 1. But this is a contradiction since x and x′ have different parities. Hence we conclude that Tj contains all n variables. 5b Thus, show that φ contains at least 2n−1 terms. Solution: Problem 5a implies that each term of φ can accept at most one input. But there are 2n−1 many inputs x with Xorn(x) = 1 and hence φ must contain one term for each such x. Note that problems 3–4 together imply that circuits can be much more expressive than CNFs. Page 2 (of 2) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}