{"path":"Exercises/Solutions/ToC ex 5 sol.pdf","text":"Exercise V, Theory of Computation 2025 These exercises are for your own benefit. Feel free to collaborate and share your answers with other students. Solve as many problems as you can and ask for help if you get stuck for too long. Problems marked * are more difficult but also more fun :). These problems are taken from various sources at EPFL and on the Internet, too numer- ous to cite individually. 1 Prove that the problem of checking whether a given DFA accepts a finite language is decidable. Solution: We claim that a DFA D accepts an infinite number of strings if and only if in the transition diagram of D there is a path P with the following properties: • The path P starts at the start of D. • The path P ends at an accepting state of D. • The path P visits some state of D at least twice. Note that one possible way for P to satisfy the third property is to contain a vertex that self-loops. The proof of this claim is quite simple. If there is such a P , then, just as in the proof of the pumping lemme, we can repeat the part of P between two visits to the same state arbitrarily often, giving rise to infinitely many accepting paths. Thus, L(D) is infinite. Conversely, if the language L(D) is infinite, then it must contain a word w whose length is larger than the number of states in D. Thus, the accepting path for P must satisfy all three conditions above by the pigeonhole principle. To solve the exercise, it therefore suffices to describe a Turing machine which decides if a given transition diagram contains a path with these three properties or not. As a technical aside, note that we can always reconstruct the transition diagram of a DFA from its encoding. Consider the following algorithm: On input ⟨D⟩, do: 1. For all states q of D: (a) Check if there is a path from the start state of D to q. (b) Check if there is a (non-empty) path that starts at q and returns to q. (c) Check if there is a path from q to some accepting state of D. (d) If all three of these checks succeeded, then accept. 2. Reject Note that each of the three sub-routines is clearly decidable, using simple path finding al- gorithms for directed graphs. By the Church-Turing thesis, the algorithms described above can be run on a Turing machine. We conclude that checking whether L(D) is infinite is Turing- decidable. And since Turing-decidable languages are closed under complementation, checking whether L(D) is finite is too. Page 1 (of 4) CS-251 Theory of Computation • Spring 2025 As another technical aside, note that the two languages mentioned above are probably not really complimentary over the underlying alphabet which we use to encode the input DFA. This is because some input strings might not correspond to the encoding of a valid DFA at all. But we always assume that the Turing machine can decide if an input is invalid, and thus we can always assume that all inputs are valid encodings. We remark that this exercise can also be solved by using the pumping lemma directly to show the following fact: The language L(D) is infinite if and only if it contains a word w such that (number of states of D) < |w| ≤ 2 × (number of states of D). But this property can be easily verified by simulating the D on all the finitely many words whose length falls in that interval. 2 Prove that the language L = {⟨D⟩ : D is a DFA over alphabet {0, 1} that only rejects a single string} is decidable. Solution: We construct a Turing machine which decides L. Consider the following algorithm: On Input ⟨D⟩, do: 1. If there is a rejecting path though D, extract w ̸∈ L(D), otherwise reject. 2. Construct a DFA Dw that accepts only the string w. 3. Construct a DFA D′ that recognizes the language L(D) ∪ L(Dw). 4. If D′ has a rejecting path, reject. Otherwise, accept. We first remark that the two DFAs we construct in the procedure have simple descriptions in terms of w or the description of previous DFAs. Moreover, finding a rejecting path though a DFA can be achieved using a simple path finding algorithm. Thus, by the Church-Turing thesis the above algorithm can be implemented na Turing machine. We now prove that this algorithm decides L. • If ⟨D⟩ ∈ L, then step 1 succeeds and finds the unique w ̸∈ L(D). But now L(D′) = L(D) ∪ L(Dw) = {0, 1}∗ does not have a rejecting path and the algorithm accepts. • If ⟨D⟩ ̸∈ L, then either L(D) = {0, 1}∗ and we reject at step 1, or we find some w ̸∈ L(D). Since ⟨D⟩ ̸∈ L, there must be some other w ̸= w′ ̸∈ L(D). But this implies w′ ̸∈ Dw and thus w′ ̸∈ L(D′) = L(D) ∪ L(Dw). Therefore, D′ has a rejecting path and the algorithm rejects. We remark that we could have also defined an equivalent algorithm that just operates on D, without constructing other DFAs. 3 Prove that the following questions about pairs of Turing machines (M, N ) are undecidable. 3a Is L(M ) ∩ L(N ) empty? 3b Is L(M ) ∩ L(N ) finite? Solution: Recall that the language ATM = { ⟨T, w⟩ : T is a Turing machine that accepts w} is undecidable. Page 2 (of 4) CS-251 Theory of Computation • Spring 2025 3a Let L∅ = { ⟨M, N ⟩ : L(M ) ∩ L(N ) = ∅ } be the language in question. We prove that if L∅ is decidable, then ATM is decidable too, which gives us the desired contradiction. To this end, assume that L∅ is decided by the Turing machine M∅. We construct an algorithm that decides ATM: On input ⟨T, w⟩, do: 1. Construct a Turing machine M ′ that simulates the T on input w and outputs T (w). 2. Run M∅(⟨M ′, M ′⟩). 3. If the computation in step 2 accepted, then reject. Otherwise, accept. We first note that this algorithm always halts. The machine M∅ was defined to be a decider of the language L∅ and thus always halts. Note that the machine M ′ we construct does not take an input. Also, there is no guarantee that M ′ halts, since T can be an arbitrary Turing machine. But this is fine, since we never actually run T or M ′, we just feed the description of M ′ to M∅. By the Church-Turing thesis, there is a Turing machine M that implements the above algo- rithm. We now argue that M decides ATM. • If ⟨T, w⟩ ∈ ATM, then T (w) accepts by definition. Thus, M ′ always accepts and L(M ′) ∩ L(M ′) ̸= ∅. This implies M∅(⟨M ′, M ′⟩) rejects, and hence M accepts • Consider ⟨T, w⟩ ̸∈ ATM. Then T (w) does not accepts (it might not halt) and thus M ′ never accepts. Therefore, L(M ′) ∩ L(M ′) = ∅ and M∅(⟨M ′, M ′⟩) accepts, making M reject. We conclude that if L∅ is decidable, then so is ATM. But we know this is not the case, hence L∅ is not decidable. 3b We can use the exact same solution as in part a, with L∅ replaced with L<∞. This is because the only time we used the definition of L∅ was to distinguish the language of all strings from the empty language. But L<∞ can do this job equally well. 4* We say that a Turing machine has property U if for all n ∈ N, at most one string of length n is accepted by M . Assuming that |Σ| > 1, prove that the language L = { ⟨M ⟩ : M has property U} is undecidable. What happens if |Σ| = 1? Solution: Assume for the sake of contradiction that L is decided by a Turing machine ML. We use ML to construct a decider M for ATM, which gives us the desired contradiction: In input ⟨T, w⟩, do: 1. Construct a Turing machine M ′ that simulates the T on w and outputs T (w). 2. Run ML(⟨M ′⟩). 3. If the computation in step 2 accepted, then reject. Otherwise, accept. This algorithm always halts, since ML does. We now show that this algorithm decides ATM. • If ⟨T, w⟩ ∈ ATM, then T (w) accepts, which implies that M ′ accepts all strings. Hence, ML(⟨M ′⟩) rejects since M ′ accepts |Σ| > 1 strings of length 1 in particular. Thus, M accepts as desired. Page 3 (of 4) CS-251 Theory of Computation • Spring 2025 • If ⟨T, w⟩ ̸∈ ATM, then T (w) never accepts and thus M ′ has property U. Hence, ML(⟨M ′⟩) accepts and M rejects as desired. Therefore, M decides ATM, contradicting its undecidability. If |Σ| = 1, then every Turing machine has property U and thus L is decidable. Note that while exercises 3 and 4 seem to be asking for very different things, the solutions are almost identical. This is no coincidence, and later in the course we might see a result which vastly generalises this argument. 5* Is the following language recognizable? L = { ⟨M ⟩ : M is a Turing machine that accepts at most 2025 strings } Solution: No, L is not recognisable. Assume for the sake of contradiction that L is recognised by the Turing machine ML. We use this to construct an algorithm that recognizes ATM, which we know to be unrecognizable. On input ⟨T, w⟩, do: 1. Construct a Turing machine M ′ that simulates T on w and outputs T (w). 2. Output ML(⟨M ′⟩). Now we show that this algorithm recognizes ATM. • If ⟨T, w⟩ ∈ ATM, then T (w) does not accept by definition. Hence, M ′ accepts 0 strings, which is less than 2025. Thus, ML(⟨M ′⟩) accepts an so does our algorithm. • If ⟨T, w⟩ ̸∈ ATM, then T (w) accepts. Hence, M ′ accepts all infinitely many strings. Since that is more than 2025, ML(⟨M ′⟩) will not accept (either reject or not halt at all). Thus, that our algorithm also does not accept. We conclude that the algorithm recognizes ATM, which contradicts with the fact that ATM is unrecognizable. Thus, our assumption that L is recognisable must have been wrong. Page 4 (of 4) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}