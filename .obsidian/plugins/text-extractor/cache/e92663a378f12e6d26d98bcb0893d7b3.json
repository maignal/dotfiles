{"path":"Exam/Solutions/examsol2024.pdf","text":"Final Exam, Theory of Computation 2024 1 (15 pts) Quick-ﬁre round. Consider the following statements. 1. Every language in P is regular. 2. Every ﬁnite language is regular. 3. Every language in NP is decidable. 4. Language {0n1m : n ≤ m} is regular. 5. Language {w : number of 1s in w is divisible by 2024} is regular. 6. Language {⟨D⟩ : D is a DFA with L(D) = ∅} is in P. 7. Language {⟨G⟩ : G is a graph with vertex cover of size 2024} is NP-complete. 8. Suppose A ⊆ B ⊆ C where A and C are decidable. Then B is recognisable. 9. If A and B are recognisable, then A ∩ B is recognisable. 10. If A ≤m B, then A ≤p B. 11. If A ≤m B, then A ≤m B. 12. If L ∈ NP, then L ∈ NP. 13. P = NP ∩ coNP. 14. 3-SAT ≤m HALT. 15. 2-SAT ∈ P. For each statement, write down one of − T if the statement is known to be true. − F if the statement is false or not known to be true. E.g., both P = NP and P ̸= NP should be marked F. − or leave your answer empty. A correct T/F answer is worth +1 point, an incorrect answer is worth −1 point, and an empty answer is worth 0 points. Solution: 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. F T T F T T F F F F T F F T T Page 1 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös 2 (20 pts) Regular languages. 2a Write down the statement of the Pumping Lemma. (Only the statement, not its proof !) 2b Let Σ = {a, b, c}. Show that the following language is regular: Double-Σ = { w ∈ Σ∗ : Every symbol in Σ appears in w at least twice }. Solution: 2a If A is a regular language, then there is a number p (the pumping length) such that, for every string s in A of length at least p, there exists a division of s into three pieces, s = xyz s.t. • for each i ≥ 0, xyiz ∈ A • |y| ≥ 1, and • |xy| ≤ p. Grading scheme: • Correct statement - 7 pts • If the statement is not correct - varies from case to case. 2b Consider language Double-a = { w ∈ Σ∗ : a appears in w at least twice}, and Double-b, Double-c deﬁned similarly. It is easy to see that Double-Σ is the intersection of these three languages, so it is enough to prove that each of them is regular. Moreover, it is enough to do it for Double-a – the proof for the other two languages is similar. We will build a DFA that recognises Double-a: • Q = {q0, q1, q2}, • δ(q0, a) = q1, δ(q0, b/c) = q0; δ(q1, a) = q2, δ(q1, b/c) = q2; δ(q2.a/b/c) = q2. • F = {q2}. Note that, after we ﬁnish reading w, we end up in q2 if and only if w contains at least two a’s, which precisely means that the DFA we have built recognises Double-a. Grading scheme: • Correct solution - 13 pts. • Solution is incorrect but it has a good idea in it - 2 or more pts. Page 2 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös 3 (15 pts) NP-completeness I. Show that the following language is NP-complete: DoubleSAT = { ⟨ϕ⟩ : ϕ is a CNF that has at least two satisfying assignments } . Solution: DoubleSAT ∈ NP: the veriﬁer will take as arguments a formula ϕ and two assign- ments C1 and C2. We check that: 1) C1 ̸= C2; 2) ϕ(C1) = 1; 3) ϕ(C2) = 1. This can all be done in polynomial time. DoubleSAT is NP-hard: we build a reduction from SAT in the following way. Given a formula ψ, we output a formula ϕ := ψ ∧ (x ∨ ¬x), where x is a new variable. If ψ had a satisfying assignment ρ, it can be extended to a satisfying assignment for ϕ in two ways: ρ ∪ {x = 0} and ρ ∪ {x = 1}. Therefore, if ψ ∈ SAT, then ϕ ∈ DoubleSAT. On the other hand, if ϕ ∈ DoubleSAT, we can take a satisfying assignment for ϕ and project it onto variables of ψ (that is, discard value of x), and the result will be a satisfying assignment for ψ. Grading scheme: up to 7 points for NP-membership and up to 8 points for NP-hardness. 4 (15 pts) NP-completeness II. Suppose S = {S1, . . . , Sn} is a family of subsets of {1, 2, . . . , n}. We say that k distinct sets Si1, . . . , Sik ∈ S form a packing of size k if the sets are pairwise disjoint, that is, Sij ∩ Sij′ = ∅ for j ̸= j′. Show that the following problem is NP-complete: SetPacking = { ⟨S, k⟩ : Family S contains a packing of size k } . Solution: To prove SetPacking ∈ NP, we give the veriﬁer as follows: Given a set of indices I = {i1, . . . , ik}, the veriﬁer checks that whether for every 1 ≤ j < j′ ≤ [k], Sij ∩ Si′ j = ∅. If yes, the veriﬁer accpets, rejects otherwise. It is clear that such a veriﬁer runs in polynomial time. Next, we prove SetPacking is NP-hard by reducing IndSet to SetPacking. Given an IndSet instance ⟨G, k⟩, we construct a SetPacking instance f (⟨G, k⟩) = ⟨S, k′⟩ as follows: Let let k′ := k and m denote the number of edges of G. We assign each edge e with a unique label ℓe ∈ [m]. For each vertex vi, we construct a subset Si ⊆ [m] which consist of the labels of all the edges incient to vi. Finally, let us prove the correctness of our reduction. Consider the following four statements: (i) {vi1, . . . , vik } is an indepdent set of G. (ii) For every edge e, at most one endpoint is in {vi1, . . . , vik }. (iii) For every edge e, the corresponding label is contained in at most one of Si1, . . . , Sik . (iv) Si1, . . . , Sik is a packing. By the deﬁnition of independent set, (i)≡(ii). By the deﬁntion of packing, (iii)≡(iv). It also follows from our reduction that (ii)≡(iii). Thus (i)≡(iv), which in turn implies that ⟨G, k⟩ ∈ IndSet if and only if ⟨S, k′⟩ ∈ SetPacking. Grading scheme: • NP-membership - 7 pts Page 3 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös • NP-hardness - 8 pts. 5 (20 pts) Undecidability. Consider the language DoubleTM = { ⟨M ⟩ : M is a TM that accepts at least two inputs, i.e., |L(M )| ≥ 2 } . Classify DoubleTM as one of (i) decidable, (ii) undecidable but recognisable, (iii) unrecognis- able. Justify your answer with a proof. (Note: You are not allowed to use Rice’s theorem as mentioned in Homework 2! Use only concepts introduced in class/exercises.) Solution: We will prove that the language DoubleTM is (ii) undecidable but recogniz- able. We will ﬁrst construct a recognizer R for DoubleTM. Let {wi}∞ i=1 be some computable enumeration of the strings in the input alphabet Σ. We deﬁne R as follows: R = \"On input x: 1. If x is not a valid encoding of a TM, reject. 2. Otherwise, for x = ⟨M ⟩, do the following: for i ≥ 1: Simulate M on w1, w2, . . . , wi for i steps. If M ’s computation results in an accept state for at least 2 of the strings w1, w2, . . . , wi, break out of the loop and accept ⟨M ⟩.\" Clearly, R accepts ⟨M ⟩ if and only if |L(M )| ≥ 2. Hence, DoubleTM is recognizable. Now, we proceed to prove that DoubleTM in undecidable through a reduction from the undecidable language Halt. That is, we will prove that Halt ≤m DoubleTM by constructing a computable function which maps the pair ⟨M, w⟩ to a TM ⟨Mw⟩ such that |L(Mw)| ≥ 2 ⇐⇒ M (w) halts. Without further ado, Mw = \"On input x: 1. If x = w · 0 (the concatenation of w and 0), accept. 2. Otherwise, simulate M on w. If M (w) halts, accept w. Now, if ⟨M, w⟩ ∈ Halt, then L(Mw) = {w, w · 0}, so ⟨Mw⟩ ∈ DoubleTM. And if M (w) loops forever, L(Mw) = {w · 0}, so ⟨Mw⟩ /∈ DoubleTM. Hence, the reduction is valid, and since Halt is undecidable, so is DoubleTM. Grading Scheme. Note that correct solutions which do not adhere to the oﬃcial solutions (or are not captured completely by the grading rubric) will receive full points. In some cases, points might be awarded for interesting approaches to the problem which do not lead to a complete solution. • 2 pts. for answering correctly with \"(ii) recognizable but undecidable.\" • 9 pts. for proving DoubleTM is recognizable: Page 4 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös – 3 pts. for a wrong formal deﬁnition of a veriﬁer that contains some hint of a correct approach but requires considerable modiﬁcations to work; – 6 pts. for a slightly wrong formal deﬁnition of a veriﬁer (e.g. the student did not account for the fact that when simulating M (w), the simulation might loop forever); – 9 pts. for an essentially correct formal deﬁnition of a veriﬁer. • 9 pts. for proving DoubleTM is undecidable: – 3 pts. for an attempt at a reduction which requires substantial amount of work to be ﬁxed; – 6 pts. for a slightly wrong reduction that can easily be ﬁxed; – 9 pts. for an essentially correct reduction to DoubleTM from an undecidable lan- guage. 6 (15 pts) Doubly accepting NFA. Let N be an NFA. The usual deﬁnition of acceptance is the existence of at least one accepting path. Change this deﬁnition as follows: N accepts the input word w iﬀ there are at least two accepting paths. Denote by L2(N ) the set of strings that admit at least two accepting paths. Prove that L2(N ) is regular. Solution: Let us convert doubly accepting NFA (daNFA) into a DFA following the standard NFA to DFA conversion. Recall that the states of the DFA in the standard conversion corresponded to {0, 1}Q, that is, binary vectors of length |Q| encoding a subset of Q. In our case the states will correspond to {0, 1, 2}Q, that is, ternary vectors of length |Q|. Such a vector will encode how many paths (0: zero, 1: one, 2: at least two) the current word can reach each of the daNFA states. The ﬁnal states of the DFA are all that have at least 2 paths in any of the accepting states in daNFA. Formally suppose that A := ⟨Q, Σ, δ, q0, F ⟩ is the initial doubly accepting NFA. Then deﬁne a DFA D := ⟨{0, 1, 2}Q, Σ, δ′, q′ 0, F ′⟩ with • For every q ∈ Q deﬁne (q′ 0)q := { 1 if q = q0 0 otherwise . • For every r ∈ {0, 1, 2}Q and α ∈ Σ let δ′(r, α) = {min{∑ t∈Q : δ(t,α)∋q rt, 2}}q∈Q. • F ′ := {r ∈ {0, 1, 2}Q | ∃q ∈ F : rq = 2} For a word w = α1, . . . , αk we can chow by induction on the length of the word that for r = δ′(q′ 0, w), the number rq = min{2, number of paths in A from q0 to q}. Hence w is accepted by D if and only if there exists q ∈ F with at least two accepting paths in A. This concludes the proof. Grading Scheme: The following are applied exclusively. • 2 pts. Showing that a regular language can be recognised by a daNFA. • 2 pts. Alternative incorrect solutions. Page 5 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös • 3 pts. Suggesting adapting NFA to DFA conversion to the current problem. • 7 pts. Solving the problem with another deﬁnition “daNFA accepts a word s if there are two distinct accepting states to which there is an accepting path corresponding to s”. Such solutions are, for instance – The standard conversion NFA to DFA conversion and deﬁning the ﬁnal states as {S ⊆ Q | |S ∩ F | ≥ 2} where Q is the set of stated of daNFA and F is the set of its ﬁnal states. – Making |F | copies of A leaving only one accepting state in each and then multiplying them. • 15 pts. Correct solution. – (-5 pts) If there is no correct proof. Page 6 (of 6) CS-251 Theory of Computation, Final Exam • Spring 2024 Mika Göös","libVersion":"0.5.0","langs":""}