{"path":"Lectures/Lecture7.pdf","text":"Lecture 7: Time Complexity, P vs. NP Mika Göös School of Computer and Communication Sciences Lecture 7 Time Complexity Lecture 7 Computability: worst case Computability: Worst Case <∞ <∞ <∞ <∞ <∞ ∞ <∞ <∞ <∞ <∞ <∞ <∞ <∞ <∞ <∞ ∞ <∞ <∞ <∞ <∞ ⋮ ⋮ 𝜀 0 1 01 10 00 11 000 ⋮ 𝑀𝐴 𝑀𝐵 Does not halt on this input and, hence, is not a decider Number of configurations TM needs to reach an accept/reject state on this input Recognizers for a language 𝐿; Which one is better? In the rest of the course we just consider decidable languages 001 010 In the rest of the course material we just consider decidable languages Lecture 7 A decidable language L 2 2 5 2 3 4 2 2 2 5 12 2 3 5 12 5 20 12 14 13 8 19 2 9 32 14 18 9 18 3 5 90 12 21 56 8 12 18 18 30 21 22 26 15 11 12 32 15 11 12 25 100 13 48 98 29 320 201 159 201 190 200 180 65 211 208 190 200 189 301 219 82 328 271 214 441 193 208 109 77 227 261 191 201 188 107 211 207 𝜀 0 1 01 10 00 11 000 001 𝑀𝐴 𝑀𝐵 𝑀𝐶 𝑀𝐺𝑀𝐹𝑀𝐸𝑀𝐷 𝑀𝐻 ⋯ A Decidable Language 𝐿 Inputs How to compare different deciders? 010 011 ⋮ … … … … … … … … … … … ⋮ ⋮ ⋮ ⋮ ⋱⋮⋮⋮⋮ Deciders for L: Number of configurations TM needs to reach an accept/reject state on this input How to compare diﬀerent deciders? Lecture 7 Two deciders for L 2 4 12 15 22 17 110 49 34 38 300 𝑀𝐴 𝑀𝐵 12 110 ⋮ ⋮ 𝜀 0 1 01 10 00 11 ⋮ 001 010 011 000 2 9 10 40 30 45 39 73 77 85 80 300 10 45 85 𝜀 0 1 01 10 00 11 ⋮ 001 010 011 000 Worst case in this group 2 2 Two Deciders for 𝐿 Lecture 7 Running time of a TM Deﬁnition: Let M be a TM that halts on all inputs (decider). The running time or time complexity of M is the function t : N → N where t(n) = max w ∈Σ∗:|w |=n number of steps M takes on w ▶ M runs in time t(n) ▶ n represents the input length t(0) = 2 t(1) = 10 t(2) = 45 t(3) = 85 Running Time of a TM Definition: Let 𝑀be a TM that halts on all inputs (decider). The running time or time complexity of 𝑀is the function 𝑡:ℕ→ ℕ where 𝑡𝑛 = max 𝑤∈Σ⋆;𝑤 =𝑛 number of steps 𝑀takeson 𝑤 - 𝑀runs in time 𝑡𝑛 - 𝑛represents the input length 2 9 10 21 30 45 33 73 77 85 80 𝑡0 =2 𝑡1 =10 𝑡2 =45 𝑡3 =85 ⋮ 10 45 85 𝜀 0 1 01 10 00 11 ⋮ 001 010 011 000 2 Lecture 7 Two deciders for L Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 ⋮ 𝑀𝐴 𝑀𝐵 Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 ⋮ 𝑡1 1 =5 𝑡1 2 =9 𝑡1 3 =17 𝑡1 4 =33 𝑡1 5 =65 𝑡2 1 =8 𝑡2 2 =13 𝑡2 3 =18 𝑡2 4 =23 𝑡2 5 =28 ⋮ ⋮ 𝑡2 0 =3𝑡1 0 =3 Two Deciders for 𝐿 Lecture 7 0 10 20 30 40 50 60 70 0 1 2 3 4 5 𝑡1(𝑛)=2 𝑛+1+1 vs 𝑡2(𝑛)=5𝑛+3 Time Input length How to compare running time functions? 𝒇𝟏 𝒏 =𝟐𝒏, 𝒇𝟐 𝒏 =𝟓𝒏𝟑+𝟏, 𝒇𝟑 𝒏 =𝟐𝟎𝒏+𝟔 How to compare running time functions? Lecture 7 The Growth of Functions 50 100 150 0 20,000 40,000 60,000 2x 2 1000 log2(x ) 2 x Lecture 7 Big-O and Small-o notation Deﬁnition (Big-O): Let f , g : N → R≥0. We say f (n) = O(g(n)) if ∃C > 0, n0 ∈ N s.t. ∀n ≥ n0 f (n) ≤ C · g(n) Examples: ▶ 5n3 + 1 = O(2 n) ? YES ▶ 5n3 + 1 = O(20n + 5) ? NO Deﬁnition (Small-o): Let f , g : N → R≥0. We say f (n) = o(g(n)) if ∀c > 0, ∃n0 ∈ N s.t. ∀n ≥ n0 f (n) < c · g(n) Examples: ▶ √n = o(n) ? YES ▶ f (n) = o(f (n)) ? NO Lecture 7 Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 ⋮ 0 100 200 300 400 500 600 1 2 3 4 5 6 7 8 9 10 11 12 t(.) 0 500 1000 1500 2000 2500 1 2 3 4 5 6 7 8 9 10 11 12 . 𝑡𝑛 =𝑂 2 𝑛 2 𝑛 To Summarize .. ⋮ 𝑡1 =4 𝑡2 =3 𝑡3 =7 𝑡4 =15 𝑡5 =14 𝑡0 =2 10 2 3 4 2 4 3 ⋮ ⋮ 7 ⋮ 6 ⋮ 15 ⋮ 10 8 ⋮ 14 ⋮ 𝑀 To summarize. . . Lecture 7 Time Complexity Deﬁnition: Time complexity class TIME (t(n)) = {L ⊆ Σ∗ | L is decided by a TM with running time O(t(n))} Example: TIME (n) ⊆ TIME (n2) ⊆ · · · ⊆ TIME (2 √ n) ⊆ TIME (2n) ⊆ TIME (22n ) . . . Example: REGULAR ⊆ TIME (n) Lecture 7 The complexity class P and eﬃciency Deﬁnition: P is the class of languages that are decidable in polynomial time on a (deterministic) Turing machine. In other words, P = ∞⋃ k=1 TIME (nk ) . Some languages in P: ▶ {⟨A⟩ : A is a sorted array of integers} ▶ {⟨G, s, t⟩ : s and t are vertices connected in graph G} (Breadth-First Search) ▶ {⟨G⟩ : G is a connected graph} Lecture 7 NP: Veriﬁcation vs. Search Lecture 7 SAT-verify and SAT Conjunctive Normal Form (CNF) Formula: ϕ1 = (x ∨ y ∨ z0) ∧ (x ∨ y ∨ z1) ∧ (x ∨ y ∨ z2) ∧ (x ∨ y ∨ z3) ϕ2 = x1 ∧ (x1 ∨ x2) ∧ (x1 ∨ x2 ∨ x3) ∧ (x1 ∨ x2 ∨ x3 ∨ x4) ϕ3 = x1 ∧ (x1 ∨ x2) ∧ (x1 ∨ x2) ▶ CNF Formula: AND of Clauses ▶ Clause: OR of Literals ▶ Literal: variable or its negation Satisfying assignment: Boolean assignment to variables which makes the formula TRUE. Check: ϕ1 has 32 satisfying assignments, ϕ2 has only one, ϕ3 has zero. A formula is satisﬁable if it has at least one satisfying assignment. Lecture 7 SAT-verify and SAT SAT-verify = {⟨ϕ, C ⟩ : C is a satisfying assignment of ϕ} Is SAT-verify in P? Yes! 1 Substitute for literals according to C . 2 Check that every clause has at least one TRUE literal. SAT = {⟨ϕ⟩ : ϕ is satisﬁable} = {⟨ϕ⟩ : ∃C such that ⟨ϕ, C ⟩ ∈ SAT-verify} Is SAT in P? Decider for SAT: 1 For each assignment C : ▶ If ⟨ϕ, C ⟩ ∈ SAT-verify, ACCEPT ϕ. 2 REJECT ϕ. Lecture 7 GI-verify and GI a bc d e f 1 2 3 4 5 6 Graph Isomorphism: Bijection f : V (G1) −→ V (G2) which preserves adjacency: {u, v } ∈ E (G1) ⇔ {f (u), f (v )} ∈ E (G2) Eg. a → 1 b → 2 c → 3 d → 4 e → 5 f → 6 in the graphs above. Two graphs are isomorphic if they have at least one graph isomorphism. Lecture 7 GI-verify and GI GI-verify = {⟨G1, G2, C ⟩ : C : V (G1) −→ V (G2) is a graph isomorphism} Is GI-verify in P? Yes! 1 Check that C is a bijection: For each u, v ∈ V (G1): ▶ Check {u, v } ∈ E (G1) ⇔ {C (u), C (v )} ∈ E (G2). GI = {⟨G1, G2⟩ : G1 and G2 are isomorphic} = {⟨G1, G2⟩ : ∃C such that ⟨G1, G2, C ⟩ ∈ GI-verify} Is GI in P? Decider for GI: 1 For each function C : V (G1) −→ V (G2): ▶ If ⟨G1, G2, C ⟩ ∈ GI-verify, ACCEPT ⟨G1, G2⟩. 2 REJECT ⟨G1, G2⟩. Lecture 7 INDSET-verify and INDSET 1 2 3 4 5 6 Independent Set: Subset S ⊆ V (G) such that no two vertices in S are adjacent in G. Eg. {1, 3, 5}, {2, 4}, {6}, ∅, etc. in the graph above. Lecture 7 INDSET-verify and INDSET INDSET-verify = {⟨G, k, C ⟩ : C is an independent set of size k in G} Is INDSET-verify in P? Yes! 1 Check that |C | = k. 2 For each u, v ∈ C : ▶ Check {u, v } < E (G). INDSET = {⟨G, k⟩ : G has an independent of size k} = {⟨G, k⟩ : ∃C such that ⟨G, k, C ⟩ ∈ INDSET-verify} Is INDSET in P? Decider for INDSET: 1 For each subset C ⊆ V (G): ▶ If ⟨G, k, C ⟩ ∈ INDSET-verify, ACCEPT ⟨G, k⟩. 2 REJECT ⟨G, k⟩. Lecture 7 Veriﬁers and the class NP Recall: A decider for language L is a TM M such that for each x ∈ Σ∗ ▶ If x ∈ L, then M accepts x . ▶ If x < L, then M rejects x . Deﬁnition: A veriﬁer for language L is a TM M such that for each x ∈ Σ∗ ▶ If x ∈ L, then there exists C such that M accepts ⟨x , C ⟩. ▶ If x < L, then for every C , M rejects ⟨x , C ⟩. (C is called a certiﬁcate or witness) A veriﬁer is a polynomial time veriﬁer if its running time on any ⟨x , C ⟩ is polynomial in |x|. (Thus |C | is polynomial in |x |) Deﬁnition: NP is the class of languages that have poly-time veriﬁers. Lecture 7 Why is it called NP? Lecture 7 Detour: Non-deterministic Turing Machines Recall: In a Turing machine, δ : (Q × Γ) −→ Q × Γ × {L, R}. In a Nondeterministic Turing Machine (NTM), δ : (Q × Γ) −→ P(Q × Γ × {L, R}) (several possible transitions for a given state and tape symbol) Deﬁnition: A nondeterministic decider for language L is an NTM N such that for each x ∈ Σ∗, every computation of N on x halts, and moreover, ▶ If x ∈ L, then some computation of N on x accepts. ▶ If x < L, then every computation of N on x rejects. An NTM is a polynomial time NTM if the running time of its longest computation on x is polynomial in |x|. Lecture 7 Nondeterministic deciders ⇐⇒ Veriﬁers Theorem: For any language L ⊆ Σ∗, L has a nondeterministic poly-time decider ⇐⇒ L has a poly-time veriﬁer. Proof Sketch (⇐=): Let M be the veriﬁer. NTM N on input x does the following: 1 Write a certiﬁcate C nondeterministically. 2 Run M on ⟨x , C ⟩. Proof Sketch (=⇒): Let N be the nondeterministic decider. Veriﬁer M on ⟨x , C ⟩ computes: ▶ Simulate N on x , choosing transitions given by C . M accepts ⟨x , C ⟩ iﬀ x ∈ L and C is an accepting path of N on x . Lecture 7 Non-deterministic Polynomial-time Theorem: For any language L ⊆ Σ∗, L has a nondeterministic poly-time decider ⇐⇒ L has a poly-time veriﬁer. Deﬁnition: NP is the class of languages which have poly-time nonde- terministic deciders, or equivalently, have poly-time veriﬁers. Deﬁnition: NTIME(t(n)) = {L : L has a nondeterministic O(t(n)) time decider} Then NP = ∞⋃ k=1 NTIME(nk ) . ∴ SAT, GI, INDSET are all in NP. Lecture 7 P and NP Is P ⊆ NP? Yes (obviously) Is P = NP? Nobody knows . . . Find the answer and win USD 1,000,000! NP SAT INDSET GI? P GI? P=NP SAT INDSET GI Cook-Levin Theorem (informal): SAT ∈ P iﬀ P = NP. (Also INDSET ∈ P iﬀ P = NP.) Lecture 7","libVersion":"0.5.0","langs":""}