{"path":"Lectures/Lecture7.pdf","text":"Lecture 7: Time Complexity, P vs. NP Mika GÃ¶Ã¶s School of Computer and Communication Sciences Lecture 7 Time Complexity Lecture 7 Computability: worst case Computability: Worst Case <âˆž <âˆž <âˆž <âˆž <âˆž âˆž <âˆž <âˆž <âˆž <âˆž <âˆž <âˆž <âˆž <âˆž <âˆž âˆž <âˆž <âˆž <âˆž <âˆž â‹® â‹® ðœ€ 0 1 01 10 00 11 000 â‹® ð‘€ð´ ð‘€ðµ Does not halt on this input and, hence, is not a decider Number of configurations TM needs to reach an accept/reject state on this input Recognizers for a language ð¿; Which one is better? In the rest of the course we just consider decidable languages 001 010 In the rest of the course material we just consider decidable languages Lecture 7 A decidable language L 2 2 5 2 3 4 2 2 2 5 12 2 3 5 12 5 20 12 14 13 8 19 2 9 32 14 18 9 18 3 5 90 12 21 56 8 12 18 18 30 21 22 26 15 11 12 32 15 11 12 25 100 13 48 98 29 320 201 159 201 190 200 180 65 211 208 190 200 189 301 219 82 328 271 214 441 193 208 109 77 227 261 191 201 188 107 211 207 ðœ€ 0 1 01 10 00 11 000 001 ð‘€ð´ ð‘€ðµ ð‘€ð¶ ð‘€ðºð‘€ð¹ð‘€ð¸ð‘€ð· ð‘€ð» â‹¯ A Decidable Language ð¿ Inputs How to compare different deciders? 010 011 â‹® â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â€¦ â‹® â‹® â‹® â‹® â‹±â‹®â‹®â‹®â‹® Deciders for L: Number of configurations TM needs to reach an accept/reject state on this input How to compare diï¬€erent deciders? Lecture 7 Two deciders for L 2 4 12 15 22 17 110 49 34 38 300 ð‘€ð´ ð‘€ðµ 12 110 â‹® â‹® ðœ€ 0 1 01 10 00 11 â‹® 001 010 011 000 2 9 10 40 30 45 39 73 77 85 80 300 10 45 85 ðœ€ 0 1 01 10 00 11 â‹® 001 010 011 000 Worst case in this group 2 2 Two Deciders for ð¿ Lecture 7 Running time of a TM Deï¬nition: Let M be a TM that halts on all inputs (decider). The running time or time complexity of M is the function t : N â†’ N where t(n) = max w âˆˆÎ£âˆ—:|w |=n number of steps M takes on w â–¶ M runs in time t(n) â–¶ n represents the input length t(0) = 2 t(1) = 10 t(2) = 45 t(3) = 85 Running Time of a TM Definition: Let ð‘€be a TM that halts on all inputs (decider). The running time or time complexity of ð‘€is the function ð‘¡:â„•â†’ â„• where ð‘¡ð‘› = max ð‘¤âˆˆÎ£â‹†;ð‘¤ =ð‘› number of steps ð‘€takeson ð‘¤ - ð‘€runs in time ð‘¡ð‘› - ð‘›represents the input length 2 9 10 21 30 45 33 73 77 85 80 ð‘¡0 =2 ð‘¡1 =10 ð‘¡2 =45 ð‘¡3 =85 â‹® 10 45 85 ðœ€ 0 1 01 10 00 11 â‹® 001 010 011 000 2 Lecture 7 Two deciders for L Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 â‹® ð‘€ð´ ð‘€ðµ Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 â‹® ð‘¡1 1 =5 ð‘¡1 2 =9 ð‘¡1 3 =17 ð‘¡1 4 =33 ð‘¡1 5 =65 ð‘¡2 1 =8 ð‘¡2 2 =13 ð‘¡2 3 =18 ð‘¡2 4 =23 ð‘¡2 5 =28 â‹® â‹® ð‘¡2 0 =3ð‘¡1 0 =3 Two Deciders for ð¿ Lecture 7 0 10 20 30 40 50 60 70 0 1 2 3 4 5 ð‘¡1(ð‘›)=2 ð‘›+1+1 vs ð‘¡2(ð‘›)=5ð‘›+3 Time Input length How to compare running time functions? ð’‡ðŸ ð’ =ðŸð’, ð’‡ðŸ ð’ =ðŸ“ð’ðŸ‘+ðŸ, ð’‡ðŸ‘ ð’ =ðŸðŸŽð’+ðŸ” How to compare running time functions? Lecture 7 The Growth of Functions 50 100 150 0 20,000 40,000 60,000 2x 2 1000 log2(x ) 2 x Lecture 7 Big-O and Small-o notation Deï¬nition (Big-O): Let f , g : N â†’ Râ‰¥0. We say f (n) = O(g(n)) if âˆƒC > 0, n0 âˆˆ N s.t. âˆ€n â‰¥ n0 f (n) â‰¤ C Â· g(n) Examples: â–¶ 5n3 + 1 = O(2 n) ? YES â–¶ 5n3 + 1 = O(20n + 5) ? NO Deï¬nition (Small-o): Let f , g : N â†’ Râ‰¥0. We say f (n) = o(g(n)) if âˆ€c > 0, âˆƒn0 âˆˆ N s.t. âˆ€n â‰¥ n0 f (n) < c Â· g(n) Examples: â–¶ âˆšn = o(n) ? YES â–¶ f (n) = o(f (n)) ? NO Lecture 7 Length 0 Length 1 Length 2 Length 3 Length 4 Length 5 â‹® 0 100 200 300 400 500 600 1 2 3 4 5 6 7 8 9 10 11 12 t(.) 0 500 1000 1500 2000 2500 1 2 3 4 5 6 7 8 9 10 11 12 . ð‘¡ð‘› =ð‘‚ 2 ð‘› 2 ð‘› To Summarize .. â‹® ð‘¡1 =4 ð‘¡2 =3 ð‘¡3 =7 ð‘¡4 =15 ð‘¡5 =14 ð‘¡0 =2 10 2 3 4 2 4 3 â‹® â‹® 7 â‹® 6 â‹® 15 â‹® 10 8 â‹® 14 â‹® ð‘€ To summarize. . . Lecture 7 Time Complexity Deï¬nition: Time complexity class TIME (t(n)) = {L âŠ† Î£âˆ— | L is decided by a TM with running time O(t(n))} Example: TIME (n) âŠ† TIME (n2) âŠ† Â· Â· Â· âŠ† TIME (2 âˆš n) âŠ† TIME (2n) âŠ† TIME (22n ) . . . Example: REGULAR âŠ† TIME (n) Lecture 7 The complexity class P and eï¬ƒciency Deï¬nition: P is the class of languages that are decidable in polynomial time on a (deterministic) Turing machine. In other words, P = âˆžâ‹ƒ k=1 TIME (nk ) . Some languages in P: â–¶ {âŸ¨AâŸ© : A is a sorted array of integers} â–¶ {âŸ¨G, s, tâŸ© : s and t are vertices connected in graph G} (Breadth-First Search) â–¶ {âŸ¨GâŸ© : G is a connected graph} Lecture 7 NP: Veriï¬cation vs. Search Lecture 7 SAT-verify and SAT Conjunctive Normal Form (CNF) Formula: Ï•1 = (x âˆ¨ y âˆ¨ z0) âˆ§ (x âˆ¨ y âˆ¨ z1) âˆ§ (x âˆ¨ y âˆ¨ z2) âˆ§ (x âˆ¨ y âˆ¨ z3) Ï•2 = x1 âˆ§ (x1 âˆ¨ x2) âˆ§ (x1 âˆ¨ x2 âˆ¨ x3) âˆ§ (x1 âˆ¨ x2 âˆ¨ x3 âˆ¨ x4) Ï•3 = x1 âˆ§ (x1 âˆ¨ x2) âˆ§ (x1 âˆ¨ x2) â–¶ CNF Formula: AND of Clauses â–¶ Clause: OR of Literals â–¶ Literal: variable or its negation Satisfying assignment: Boolean assignment to variables which makes the formula TRUE. Check: Ï•1 has 32 satisfying assignments, Ï•2 has only one, Ï•3 has zero. A formula is satisï¬able if it has at least one satisfying assignment. Lecture 7 SAT-verify and SAT SAT-verify = {âŸ¨Ï•, C âŸ© : C is a satisfying assignment of Ï•} Is SAT-verify in P? Yes! 1 Substitute for literals according to C . 2 Check that every clause has at least one TRUE literal. SAT = {âŸ¨Ï•âŸ© : Ï• is satisï¬able} = {âŸ¨Ï•âŸ© : âˆƒC such that âŸ¨Ï•, C âŸ© âˆˆ SAT-verify} Is SAT in P? Decider for SAT: 1 For each assignment C : â–¶ If âŸ¨Ï•, C âŸ© âˆˆ SAT-verify, ACCEPT Ï•. 2 REJECT Ï•. Lecture 7 GI-verify and GI a bc d e f 1 2 3 4 5 6 Graph Isomorphism: Bijection f : V (G1) âˆ’â†’ V (G2) which preserves adjacency: {u, v } âˆˆ E (G1) â‡” {f (u), f (v )} âˆˆ E (G2) Eg. a â†’ 1 b â†’ 2 c â†’ 3 d â†’ 4 e â†’ 5 f â†’ 6 in the graphs above. Two graphs are isomorphic if they have at least one graph isomorphism. Lecture 7 GI-verify and GI GI-verify = {âŸ¨G1, G2, C âŸ© : C : V (G1) âˆ’â†’ V (G2) is a graph isomorphism} Is GI-verify in P? Yes! 1 Check that C is a bijection: For each u, v âˆˆ V (G1): â–¶ Check {u, v } âˆˆ E (G1) â‡” {C (u), C (v )} âˆˆ E (G2). GI = {âŸ¨G1, G2âŸ© : G1 and G2 are isomorphic} = {âŸ¨G1, G2âŸ© : âˆƒC such that âŸ¨G1, G2, C âŸ© âˆˆ GI-verify} Is GI in P? Decider for GI: 1 For each function C : V (G1) âˆ’â†’ V (G2): â–¶ If âŸ¨G1, G2, C âŸ© âˆˆ GI-verify, ACCEPT âŸ¨G1, G2âŸ©. 2 REJECT âŸ¨G1, G2âŸ©. Lecture 7 INDSET-verify and INDSET 1 2 3 4 5 6 Independent Set: Subset S âŠ† V (G) such that no two vertices in S are adjacent in G. Eg. {1, 3, 5}, {2, 4}, {6}, âˆ…, etc. in the graph above. Lecture 7 INDSET-verify and INDSET INDSET-verify = {âŸ¨G, k, C âŸ© : C is an independent set of size k in G} Is INDSET-verify in P? Yes! 1 Check that |C | = k. 2 For each u, v âˆˆ C : â–¶ Check {u, v } < E (G). INDSET = {âŸ¨G, kâŸ© : G has an independent of size k} = {âŸ¨G, kâŸ© : âˆƒC such that âŸ¨G, k, C âŸ© âˆˆ INDSET-verify} Is INDSET in P? Decider for INDSET: 1 For each subset C âŠ† V (G): â–¶ If âŸ¨G, k, C âŸ© âˆˆ INDSET-verify, ACCEPT âŸ¨G, kâŸ©. 2 REJECT âŸ¨G, kâŸ©. Lecture 7 Veriï¬ers and the class NP Recall: A decider for language L is a TM M such that for each x âˆˆ Î£âˆ— â–¶ If x âˆˆ L, then M accepts x . â–¶ If x < L, then M rejects x . Deï¬nition: A veriï¬er for language L is a TM M such that for each x âˆˆ Î£âˆ— â–¶ If x âˆˆ L, then there exists C such that M accepts âŸ¨x , C âŸ©. â–¶ If x < L, then for every C , M rejects âŸ¨x , C âŸ©. (C is called a certiï¬cate or witness) A veriï¬er is a polynomial time veriï¬er if its running time on any âŸ¨x , C âŸ© is polynomial in |x|. (Thus |C | is polynomial in |x |) Deï¬nition: NP is the class of languages that have poly-time veriï¬ers. Lecture 7 Why is it called NP? Lecture 7 Detour: Non-deterministic Turing Machines Recall: In a Turing machine, Î´ : (Q Ã— Î“) âˆ’â†’ Q Ã— Î“ Ã— {L, R}. In a Nondeterministic Turing Machine (NTM), Î´ : (Q Ã— Î“) âˆ’â†’ P(Q Ã— Î“ Ã— {L, R}) (several possible transitions for a given state and tape symbol) Deï¬nition: A nondeterministic decider for language L is an NTM N such that for each x âˆˆ Î£âˆ—, every computation of N on x halts, and moreover, â–¶ If x âˆˆ L, then some computation of N on x accepts. â–¶ If x < L, then every computation of N on x rejects. An NTM is a polynomial time NTM if the running time of its longest computation on x is polynomial in |x|. Lecture 7 Nondeterministic deciders â‡â‡’ Veriï¬ers Theorem: For any language L âŠ† Î£âˆ—, L has a nondeterministic poly-time decider â‡â‡’ L has a poly-time veriï¬er. Proof Sketch (â‡=): Let M be the veriï¬er. NTM N on input x does the following: 1 Write a certiï¬cate C nondeterministically. 2 Run M on âŸ¨x , C âŸ©. Proof Sketch (=â‡’): Let N be the nondeterministic decider. Veriï¬er M on âŸ¨x , C âŸ© computes: â–¶ Simulate N on x , choosing transitions given by C . M accepts âŸ¨x , C âŸ© iï¬€ x âˆˆ L and C is an accepting path of N on x . Lecture 7 Non-deterministic Polynomial-time Theorem: For any language L âŠ† Î£âˆ—, L has a nondeterministic poly-time decider â‡â‡’ L has a poly-time veriï¬er. Deï¬nition: NP is the class of languages which have poly-time nonde- terministic deciders, or equivalently, have poly-time veriï¬ers. Deï¬nition: NTIME(t(n)) = {L : L has a nondeterministic O(t(n)) time decider} Then NP = âˆžâ‹ƒ k=1 NTIME(nk ) . âˆ´ SAT, GI, INDSET are all in NP. Lecture 7 P and NP Is P âŠ† NP? Yes (obviously) Is P = NP? Nobody knows . . . Find the answer and win USD 1,000,000! NP SAT INDSET GI? P GI? P=NP SAT INDSET GI Cook-Levin Theorem (informal): SAT âˆˆ P iï¬€ P = NP. (Also INDSET âˆˆ P iï¬€ P = NP.) Lecture 7","libVersion":"0.5.0","langs":""}