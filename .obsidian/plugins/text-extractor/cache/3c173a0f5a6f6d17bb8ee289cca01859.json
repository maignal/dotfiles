{"path":"Homeworks/Solutions/HW3-sol.pdf","text":"Homework I, Theory of Computation 2025 Submission: The deadline for Homework 1 is 23:59 on 20 March. Please submit your solutions on Moodle. Typing your solutions using a typesetting system such as LATEX is strongly encouraged! If you must handwrite your solutions, write cleanly and with a pen. Messy and unreadable homeworks will not be graded. No late homeworks will be accepted. Writing: Please be precise, concise and (reasonably) formal. Keep in mind that many of the problems ask you to provide a proof of a statement (as opposed to, say, just to provide an example). Therefore, make sure that your reasoning is correct and there are no holes in it. A solution that is hard/impossible to decipher/follow might not get full credit (even if it is in principle correct). You do not need to reprove anything that was shown in the class—just state clearly what was proved and where. Collaboration: These problem sets are meant to be worked on in groups of 2–4 students. Please submit only one writeup per team—it should contain the names of all the students. You are strongly encouraged to solve these problems by yourself. If you must, you may use books or online resources to help solve homework problems, but you must credit all such sources in your writeup and you must never copy material verbatim. Even though only one writeup is submitted, it is expected that each one of the team members is able to fully explain the solutions if requested to do so. Grading: Each of the two problems will be graded on a scale from 0 to 5. Warning: Your attention is drawn to the EPFL policy on academic dishonesty. In particular, you should be aware that copying solutions, in whole or in part, from other students in the class or any other source (e.g., ChatGPT) without acknowledgement constitutes cheating. Any student found to be cheating risks automatically failing the class and being referred to the appropriate office. Page 1 (of 5) CS-251 Theory of Computation • Spring 2025 Homework 1 1 We say that a word u = a1 · · · an is a compression of w ∈ Σ∗, denoted by u ⪯ w, if there are words w0, . . . , wn ∈ Σ∗ such that w = w0a1w1a2 · · · anwn. For a language L ⊆ Σ∗ define ↑ L = {u ∈ Σ∗ : w ⪯ u for some w ∈ L}, ↓ L = {u ∈ Σ∗ : u ⪯ w for some w ∈ L}. Show that if L is regular, then both ↑ L and ↓ L are also regular. 2 Let Σn = {1, 2, ..., n} be an alphabet with n symbols. Define language Ln to be the set of all words w ∈ Σ∗ n such that at least one symbol of Σn does not appear in w. So, for instance, 2112, 23, 2222 ∈ L3 and 123, 3312 /∈ L3. 2a Give a NFA for Ln with O(n) states. 2b Give a DFA for Ln with 2n states. 2c Show that any DFA for Ln has at least 2n states. (Hint: If a DFA uses fewer than 2n states, use a pigeonhole argument to find two (cleverly chosen) words that lead to the same state.) 1 Solution to Question 1 We say that a word u = a1 · · · an is a compression of w ∈ Σ∗, denoted by u ⪯ w, if there are words w0, . . . , wn ∈ Σ∗ such that w = w0a1w1a2 · · · anwn. For a language L ⊆ Σ∗ define ↑ L = {u ∈ Σ∗ : w ⪯ u for some w ∈ L}, ↓ L = {u ∈ Σ∗ : u ⪯ w for some w ∈ L}. Show that if L is regular, then both ↑ L and ↓ L are also regular. Solution : To prove that ↑ L is regular we design a NFA that accepts ↑ L. Since L is a regular language this means that there exists a DFA that accepts it. Let M = (Q, Σ, δ, q0, F ) be this DFA. A word u belongs to ↑ L if and only if there exist a compression of u that belongs to L. Essentially, this means that if we remove some characters of u we obtain a string in L. The problem is that we do not know which characters we should keep in u and which one we should remove. This is why we will build an NFA for ↑ L. The NFA will account for this uncertainty. Let N↑ = (Q, Σ, δ↑, q0, F ) be a NFA. Note that the individual components of N↑ are practically identic to the ones of M up to transition function that differs. We define the transition function as follow : δ↑(q, a) = { {δ(q, a), q}, if a ∈ Σ ∅, if a = ε Claim : N↑ recognizes ↑ L. What the transition function δ↑ allows us to do is to ignore some characters of u non-deterministically by staying in our current state q. If a word u belongs to ↑ L we know that u can be decomposed in the following way : u = w0a0w1a1...wnan with w0, ...wn, a1, ..., an ∈ Σ∗ such that w = w0w1...wn ∈ L. This is because we know that there exists at least one word w in L that is a compression of u. Thus, crossing out all the characters of Page 2 (of 5) CS-251 Theory of Computation • Spring 2025 a0, a1, ..., an in u will effectively yield a word in L. It is guaranteed that one of the computing branches of the NFA N↑ will ignore exactly those characters in a0, a1, ..., an yielding to a path that accepts u. Finally if u is not in ↑ L then no matter what characters we ignore we will never reach an accept state since no compression of u is in L. Consequently, all the computational branches of N↑ will reject u. From this we get that u is accepted by N↑ if and only if u ∈↑ L ie. N↑ recognizes ↑ L. From this we immediatly get that ↑ L is regular. Now let’s prove that ↓ L is regular. Again, we will design a NFA that accepts ↓ L for that purpose. A word u belongs to ↓ L if and only if it is a compression of some word w ∈ L. This essentially means that u by inserting some characters in u we obtain a word w in L. The issue here is that we do not know which characters to insert, nor do we know where. Hence why, again, there is use for a non-deterministic finite automaton here. Again, consider the DFA M = (Q, Σ, δ, q0, F ) that accepts L. Let N↓ = (Q, Σ, δ↓, q0, F ) be a NFA. Note that, again, the components of the tuple of N↓ are identical to the elements of M up to the transition function. We define the transition function as follow : δ↓(q, a) = { {δ(q, a)}, if a ∈ Σ {q′ ∈ Q | ∃s ∈ Σ : δ(q, s) = q′}, if a = ε Claim : N↓ recognizes ↓ L. N↓ is quite similar to M. The only change we made is that we added some epsilon transitions to it. These epsilon transitions allow us to do as if we were adding some characters to our string u to make it belong to L. This is done in a non-deterministic way to account for the fact that we do not know where and what characters to insert in u. More formally, given a word u ∈↓ L, we now that there exists a word w ∈ L such that w can be decomposed in the following way : w = u0a0u1a1...unan with u0, ..., un, a0, ..., an ∈ Σ∗ such that u = u0u1...un. By inserting the words a0, ..., an in u in the right positions, we would obtain the word w ∈ L. There is at least one computational path in N↓ that will take the right epsilon transitions to do as if those words a0, ..., an were added to u at the right position. This path will lead to an accept state as w ∈ L. Thus N↓ will accept u. Conversely if u does not belong to ↓ L then no matter what words and where we insert these words in u we will never obtain a word w in L. Suppose that one computational branch in N↓ ends up in an accept state. This would mean that by inserting some characters in u (or inserting none) we obtain a word belonging to L. This would imply that u belongs to ↓ L, contradicting our hypothesis. Thus no computational branch in N↓ terminates in an accept state ie. N↓ does not accept u. We have showed that N↓ accepts u if and only if u belongs to ↓ L. Thus, ↓ L is indeed regular. 2 Grading scheme to Question 1 1. (1.5 Points) Explains clearly that since L is regular it has a corresponding DFA/NFA. Uses the DFA/NFA of L to build a DFA/NFA for ↑ L and ↓ L. 2. (1.0 Points) Gives a correct DFA/NFA for ↑ L 3. (0.5 Points) Solid explanation for the correctness of the given DFA/NFA for ↑ L. Full points for an argument involving a double implication (u ∈ L(N ) ⇐⇒ u ∈↑ L). 4. (1.0 Points) Gives a correct DFA/NFA for ↓ L 5. (0.5 Points) Solid explanation for the correctness of the given DFA/NFA for ↓ L. Full points for an argument involving a double implication (u ∈ L(N ) ⇐⇒ u ∈↓ L). 6. (0.5 Points) The formalism is correct. The notation used is clear. No confusion between singletons and states (between q and {q}). Page 3 (of 5) CS-251 Theory of Computation • Spring 2025 3 Solution to Question 2 2a: Construction of an NFA Consider a language Mn,i := {x ∈ Σ∗ n | x does not contain i}. Then Ln = ⋃i∈[n] Mn,i (here [n] = {1, 2, . . . , n}). Lemma 3.1. If languages S1, . . . , Sn are recognized by NFAs N1, . . . , Nn of sizes ℓ1, . . . , ℓn respectively, then S := ⋃i∈[n] Sn is recognized by an NFA of size ∑ i∈[n] ℓi. Proof. Construct the NFA for S as follows: let us unite the NFAs N1, . . . , Nn preserving the transitions and final state, set the starting state qstart of the NFA as the starting state of N1 and add ϵ-transitions from qstart to the starting states of N2, . . . , Nn. Then any word accepted by any of N1, . . . , Nn is accepted by the new NFA (take the corresponding ϵ-transition and follow an accepting path in the corresponding NFA). On the other hand, if a word w is accepted by the constructed NFA, observe that the accepting path must either be within the copy of N1 or start with an ϵ-transition and continue within some Ni, hence, removing the first ϵ-transition we get an accepting path in one of Ni. By Lemma 3.1 it suffices to show that each Mn,i is recognizable by an DFA∗ with O(1) states. Consider an DFA with Q = {accept, reject} and with the transitions defined as δ(accept, i) = reject, and δ(q, j) = q for (q, j) ∈ {accept, reject} × [n] \\ (accept, i). The starting and the only accepting state is accept. It is easy to see that the given DFA recognizes Mn,i: for a word w = u ◦ i ◦ v ∈ Mn,i we have δ(accept, w) = δ(δ(δ(accept, u), i), v) = δ(δ(q, i), v) = δ(reject, v) = reject. For a word w ̸∈ Mn,i δ(accept, w) = accept, since the i-transition is never taken. 2b: Construction of a DFA Let Dn,i = (Qi, Σn, δi, accepti, accepti) be the 2-state DFA that recognizes Mn,i. We need to construct a DFA that accepts a word if and only if one of Dn,1, . . . , Dn,n accepts it. Let D = (Q1 × · · · × Qn, Σn, δ, (accept1, . . . , acceptn), F ) with δ((q1, . . . , qn), a) = (δ1(q1, a), . . . , δn(qn, a)) and F = {(q1, . . . , qn) | ∃i ∈ [n] : qi = accepti}. In words, the state of D after reading a word w is the tuple of states of Mn,1, . . . , Mn,i after reading w. The number of states in D is |Q1| · |Q2| · · · · · |Qn| = 2n as required. By definition of accepting states, D accepts precisely the words in ⋃i∈[n] Mn,i = Ln. 2c: Lower bound on the number of states in a DFA Suppose that there exists a DFA D with fewer than 2n states accepting Ln. For every set I ⊆ [n] define wI = i1 ◦ · · · ◦ i|I| where I = {i1, . . . , i|I|} and i1 < · · · < i|I| (the ordering is just for concreteness, any word containing all symbols in I and only them works). Then by the pigeonhole principle there exist two words wI and wJ such that I ̸= J and δ(qstart, wI ) = δ(qstart, wJ ) = q. Without loss of generality, suppose I \\ J ̸= ∅. Then q1 := δ(qstart, wJ ◦ w[n]\\I ) is an accepting state since wJ ◦ w[n]\\I does not contain any symbols in I \\ J. On the other hand, q2 := δ(qstart, wI ◦ w[n]\\I ) is not an accepting state since the word wI ◦ w[n]\\I contains all symbols of Σn. But q1 = q2 = δ(q, w[n]\\I ), which is a contradiction. ∗An NFA would have sufficed, but an NFA has a constant number of state if and only if a DFA does. Page 4 (of 5) CS-251 Theory of Computation • Spring 2025 Grading Scheme (2a) 1.5 points; -0.5 points if the proof of correctness is imperfect or missing; (2b) 1.5 points; -0.5 points if the proof of correctness is imperfect or missing; (2c) 2 points: • 0.5 points if there is some intuitive justification or a proof in assumption that the DFA must adhere to the structure described in 2b. • 2 points for a perfect proof; -0.5 points for minor issues in a correct proof. A common mistake: applying the pigeonhole principle we get that some words w and w′ both arrive at some state q of an automaton. One cannot then assume that w and w′ have some extra properties that some of the words in the collection do not have (e.g. w containing all symbols of Σn). Page 5 (of 5) CS-251 Theory of Computation • Spring 2025","libVersion":"0.5.0","langs":""}