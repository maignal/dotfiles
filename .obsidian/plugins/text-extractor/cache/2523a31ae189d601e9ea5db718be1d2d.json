{"path":"Lectures/Lecture6-recap.pdf","text":"Lecture 6 Recap: Reductions Mika GÃ¶Ã¶s School of Computer and Communication Sciences Lecture 6 Recap Reductions Lecture 6 Recap Informally Reducibility Use knowledge about complexity of one language to reason about the complexity of other in an easy way Reduction Way to show that to solve one problem (A), it is suï¬ƒcient to solve another problem (B) A reduces to B. . . â–¶ Many examples (e.g. calculate area of rectangle reduces to calculate its width and height) â–¶ Reductions quantify relative hardness of problems â–¶ If problem B is easy then problem A is easy too â–¶ If problem A is hard then problem B is hard too Lecture 6 Recap A reduction f from triangle to rectangle area Triangle-Area = {âŸ¨h, b, tâŸ© âˆˆ {0, 1} âˆ— | h âˆ— b/2 â‰¥ t} b h In language if area is at least t Rectangle-Area = {âŸ¨h, b, r âŸ© âˆˆ {0, 1} âˆ— | h âˆ— b â‰¥ r } h b In language if area is at least r Suppose we have a Turing machine TMRA for deciding Rectangle-Area. How can we use it form a decider TMTA for Triangle-Area? TMTA TMRAreduction fâŸ¨h, b, tâŸ© âˆˆ {0, 1}âˆ— âŸ¨h, b, r âŸ© accept reject Lecture 6 Recap A reduction f from triangle to rectangle area TMTA TMRAreduction fâŸ¨h, b, tâŸ© âˆˆ {0, 1}âˆ— âŸ¨h, b, r âŸ© accept reject Deï¬ne f (âŸ¨h, b, tâŸ©) = âŸ¨h, b, 2tâŸ©. Then Triangle-Area Triangle-Area Rectangle-Area Rectangle-Area f â–¶ f does not use the knowledge whether input is in language or not â–¶ f can be computed with a TM Lecture 6 Recap Mapping Reductions Lecture 6 Recap Reductions Part 1: Computability Reductions Part 1: Computability 0 0 1 0 1 1 0 1 âŠ” 1 1 1 0 âŠ” âŠ” âŠ” âŠ” âŠ” ğ‘¤ ğ‘‡ğ‘€ğ‘“ ğ‘“(ğ‘¤) ğ‘“ Î£ â‹† Î£ â‹† ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘£1 ğ‘£2 ğ‘£3ğ‘¤4 ğ‘£3ğ‘¤4 Definition: A function ğ‘“:Î£ â‹†â†’ Î£ â‹†is a computable function if some TM ğ‘€, on every input ğ‘¤ halts with just ğ‘“(ğ‘¤)on its tape Deï¬nition: A function f : Î£ âˆ— â†’ Î£âˆ— is a computable function if some TM M, on every input w halts with just f (w ) on its tape Lecture 6 Recap Reductions Part 2: Correctness Reductions Part 2: Correctness Definition: Language ğ´ is mapping reducible to language ğµ,written ğ‘¨ â‰¤ğ’ ğ‘©,if there is a computable function ğ‘“:Î£ â‹†â†’ Î£ â‹†,such that for every ğ‘¤ âˆˆÎ£ â‹†: ğ’˜âˆˆğ‘¨ âŸº ğ’‡ğ’˜ âˆˆğ‘© Î£ â‹† Î£ â‹† ğ‘“ ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘£1 ğ‘£2 ğ‘£3 ğ´ ğ‘¤4à´¥ğ´ ğµ à´¤ğµğ‘£4ğ‘¤4 Reduction Mapping may not be Surjective ğ‘£3 ğ‘£5 Deï¬nition: Language A is mapping reducible to language B, written A â‰¤m B, if there is a computable function f : Î£ âˆ— â†’ Î£âˆ—, such that for every w âˆˆ Î£âˆ—: w âˆˆ A â‡” f (w ) âˆˆ B Lecture 6 Recap Theorem: If A â‰¤m B and B is decidable, then A is decidable Proof: â–¶ Assume that M is a decided for B and f is a reduction from A to B â–¶ Let N be a TM as follows: â€¢ Assume that ğ‘´ is a decider for ğ‘©and ğ‘“is a reduction from ğ´ to ğµ â€¢ Let ğ‘ be a TM as follows: â€¢ ğ‘ =â€œOn input ğ‘¤: 1. Compute ğ‘“(ğ‘¤) 2. Run ğ‘€ on input ğ‘“(ğ‘¤)and output whatever ğ‘€ outputs\" ğ‘¤ ğ‘“(ğ‘¤) ğ‘€ ğ‘ ğ‘“ Computability of ğ‘“â‡’ N is a decider Correctness of ğ‘“â‡’ N decides A Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is decidable, then ğ´ is decidable Corollary: If ğ´ â‰¤ğ‘š ğµ and ğ´ is undecidable, then ğµ is undecidable Proof: â–¶ N = â€œOn input w : 1 Compute f (w ) 2 Run M on input f (w ) and output whatever M outputsâ€ â€¢ Assume that ğ‘´ is a decider for ğ‘©and ğ‘“is a reduction from ğ´ to ğµ â€¢ Let ğ‘ be a TM as follows: â€¢ ğ‘ =â€œOn input ğ‘¤: 1. Compute ğ‘“(ğ‘¤) 2. Run ğ‘€ on input ğ‘“(ğ‘¤)and output whatever ğ‘€ outputs\" ğ‘¤ ğ‘“(ğ‘¤) ğ‘€ ğ‘ ğ‘“ Computability of ğ‘“â‡’ N is a decider Correctness of ğ‘“â‡’ N decides A Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is decidable, then ğ´ is decidable Corollary: If ğ´ â‰¤ğ‘š ğµ and ğ´ is undecidable, then ğµ is undecidable Proof: â€¢ Assume that ğ‘´ is a decider for ğ‘©and ğ‘“is a reduction from ğ´ to ğµ â€¢ Let ğ‘ be a TM as follows: â€¢ ğ‘ =â€œOn input ğ‘¤: 1. Compute ğ‘“(ğ‘¤) 2. Run ğ‘€ on input ğ‘“(ğ‘¤)and output whatever ğ‘€ outputs\" ğ‘¤ ğ‘“(ğ‘¤) ğ‘€ ğ‘ ğ‘“ Computability of ğ‘“â‡’ N is a decider Correctness of ğ‘“â‡’ N decides A Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is decidable, then ğ´ is decidable Corollary: If ğ´ â‰¤ğ‘š ğµ and ğ´ is undecidable, then ğµ is undecidable Proof: Corollary: If A â‰¤m B and A is undecidable, then B is undecidable Lecture 6 Recap Examples of Reductions Lecture 6 Recap HALTTM = {âŸ¨M, w âŸ© | M halts on w } ATM = {âŸ¨M, w âŸ© | M accepts w } Theorem: ATM â‰¤m HALTTM Proof idea: TMATM TMHALTreduction fâŸ¨M, w âŸ© âˆˆ {0, 1} âˆ— âŸ¨M â€², w â€²âŸ© accept reject Deï¬ne computable f such that ATM ATM HALTTM HALTTM f Lecture 6 Recap Theorem: ATM â‰¤m HALTTM (â‡’ HALTTM is undecidable) â–¶ Let us deï¬ne a function f as follows â–¶ Given an input x = âŸ¨M, w âŸ©, return f (x ) = âŸ¨M â€², w âŸ©, where â–¶ M â€² =â€œOn input y : 1 Run M on w ; 2 If M rejects w , enter inï¬nite loop. Otherwise, accept y â€ â–¶ Check that f is computable â€¢ Let us define a function ğ‘“as follows â€¢ Given an input ğ‘¥ â‰” ğ‘€,ğ‘¤ , return ğ‘“ğ‘¥ â‰” ğ‘€â€²,ğ‘¤ where â€¢ ğ‘€â€™=â€œOn input ğ‘¦ âˆ¶ (1) Run ğ‘€ on ğ‘¤; (2) If ğ‘´ rejects ğ’˜, enter infinite loop. Otherwise, accept y\" â€¢ Check that ğ‘“is computable Theorem: ğ´ğ‘‡ğ‘€â‰¤ğ‘š ğ»ğ´ğ¿ğ‘‡ğ‘‡ğ‘€ (â‡’ ğ»ğ´ğ¿ğ‘‡ğ‘‡ğ‘€is undecidable) â€¢ â‡’If ğ‘€,ğ‘¤ âˆˆ ğ´ğ‘‡ğ‘€then ğ‘€â€²halts on ğ‘¤. Thus, ğ‘€â€²,ğ‘¤ âˆˆ ğ»ğ´ğ¿ğ‘‡ğ‘‡ğ‘€ â€¢ ÖšIf ğ‘€,ğ‘¤ âˆ‰ ğ´ğ‘‡ğ‘€then either (1) will never halt or ğ‘€ rejects ğ‘¤ and (2) will ensure no halting. Thus, ğ‘€â€²,ğ‘¤ âˆ‰ ğ»ğ´ğ¿ğ‘‡ğ‘‡ğ‘€ ğ‘“has to write down the code of ğ‘€â€²only. It does not run ğ‘€â€²! (ğ‘€â€²might loop for some inputs.) â–¶ â‡’ If âŸ¨M, w âŸ© âˆˆ ATM then M â€² halts on w . Thus, âŸ¨M â€², w âŸ© âˆˆ HALTTM â–¶ â‡ If âŸ¨M, w âŸ© < ATM then either (1) will never halt or M rejects w and (2) will ensure no halting. Thus, âŸ¨M â€², w âŸ© < HALTTM Lecture 6 Recap REGTM = {âŸ¨NâŸ© | L(N) is a regular language} Theorem: REGTM is undecidable Proof idea: reduction from ATM TMATM TMREGreduction fâŸ¨M, w âŸ© âˆˆ {0, 1} âˆ— âŸ¨NâŸ© accept reject Deï¬ne computable f such that ATM ATM REGTM REGTM f Lecture 6 Recap Theorem: ATM â‰¤m REGTM (â‡’ REGTM is undecidable) â–¶ Let us deï¬ne a function f as follows â–¶ Given an input x = âŸ¨M, w âŸ©, return f (x ) = âŸ¨M â€²âŸ©, where â–¶ M â€² =â€œOn input y : 1 if y âˆˆ B = {0n1n : n â‰¥ 0}, then accept y 2 Run M on w , and accept y iï¬€ M accepts w â€ â–¶ Check that f is computable â–¶ â‡’ If âŸ¨M, w âŸ© âˆˆ ATM then M â€² accepts all inputs. Thus, L(M â€²) = {0, 1} âˆ— is regular â€” âŸ¨M â€²âŸ© âˆˆ REGTM â–¶ â‡ If âŸ¨M, w âŸ© < ATM then M does not accept w . Thus L(M â€²) = B is non-regular â€” âŸ¨M â€²âŸ© < REGTM Lecture 6 Recap Theorem: If A â‰¤m B and B is recognizable then A is recognizable Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is recognizable, then ğ´ is recognizable ğ‘€accepts ğ‘¤ âŸº ğ‘…ğµaccepts ğ‘“ğ‘¤ âŸº ğ‘“ğ‘¤ âˆˆğµ âŸº ğ‘¤âˆˆğ´ Definition of ğ‘€ ğ´ â‰¤ğ‘š ğµ ğ‘…ğµis a recognizer for ğµ â‡’ ğ‘´ is a recognizer for ğ‘¨ ğ‘¤ ğ‘“ğ‘¤ ğ‘…ğµ ğ‘€ ğ‘“ Corollary: If ğ´ â‰¤ğ‘š ğµ and A is unrecognizable, then ğµ is unrecognizable Proof. Corollary: If A â‰¤m B and A is unrecognizable then B is unrecognizable Lecture 6 Recap EQTM = {âŸ¨M1, M2âŸ© | M1, M2 are TMs s.t. L(M1) = L(M2)} Theorem: EQTM is unrecognizable Proof idea: reduction from ATM TMATM TMEQreduction fâŸ¨M, w âŸ© âˆˆ {0, 1} âˆ— âŸ¨M1, M2âŸ© accept reject Deï¬ne computable f such that ATM ATM EQTM EQTM f Lecture 6 Recap EQTM = {âŸ¨M1, M2âŸ© | M1, M2 are TMs s.t. L(M1) = L(M2)} Theorem: ATM â‰¤m EQTM (â‡’ EQTM is unrecognizable) â–¶ Let us deï¬ne a function f as follows â–¶ Given an input x = âŸ¨M, w âŸ©, return f (x ) = âŸ¨M1, M2âŸ©, where â–¶ M1 =â€œOn input y : 1 Run M on w (ignore the input y ) 2 If M accepts then accept, else enter an inï¬nite loop â–¶ M2 =â€œOn input y : 1 Reject y â–¶ â‡’ If âŸ¨M, w âŸ© âˆˆ ATM then M1 loops on all inputs. Thus, L(M1) = âˆ… = L(M2) â€” âŸ¨M1, M2âŸ© âˆˆ EQTM â–¶ â‡ If âŸ¨M, w âŸ© < ATM then M accepts w and hence M1 accepts every string. Thus L(M1) = Î£ âˆ— , âˆ… = L(M2) â€” âŸ¨M1, M2âŸ© < EQTM Lecture 6 Recap Summary of Reductions Summary Definition: ğ‘“:Î£1 â‹†â†’ Î£2 â‹†is a computable function if some TM ğ‘€, on every input ğ‘¤halts with just ğ‘“(ğ‘¤)on its tape Definition: ğ´ is mapping reducible to ğµ,(ğ´ â‰¤ğ‘š ğµ),if there exists ğ‘“:Î£1 â‹†â†’ Î£2 â‹†, ğ‘“computable, s.t. âˆ€ğ‘¤âˆˆÎ£â‹†: ğ‘¤âˆˆAâŸº ğ‘“ğ‘¤ âˆˆğµ ğ‘“is called a reduction of ğ´ to ğµ Theorem: If ğ´ â‰¤ğ‘š ğµ and ğµ is recognizable (decidable), then ğ´ is recognizable (decidable) Theorem: If ğ´ â‰¤ğ‘š ğµ and A is unrecognizable (undecidable) , then ğµ is unrecognizable (undecidable) ğ´ ğµğ‘“ ğ‘“ Î£â‹† Î£ â‹† Deï¬nition: A function f : Î£âˆ— â†’ Î£âˆ— is a computable function if some TM M, on every input w halts with just f (w ) on its tape Deï¬nition: Language A is mapping reducible to language B, written A â‰¤m B, if there is a computable function f : Î£âˆ— â†’ Î£âˆ—, such that for every w âˆˆ Î£âˆ—: w âˆˆ A â‡” f (w ) âˆˆ B f is called a reduction of A to B Theorem: If A â‰¤m B and B is decidable (recognizable), then A is decidable (recognizable) Corollary: If A â‰¤m B and A is undecidable (unrecognizable) then B is undecidable (unrecognizable) Lecture 6 Recap","libVersion":"0.5.0","langs":""}