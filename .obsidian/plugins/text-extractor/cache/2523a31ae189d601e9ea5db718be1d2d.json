{"path":"Lectures/Lecture6-recap.pdf","text":"Lecture 6 Recap: Reductions Mika Göös School of Computer and Communication Sciences Lecture 6 Recap Reductions Lecture 6 Recap Informally Reducibility Use knowledge about complexity of one language to reason about the complexity of other in an easy way Reduction Way to show that to solve one problem (A), it is suﬃcient to solve another problem (B) A reduces to B. . . ▶ Many examples (e.g. calculate area of rectangle reduces to calculate its width and height) ▶ Reductions quantify relative hardness of problems ▶ If problem B is easy then problem A is easy too ▶ If problem A is hard then problem B is hard too Lecture 6 Recap A reduction f from triangle to rectangle area Triangle-Area = {⟨h, b, t⟩ ∈ {0, 1} ∗ | h ∗ b/2 ≥ t} b h In language if area is at least t Rectangle-Area = {⟨h, b, r ⟩ ∈ {0, 1} ∗ | h ∗ b ≥ r } h b In language if area is at least r Suppose we have a Turing machine TMRA for deciding Rectangle-Area. How can we use it form a decider TMTA for Triangle-Area? TMTA TMRAreduction f⟨h, b, t⟩ ∈ {0, 1}∗ ⟨h, b, r ⟩ accept reject Lecture 6 Recap A reduction f from triangle to rectangle area TMTA TMRAreduction f⟨h, b, t⟩ ∈ {0, 1}∗ ⟨h, b, r ⟩ accept reject Deﬁne f (⟨h, b, t⟩) = ⟨h, b, 2t⟩. Then Triangle-Area Triangle-Area Rectangle-Area Rectangle-Area f ▶ f does not use the knowledge whether input is in language or not ▶ f can be computed with a TM Lecture 6 Recap Mapping Reductions Lecture 6 Recap Reductions Part 1: Computability Reductions Part 1: Computability 0 0 1 0 1 1 0 1 ⊔ 1 1 1 0 ⊔ ⊔ ⊔ ⊔ ⊔ 𝑤 𝑇𝑀𝑓 𝑓(𝑤) 𝑓 Σ ⋆ Σ ⋆ 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3𝑤4 𝑣3𝑤4 Definition: A function 𝑓:Σ ⋆→ Σ ⋆is a computable function if some TM 𝑀, on every input 𝑤 halts with just 𝑓(𝑤)on its tape Deﬁnition: A function f : Σ ∗ → Σ∗ is a computable function if some TM M, on every input w halts with just f (w ) on its tape Lecture 6 Recap Reductions Part 2: Correctness Reductions Part 2: Correctness Definition: Language 𝐴 is mapping reducible to language 𝐵,written 𝑨 ≤𝒎 𝑩,if there is a computable function 𝑓:Σ ⋆→ Σ ⋆,such that for every 𝑤 ∈Σ ⋆: 𝒘∈𝑨 ⟺ 𝒇𝒘 ∈𝑩 Σ ⋆ Σ ⋆ 𝑓 𝑤1 𝑤2 𝑤3 𝑣1 𝑣2 𝑣3 𝐴 𝑤4ഥ𝐴 𝐵 ത𝐵𝑣4𝑤4 Reduction Mapping may not be Surjective 𝑣3 𝑣5 Deﬁnition: Language A is mapping reducible to language B, written A ≤m B, if there is a computable function f : Σ ∗ → Σ∗, such that for every w ∈ Σ∗: w ∈ A ⇔ f (w ) ∈ B Lecture 6 Recap Theorem: If A ≤m B and B is decidable, then A is decidable Proof: ▶ Assume that M is a decided for B and f is a reduction from A to B ▶ Let N be a TM as follows: • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: ▶ N = “On input w : 1 Compute f (w ) 2 Run M on input f (w ) and output whatever M outputs” • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: • Assume that 𝑴 is a decider for 𝑩and 𝑓is a reduction from 𝐴 to 𝐵 • Let 𝑁 be a TM as follows: • 𝑁 =“On input 𝑤: 1. Compute 𝑓(𝑤) 2. Run 𝑀 on input 𝑓(𝑤)and output whatever 𝑀 outputs\" 𝑤 𝑓(𝑤) 𝑀 𝑁 𝑓 Computability of 𝑓⇒ N is a decider Correctness of 𝑓⇒ N decides A Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is decidable, then 𝐴 is decidable Corollary: If 𝐴 ≤𝑚 𝐵 and 𝐴 is undecidable, then 𝐵 is undecidable Proof: Corollary: If A ≤m B and A is undecidable, then B is undecidable Lecture 6 Recap Examples of Reductions Lecture 6 Recap HALTTM = {⟨M, w ⟩ | M halts on w } ATM = {⟨M, w ⟩ | M accepts w } Theorem: ATM ≤m HALTTM Proof idea: TMATM TMHALTreduction f⟨M, w ⟩ ∈ {0, 1} ∗ ⟨M ′, w ′⟩ accept reject Deﬁne computable f such that ATM ATM HALTTM HALTTM f Lecture 6 Recap Theorem: ATM ≤m HALTTM (⇒ HALTTM is undecidable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M ′, w ⟩, where ▶ M ′ =“On input y : 1 Run M on w ; 2 If M rejects w , enter inﬁnite loop. Otherwise, accept y ” ▶ Check that f is computable • Let us define a function 𝑓as follows • Given an input 𝑥 ≔ 𝑀,𝑤 , return 𝑓𝑥 ≔ 𝑀′,𝑤 where • 𝑀’=“On input 𝑦 ∶ (1) Run 𝑀 on 𝑤; (2) If 𝑴 rejects 𝒘, enter infinite loop. Otherwise, accept y\" • Check that 𝑓is computable Theorem: 𝐴𝑇𝑀≤𝑚 𝐻𝐴𝐿𝑇𝑇𝑀 (⇒ 𝐻𝐴𝐿𝑇𝑇𝑀is undecidable) • ⇒If 𝑀,𝑤 ∈ 𝐴𝑇𝑀then 𝑀′halts on 𝑤. Thus, 𝑀′,𝑤 ∈ 𝐻𝐴𝐿𝑇𝑇𝑀 • ֚If 𝑀,𝑤 ∉ 𝐴𝑇𝑀then either (1) will never halt or 𝑀 rejects 𝑤 and (2) will ensure no halting. Thus, 𝑀′,𝑤 ∉ 𝐻𝐴𝐿𝑇𝑇𝑀 𝑓has to write down the code of 𝑀′only. It does not run 𝑀′! (𝑀′might loop for some inputs.) ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M ′ halts on w . Thus, ⟨M ′, w ⟩ ∈ HALTTM ▶ ⇐ If ⟨M, w ⟩ < ATM then either (1) will never halt or M rejects w and (2) will ensure no halting. Thus, ⟨M ′, w ⟩ < HALTTM Lecture 6 Recap REGTM = {⟨N⟩ | L(N) is a regular language} Theorem: REGTM is undecidable Proof idea: reduction from ATM TMATM TMREGreduction f⟨M, w ⟩ ∈ {0, 1} ∗ ⟨N⟩ accept reject Deﬁne computable f such that ATM ATM REGTM REGTM f Lecture 6 Recap Theorem: ATM ≤m REGTM (⇒ REGTM is undecidable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M ′⟩, where ▶ M ′ =“On input y : 1 if y ∈ B = {0n1n : n ≥ 0}, then accept y 2 Run M on w , and accept y iﬀ M accepts w ” ▶ Check that f is computable ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M ′ accepts all inputs. Thus, L(M ′) = {0, 1} ∗ is regular — ⟨M ′⟩ ∈ REGTM ▶ ⇐ If ⟨M, w ⟩ < ATM then M does not accept w . Thus L(M ′) = B is non-regular — ⟨M ′⟩ < REGTM Lecture 6 Recap Theorem: If A ≤m B and B is recognizable then A is recognizable Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is recognizable, then 𝐴 is recognizable 𝑀accepts 𝑤 ⟺ 𝑅𝐵accepts 𝑓𝑤 ⟺ 𝑓𝑤 ∈𝐵 ⟺ 𝑤∈𝐴 Definition of 𝑀 𝐴 ≤𝑚 𝐵 𝑅𝐵is a recognizer for 𝐵 ⇒ 𝑴 is a recognizer for 𝑨 𝑤 𝑓𝑤 𝑅𝐵 𝑀 𝑓 Corollary: If 𝐴 ≤𝑚 𝐵 and A is unrecognizable, then 𝐵 is unrecognizable Proof. Corollary: If A ≤m B and A is unrecognizable then B is unrecognizable Lecture 6 Recap EQTM = {⟨M1, M2⟩ | M1, M2 are TMs s.t. L(M1) = L(M2)} Theorem: EQTM is unrecognizable Proof idea: reduction from ATM TMATM TMEQreduction f⟨M, w ⟩ ∈ {0, 1} ∗ ⟨M1, M2⟩ accept reject Deﬁne computable f such that ATM ATM EQTM EQTM f Lecture 6 Recap EQTM = {⟨M1, M2⟩ | M1, M2 are TMs s.t. L(M1) = L(M2)} Theorem: ATM ≤m EQTM (⇒ EQTM is unrecognizable) ▶ Let us deﬁne a function f as follows ▶ Given an input x = ⟨M, w ⟩, return f (x ) = ⟨M1, M2⟩, where ▶ M1 =“On input y : 1 Run M on w (ignore the input y ) 2 If M accepts then accept, else enter an inﬁnite loop ▶ M2 =“On input y : 1 Reject y ▶ ⇒ If ⟨M, w ⟩ ∈ ATM then M1 loops on all inputs. Thus, L(M1) = ∅ = L(M2) — ⟨M1, M2⟩ ∈ EQTM ▶ ⇐ If ⟨M, w ⟩ < ATM then M accepts w and hence M1 accepts every string. Thus L(M1) = Σ ∗ , ∅ = L(M2) — ⟨M1, M2⟩ < EQTM Lecture 6 Recap Summary of Reductions Summary Definition: 𝑓:Σ1 ⋆→ Σ2 ⋆is a computable function if some TM 𝑀, on every input 𝑤halts with just 𝑓(𝑤)on its tape Definition: 𝐴 is mapping reducible to 𝐵,(𝐴 ≤𝑚 𝐵),if there exists 𝑓:Σ1 ⋆→ Σ2 ⋆, 𝑓computable, s.t. ∀𝑤∈Σ⋆: 𝑤∈A⟺ 𝑓𝑤 ∈𝐵 𝑓is called a reduction of 𝐴 to 𝐵 Theorem: If 𝐴 ≤𝑚 𝐵 and 𝐵 is recognizable (decidable), then 𝐴 is recognizable (decidable) Theorem: If 𝐴 ≤𝑚 𝐵 and A is unrecognizable (undecidable) , then 𝐵 is unrecognizable (undecidable) 𝐴 𝐵𝑓 𝑓 Σ⋆ Σ ⋆ Deﬁnition: A function f : Σ∗ → Σ∗ is a computable function if some TM M, on every input w halts with just f (w ) on its tape Deﬁnition: Language A is mapping reducible to language B, written A ≤m B, if there is a computable function f : Σ∗ → Σ∗, such that for every w ∈ Σ∗: w ∈ A ⇔ f (w ) ∈ B f is called a reduction of A to B Theorem: If A ≤m B and B is decidable (recognizable), then A is decidable (recognizable) Corollary: If A ≤m B and A is undecidable (unrecognizable) then B is undecidable (unrecognizable) Lecture 6 Recap","libVersion":"0.5.0","langs":""}