{"path":"Exam/Solutions/examsol2021.pdf","text":"Final Exam, Theory of Computation 2021 • Books, notes, communication, calculators, cell phones, computers, etc... are not al- lowed. • Your explanations and proofs should be clear enough and in suﬃcient detail so that they are easy to understand and have no ambiguities. • You are allowed to refer to material covered in lectures (but not exercises) including theorems without reproving them. • Do not touch until the start of the exam. Good luck! Name: N◦ Sciper: Problem 1 Problem 2 Problem 3 Problem 4 Problem 5 Problem 6 / 15 points / 20 points / 20 points / 15 points / 15 points / 15 points Total / 100 Page 1 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 1 (15 pts) Quick-ﬁre round. Which of the following statements are true? 1. If A is a ﬁnite set, then A is regular. 2. The language {0n : n is divisible by 2021} is regular. 3. If A is regular and B ⊆ A then B is regular. 4. Let A be undecidable but recognisable. Then A is unrecognisable. 5. The language {⟨N, w⟩ : N is an NFA and N accepts w} is undecidable. 6. If A and B are decidable, then A ∩ B is decidable. 7. If A ∈ P then A∗ ∈ P where A∗ = {a1a2 · · · an : n ≥ 0, ai ∈ A} is the Kleene star. 8. HALT ≤m SAT. 9. If A ≤m B then B ≤m A. 10. k-SAT ≤p 3-SAT for any k ≥ 1. 11. If P = NP then NP = coNP. 12. If SAT ∈ P then P = NP. 13. If A and B are both NP-hard, then A ≤p B. 14. The language {⟨n⟩ : n ∈ N and n is not a prime number} is in NP. 15. A circuit of size m can be written equivalently as a CNF formula of size O(m2). For each box below, indicate whether the statement is either True, False, or if you are uncertain, leave the box empty. A correct answer is worth +1 point, an incorrect answer is worth −1 point, and an empty answer is worth 0 points. Your answers: 1. 2. 3. 4. 5. 6. 7. 8. 9. 10. 11. 12. 13. 14. 15. Solution: True statements: 1,2,4,6,7,10,11,12,14. Page 2 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 2 (20 pts) Basics of NP. 2a Write down the deﬁnition of the class NP and the deﬁnition a given problem to be NP- complete. If you use the concept of a veriﬁer or an NTM, then explain what it is. Solution: A language is in N P if it has a polynomial-time veriﬁer or equivalently a polynomial- time nondeterministic decider. A polynomial-time veriﬁer is a Turing Machine M such that given an input x, if x is in the language, then there exists a certiﬁcate C such that M accepts (x, C); if x is not in the language, then for every certiﬁcate C, M rejects (x, C). A nondeterministic decider is an NTM N such that for each input x, every computation of N on x halts, and if x is in the language, then some computation of N on x accepts; if x is not in the language, then every computation of N on x rejects. A problem L is NP-complete if L ∈ NP and for every L′ ∈ NP we have L′ ≤p L, meaning that there is a polynomial-time computable function f : {0, 1}∗ → {0, 1}∗ such that x ∈ L′ ⇐⇒ f (x) ∈ L. Page 3 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 2b The class of problems solvable in deterministic exponential time is deﬁned by EXP = ⋃ k≥1 TIME(2 nk ). Show that NP ⊆ EXP. Solution: Exponential time allows a solution by exhaustive search of any problem in NP as follows. Given a problem in NP — that is, given a problem, its certiﬁcate-checking Turing machine, and its polynomial bound — we enumerate all possible certiﬁcates, feeding each in turn to the certiﬁcate-checking Turing machine, until either the machine answers \"yes\" or we have exhausted all possible certiﬁcates. The key to the proof is that all possible certiﬁcates are succinct, so that they exist \"only\" in exponential number. Speciﬁcally, if the tape alphabet of the Turing machine has d symbols (including the blank) and the polynomial bound is described by p(), then an instance x has a total of dp(x) distinct certiﬁcates, each of length p(x). Generating them all requires time proportional to p(x) · dp(x), as does checking them all (since each can be checked in no more than p(x) time). Since p(|x|)·dp(|x|) is bounded by 2(q(|x|)) for a suitable choice of polynomial q, any problem in N P has a solution algorithm requiring at most exponential time. Page 4 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 3 (20 pts) Regular languages. For the following two languages, determine, with proof, whether they are regular. If a language is regular it suﬃces to draw a DFA or an NFA. You do not need to prove that your automaton is correct. 3a A = {0n : n is a power of 2} 3b B = {w ∈ {0, 1}∗ : w has an equal number of occurrences of 01 and 10 as substrings}. (For example, 010 has one occurrence of 01 and one occurrence of 10, so 010 ∈ B. On the other hand, 01101 has two occurrences of 01 and one occurrence of 10, so 01101 ̸∈ B.) Solution: 3a We will show that A is not regular. We assume towards a contradiction that A is regular. We can apply the pumping lemma to A. Let p be the pumping length of A. Let k := mini2i > p. Then by deﬁnition 0k ∈ A and |0k| > p. Thus we can apply the pumping lemma to 0k, which states that 0k can be partitioned into 0k = xyz, such that |xy| ≤ p, |y| ≥ 1 and for all i ∈ N we have xyiz ∈ A. Let us apply the lemma for i = 2. We bound the length of xy2z from above and from below: k = |xyz| < |xy2z| = |xyz| + |y| = k + |y| ≤ k + p < 2k, where in the last inequality we used the deﬁnition of k. Thus we know that the length of xy2z is strictly between two consecutive powers of 2 (i.e. k, 2k), which means that xy2z ̸∈ A. This, in turn, contradicts the statement of the pumping lemma, which implies that xy2z ∈ A. We arrived at a contradiction, which means that A is not regular. 3b Yes, such a DFA exists as shown on the ﬁgure below. State q0 is a start state and set of accept states is {q0, q1, q3}. Page 5 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 4 (15 pts) NP-completeness. Let G = (V, E) be a graph and w : E → N an assignment of non-negative integer weights to the edges. A subset of edges E′ ⊆ E is a spanning tree if the subgraph (V, E′) is a tree (no cycles) that connects all vertices. The weight of the spanning tree is∑ e∈E′ w(e). For example, the bold edges below form a spanning tree of weight 3 + 7 + 8 + 2 = 20. 2 2 3 0 5 7 78 In the Exact Spanning Tree problem (ESP for short), the input consists of a graph G = (V, E), edge weights w : E → N, and a target k ∈ N. The goal to decide whether G contains a spanning tree of weight exactly k. That is, ESP = {⟨G, w, k⟩ : G contains a spanning tree of weight exactly k}. Show that ESP is NP-complete. (You may use, without proof, the NP-completeness of any problem discussed in lectures.) Solution: We will ﬁrst show that ESP is in NP. We can take the certiﬁcate to be the subset of edges of the graph. To check that these subset of edges form a spanning tree, one can use the breadth ﬁrst search algorithm. To check that the sum of weights of these edges is k also requires going through these edges once and adding their weights. Both tasks in total take linear time in number of edges and vertices. Now we show that ESP is NP-hard by reducing from Subset-Sum. In an instance ⟨S, t⟩ of Subset-Sum, where S is a set of non-negative integers and t is a non-negative integer, one has to decide whether ∃ a subset T of S that sums to t. We will convert an instance of Subset-sum into ESP as follows. 1. For each integer i in S, add two separate vertices v and v′ to G. Add an edge of weight i between these two new vertices. 2. For every pair of vertices in G not connected by an edge, add an edge of weight 0. 3. Set k = t. The reduction clearly takes polynomial time. Now we prove that ⟨S, t⟩ ∈ Subset-Sum iﬀ ⟨G, k⟩ ∈ ESP. 1. If ⟨S, t⟩ ∈ Subset-Sum, ∃ a T ⊆ S that sums to t. Hence, a spanning tree in G can be formed by taking edges corresponding to integers in T and then connecting the isolated vertices by zero edges. 2. If ⟨G, k⟩ ∈ ESP, the sum of edges selected in the spanning tree sum to k. By taking the integers corresponding to the selected non-zero edges in S, one gets T that sums to t. Hence, ⟨S, t⟩ ∈ Subset-Sum. Page 6 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 5 (15 pts) Decidability. Consider the language L = {⟨M ⟩ : M is a Turing machine that halts on every input} Classify L as one of (i) decidable, (ii) undecidable but recognisable, (iii) unrecognisable. Justify your answer with a proof. Solution: Intuitively, L is harder than the halting language HALT , which is undecidable but recognizable. From the closure properties of recognizable languages we know that the complement HALT needs to be unrecognisable. We build a reduction φ from HALT to L. φ(⟨M, w⟩) is the Turing machine that on input x: • Runs M on w for |x| steps. • If M halts then it loops. • Otherwise, it halts. We show correctness: ⇒) If ⟨M, w⟩ ∈ HALT then M does not halt on w. Thus N halts on every input, so ⟨N ⟩ ∈ L. ⇐) If ⟨M, w⟩ /∈ HALT then M halts on w after some s steps. Then N accepts if and only if x < s. Therefore ⟨N ⟩ /∈ L. Page 7 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös 6 (15 pts) Circuit complexity. This problem asks you to show that regular languages admit linear-size circuits. That is, let L ⊆ {0, 1}∗ be a regular language. For any input length n ∈ N, show how to construct a boolean circuit Cn with n input variables, one output wire, and O(n) gates such that ∀x ∈ {0, 1} n : Cn(x) = 1 ⇐⇒ x ∈ L. Solution: Let D = (Q, {0, 1}, δ, q0, F ) be a DFA that recognizes L. For simplicity, let us assume that the k states are labelled with {e1, e2, . . . , ek} where ei ∈ {0, 1}k is the indicator bit-string which is 1 only at position i. Note that the transition function δ : {0, 1}k+1 → {0, 1}k can be computed by a circuit ∆ of constant size. Indeed, since the input size is k + 1 and the output size is k, the function is described by a truth table of size (2k)2k+1 ∈ O(1). To construct the circuit that recognizes L on inputs of length n, we mimic D by processing the input iteratively, updating the state each time with ∆. When the last bit of the input has been processed, we check the ﬁnal state and output 1 if and only if it belongs to F (this can be done with a constant number of gates), see Figure 1 for a depiction of the circuit. Since the circuit emulates D, it correctly computes L while using n · O(1) + O(1) = O(n) gates. x1 x2 · · · xn ∆ q0 ∆ · · · ∆ ∈ F Figure 1. Architecture of the circuit that accepts n-bit words of L. Page 8 (of 8) CS-251 Theory of Computation, Final Exam • Spring 2021 Mika Göös","libVersion":"0.5.0","langs":""}